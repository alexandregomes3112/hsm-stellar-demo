import * as enums from "../../enums";
import * as interfaces from "../../interfaces";
export default interface Blockchain {
    /**
     * Cria uma chave Extended Private Key (XPrv) para a blockchain no padrão BIP32.
     * @param {string} name Nome da chave no HSM.
     * @param {enums.BLOCKCHAIN_KEYS} type    Tipo de geração da chave.
     * @param {boolean} exportable Se a chave será exportável.
     * @param {boolean} temporary Se a chave será temporária.
     * @param {enums.VERSION_OPTIONS | null} version Versão da chave que deve ser passado de acordo com a opção do tipo
     * @param {string | null} seed Buffer contendo os dados necessários para a geração da chave. Os dados de entrada devem ser passados de acordo com a opção do type de {@link enums.BLOCKCHAIN_KEYS}.
     * @returns {Promise<boolean>} Chave criada.
     * @throws {@link exceptions.HsmError} Caso não seja possível criar a chave ou ocorra algum erro na operação.
     * @see Código de exemplo: [Criando uma chave blockchain](<../../../../pages/Criando uma chave blockchain.md>)
     */
    create(name: string, type: enums.BLOCKCHAIN_KEYS, exportable: boolean, temporary: boolean, version?: enums.VERSION_OPTIONS | null, seed?: string | null, passphrase?: string | null): Promise<boolean>;
    /**
     * Deleta uma chave armazenada no HSM.
     * @param {string} name Nome da chave.
     * @returns {Promise<boolean>} Retorna true se a chave foi deletada com sucesso.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na deleção da chave.
     * @see Código de exemplo: [Excluindo uma chave blockchain](<../../../../pages/Excluindo uma chave blockchain.md>)
     */
    delete(name: string): Promise<boolean>;
    /**
     * Bloqueia uma chave no HSM.
     * @param {string} name Nome da chave.
     * @returns {Promise<boolean>} Retorna true se a chave foi bloqueada com sucesso.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na deleção da chave.
     * @see Código de exemplo: [Bloqueando uma chave blockchain](<../../../../pages/Bloqueando uma chave blockchain.md>)
     */
    block(name: string): Promise<boolean>;
    /**
     * Desbloqueia uma chave no HSM.
     * @param {string} name Nome da chave.
     * @returns {Promise<boolean>} Retorna true se a chave foi desbloqueada com sucesso.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na deleção da chave.
     * @see Código de exemplo: [Desbloqueando uma chave blockchain](<../../../../pages/Desbloqueando uma chave blockchain.md>)
     */
    unblock(name: string): Promise<boolean>;
    /**
     * Faz uma operação de Child Key Derivation (CKD). Deriva uma chave Extended Private Key (XPrv) para a blockchain no padrão BIP32.
     * @param {enums.VERSION_OPTIONS} version Versão da chave.
     * @param {enums.BCHAIN_SECURE_BIP32_INDEX} index Índice da chave que será derivada. Chaves non hardened usam índice de 0 a 2<sup>31</sup>-1 e chaves hardened (irrestritamente seguras) usam índices de 2<sup>31</sup> a 2<sup>32</sup>-1, como especificado no padrão BIP32. É altamente recomendado gerar chaves hardened.
     * @param {boolean} exportable Se a chave será exportável.
     * @param {boolean} temporary Se a chave será temporária.
     * @param {string} childKeyName Nome da chave que será derivada no HSM.
     * @param {string} parentKeyName Nome da chave pai no HSM. Deve ser uma chave XPrv.
     * @returns {Promise<interfaces.blockchain.KeyInfo>} Informações da chave derivada.
     * @throws {@link exceptions.HsmError} Caso não seja possível derivar a chave ou ocorra algum erro na operação.
     * @see Código de exemplo: [Criando chave blockchain bip32 derivada](<../../../../pages/Criando chave blockchain bip32 derivada.md>)
     */
    createBip32ChildKeyDerivation(version: enums.VERSION_OPTIONS, index: enums.BCHAIN_SECURE_BIP32_INDEX | number, exportable: boolean, temporary: boolean, parentKeyName: string, childKeyName: string): Promise<interfaces.blockchain.KeyInfo>;
    /**
     * Calcula um hash usando o módulo blockchain.
     * @param {enums.BLOCKCHAIN_HASH_MODE} hashMode Modo do hash.
     * @param {Buffer} data Dados que serão processados. Tamanho máximo de {@link constants.BLOCKCHAIN_MAX_DATA_LEN}.
     * @returns {Promise<Buffer>} Hash calculado.
     * @throws {@link exceptions.HsmError} Caso não seja possível calcular o hash ou ocorra algum erro na operação.
     * @see Código de exemplo: [Gerando hash de dados](<../../../../pages/Gerando hash de dados.md>)
     */
    hashData(hashMode: enums.BLOCKCHAIN_HASH_MODE, data: Buffer): Promise<Buffer>;
    /**
     * Gera uma assinatura EdDSA usando o módulo blockchain.
     * @param {enums.BLOCKCHAIN_EdDSA_TYPE} type Tipo da assinatura a ser gerada.
     * @param {string} privKeyName Nome da chave privada.
     * @param {Buffer} data Dados que serão assinados.
     * @returns {Promise<Buffer>} Assinatura gerada.
     * @throws {@link exceptions.HsmError} Caso não seja possível assinar os dados ou ocorra algum erro na operação.
     * @see Código de exemplo: [Assinando hash com chave EdDSA blockchain](<../../../../pages/Assinando hash com chave EdDSA blockchain.md>)
     */
    edDsaSign(type: enums.BLOCKCHAIN_EdDSA_TYPE, privKeyName: string, data: Buffer): Promise<Buffer>;
    /**
     * Recupera uma chave pública a partir de uma chave privada usando o módulo blockchain.
     * @param {enums.BLOCKCHAIN_GET_PUB_KEY_TYPE} type Formato da chave pública a ser exportada.
     * @param {string} privKeyName Nome da chave privada.
     * @returns {Promise<Buffer>} Chave pública.
     * @throws {@link exceptions.HsmError} Caso a chave privada não seja encontrada ou ocorra algum erro na operação.
     * @see Código de exemplo: [Recuperando uma chave pública blockchain](<../../../../pages/Recuperando uma chave pública blockchain.md>)
     */
    getPubKey(type: enums.BLOCKCHAIN_GET_PUB_KEY_TYPE, privKeyName: string): Promise<Buffer>;
    /**
     * Verifica uma assinatura EdDSA usando o módulo blockchain.
     * @param {enums.BLOCKCHAIN_EdDSA_TYPE} type Tipo da assinatura a ser verificada.
     * @param {enums.BLOCKCHAIN_PUB_KEY_TYPE} pubKeyType Tipo da chave pública.
     * @param {Buffer} pubKey Chave pública. Deve ser uma chave pública válida retornada pelo método {@link Blockchain.getPubKey Blockchain.getPubKey}.
     * @param {Buffer} signature Assinatura a ser verificada. Deve ser uma assinatura válida retornada pelo método {@link Blockchain.edDsaSign Blockchain.edDsaSign}.
     * @param {Buffer} data Dados que foram assinados. Deve ser uma hash válida retornada pelo método {@link Blockchain.hashData Blockchain.hashData}.
     * @returns {Promise<boolean>} True se a assinatura for válida, false caso contrário.
     * @throws {@link exceptions.HsmError} Caso ocorra algum erro na operação.
     * @see Código de exemplo: [Verificando assinatura de hash com EdDSA blockchain](<../../../../pages/Verificando assinatura de hash com EdDSA blockchain.md>)
     */
    edDsaVerify(type: enums.BLOCKCHAIN_EdDSA_TYPE, pubKeyType: enums.BLOCKCHAIN_PUB_KEY_TYPE, pubKey: Buffer, signature: Buffer, data: Buffer): Promise<boolean>;
    /**
     * Recupera o endereço de uma chave usando o módulo blockchain.
     * @param {enums.ADDRESS_TYPE} type Tipo do endereço a ser gerado.
     * @param {enums.ADDRESS_VERSION} version Versão do endereço.
     * @param {enums.ADDRESS_HRP} hrp HRP (Human Readable Part) da chave.
     * @param {string} pk Chave privada da qual será gerado o endereço ou o script-hash.
     * @returns {Promise<Buffer>} Retorna o endereço.
     * @throws {@link exceptions.HsmError} Caso não seja possível recuperar o endereço ou ocorra algum erro na operação.
     * @see Código de exemplo: [Obtendo o endereço blockchain a partir da chave privada](<../../../../pages/Obtendo o endereço blockchain a partir da chave privada.md>)
     * <div style="border-left: 4px solid red;padding: 0 0 6px 10px;">
     * <h4 style="margin: 5px 0;">ATENÇÃO</h4>
     * Endereços P2TR (sem tweak de chave) devem ser usados com assinaturas BIP340/Schnorr apenas em cenários de single-key-setting (assinatura única).
     * </div>
     */
    getAddress(type: enums.ADDRESS_TYPE, version: enums.ADDRESS_VERSION, hrp: enums.ADDRESS_HRP, pk: string): Promise<Buffer>;
    /**
     * Assina um hash usando o módulo blockchain.
     * @param {enums.BLOCKCHAIN_SIG_TYPE} type Tipo da assinatura a ser realizada.
     * @param {enums.BLOCKCHAIN_HASH_MODE} hashMode Modo do hash.
     * @param {Buffer} hash Hash calculado de acordo com o informado em hashMode ({@link enums.BLOCKCHAIN_HASH_MODE}).
     * @param {string} pk Nome da chave privada.
     * @throws {@link exceptions.HsmError} Caso não seja possível assinar os dados ou ocorra algum erro na operação.
     * @see Código de exemplo: [Assinando hash com chave ECDSA blockchain](<../../../../pages/Assinando hash com chave ECDSA blockchain.md>)
     */
    sign(type: enums.BLOCKCHAIN_SIG_TYPE, hashMode: enums.BLOCKCHAIN_HASH_MODE, hash: Buffer, pk: string): Promise<Buffer>;
    /**
     * Recupera as propriedades de uma chave usando o módulo blockchain.
     * @param {string} name Nome da chave privada.
     * @returns {Promise<interfaces.blockchain.KeyInfo>} Retorna um objeto com os dados de blockchain da chave.
     * @throws {@link exceptions.HsmError} Caso não seja possível recuperar o endereço ou ocorra algum erro na operação.
     * @see Código de exemplo: [Obtendo informações de uma chave blockchain](<../../../../pages/Obtendo informações de uma chave blockchain.md>)
     */
    getKeyInfo(name: string): Promise<interfaces.blockchain.KeyInfo>;
    /**
     * Importa uma chave privada usando o módulo blockchain_interfaces.
     * @param {enums.IMPORT_EXPORT_FORMAT} format Formato da chave a ser importada.
     * @param {boolean} exportable Se a chave será exportável.
     * @param {boolean} temporary Se a chave será temporária.
     * @param {string} name Nome da chave privada.
     * @param {string} data Chave privada no formato especificado em {@link enums.IMPORT_EXPORT_FORMAT}.
     * @returns {Promise<boolean>} True se a importação foi efetuada ou uma exceção caso o contrário.
     * @throws {@link exceptions.HsmError} Caso ocorra algum erro na operação.
     * @see Código de exemplo: [Importando chave privada blockchain](<../../../../pages/Importando chave privada blockchain.md>)
     */
    import(format: enums.IMPORT_EXPORT_FORMAT, exportable: boolean, temporary: boolean, name: string, data: string): Promise<boolean>;
    /**
     * Exporta uma chave privada usando o módulo blockchain.
     * @param {enums.IMPORT_EXPORT_FORMAT} format Formato da chave a ser exportada.
     * @param {enums.BLOCKCHAIN_EXPORT_VERSION} version Versão da chave.
     * @param {boolean} compressed Se a chave deve ser retornada comprimida.
     * @param {string} name Nome da chave privada.
     * @returns {Promise<Buffer>} Buffer com a chave privada.
     * @throws {@link exceptions.HsmError} Caso ocorra algum erro na operação.
     * @see Código de exemplo: [Exportando chave privada blockchain](<../../../../pages/Exportando chave privada blockchain.md>)
     */
    export(format: enums.IMPORT_EXPORT_FORMAT, version: enums.BLOCKCHAIN_EXPORT_VERSION, compressed: boolean, name: string): Promise<Buffer>;
    /**
     * Verifica uma assinatura usando o módulo blockchain.
     * @param {enums.BLOCKCHAIN_SIG_TYPE} sigType Tipo da assinatura que foi realizada.
     * @param {enums.BLOCKCHAIN_HASH_MODE} hashMode Modo do hash.
     * @param {Buffer} hashData Hash calculado conforme o informado em hashData.
     * @param {Buffer} signature Assinatura conforme o informado em sigType ({@link enums.BLOCKCHAIN_SIG_TYPE}).
     * @param {enums.BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE} pubKeyType Tipo da chave pública.
     * @param {Buffer} pubSignature Chave pública conforme o informado em **pubKeyType**.
     * @returns {Promise<boolean>} True se a assinatura for válida, false caso contrário.
     * @throws {@link exceptions.HsmError} Caso ocorra algum erro na operação.
     * @see Código de exemplo: [Verificando assinatura ECDSA blockchain](<../../../../pages/Verificando assinatura ECDSA blockchain.md>)
     */
    verify(sigType: enums.BLOCKCHAIN_SIG_TYPE, hashMode: enums.BLOCKCHAIN_HASH_MODE, hashData: Buffer, signature: Buffer, pubKeyType: enums.BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE, pubSignature: Buffer): Promise<boolean>;
    /**
     * Recupera uma chave pública (PBK) a partir de uma assinatura do tipo ECDSA.
     * @param {enums.BLOCKCHAIN_SIG_TYPE} sigType Tipo da assinatura a ser gerada.
     * @param {enums.BLOCKCHAIN_HASH_MODE} hashMode Modo do hash.
     * @param {Buffer} hashData Hash calculado conforme o informado em hashData.
     * @param {Buffer} signature Assinatura conforme o informado em sigType ({@link enums.BLOCKCHAIN_SIG_TYPE}).
     * @returns {Promise<Buffer>} Retorna um buffer com a chave pública.
     * @throws {@link exceptions.HsmError} Caso ocorra algum erro na operação.
     * @see Código de exemplo: [Recuperando chave pública a partir de assinatura](<../../../../pages/Recuperando chave pública a partir de assinatura.md>)
     */
    pubKeyRecovery(sigType: enums.BLOCKCHAIN_SIG_TYPE, hashMode: enums.BLOCKCHAIN_HASH_MODE, hashData: Buffer, signature: Buffer): Promise<Buffer>;
    /**
     * Calcula um ponto a partir de outro ponto e um contexto randómico.
     * @param {string | Buffer} x Ponto X que pode ser um buffer de {@link constants.ABN128_XY_BUFF_LEN} bytes ou uma string hexadecimal de {@link constants.ABN128_XY_HEX_LEN} caracteres.
     * @param {string | Buffer} y Ponto Y que pode ser um buffer de {@link constants.ABN128_XY_BUFF_LEN} bytes ou uma string hexadecimal de {@link constants.ABN128_XY_HEX_LEN} caracteres.
     * @returns {Promise<Buffer>} Retorna um buffer com o ponto calculado.
     * @throws {exceptions.InvalidKeyNameError} Caso algum parâmetro informado seja invalido.
     * @throws {@link exceptions.InvalidParameterError} Caso algum parâmetro informado seja invalido.
     * @throws {@link exceptions.HsmError} Caso ocorra algum erro na operação.
     */
    abn128RndCtxGetPt(x: string | Buffer, y: string | Buffer): Promise<Buffer>;
    /**
     * Multiplica um escalar pela chave privada e soma um escalar randômico.
     * @param {string} keyName Nome da chave que será usada para a operação.
     * @param {string | Buffer} scalar Escalar que pode ser um buffer de {@link constants.ABN128_XY_BUFF_LEN} bytes ou uma string hexadecimal de {@link constants.ABN128_XY_HEX_LEN} caracteres.
     * @returns {Promise<Buffer>} Retorna um buffer com o resultado da operação.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
     * @throws {@link exceptions.InvalidParameterError} Caso algum parâmetro informado seja invalido.
     * @throws {@link exceptions.HsmError} Caso ocorra algum erro na operação.
     */
    abn128RndCtxMultAdd(keyName: string, scalar: string | Buffer): Promise<Buffer>;
    /**
     * Retrona quatro escalares randômicos.
     * @returns {Promise<Array<Buffer>>} Retorna um array de bufferes com os escalares randômicos.
     * @throws {@link exceptions.HsmError} Caso ocorra algum erro na operação.
     */
    abn128RndScs(): Promise<Array<Buffer>>;
    /**
     * Retrona um escalar randômico.
     * @returns {Promise<Buffer>} Retorna um buffer com o escalare randômico.
     * @throws {@link exceptions.HsmError} Caso ocorra algum erro na operação.
     */
    abn128RndSc(): Promise<Buffer>;
    /**
     * Atualiza o contexto randômico.
     * @param {string | Buffer} x Ponto X que pode ser um buffer de {@link constants.ABN128_XY_BUFF_LEN} bytes ou uma string hexadecimal de {@link constants.ABN128_XY_HEX_LEN} caracteres.
     * @param {string | Buffer} y Ponto Y que pode ser um buffer de {@link constants.ABN128_XY_BUFF_LEN} bytes ou uma string hexadecimal de {@link constants.ABN128_XY_HEX_LEN} caracteres.
     * @returns {Promise<Buffer>} Retorna um buffer com o ponto calculado.
     * @throws {exceptions.InvalidKeyNameError} Caso algum parâmetro informado seja invalido.
     * @throws {@link exceptions.InvalidParameterError} Caso algum parâmetro informado seja invalido.
     * @throws {@link exceptions.HsmError} Caso ocorra algum erro na operação.
     */
    abn128RndCtxRefresh(x: string | Buffer, y: string | Buffer): Promise<Buffer>;
    /**
     * Multiplica um escalar pela chave privada.
     * @param {string} keyName Nome da chave que será usada para a operação.
     * @param {string | Buffer} x Ponto X que pode ser um buffer de {@link constants.ABN128_XY_BUFF_LEN} bytes ou uma string hexadecimal de {@link constants.ABN128_XY_HEX_LEN} caracteres.
     * @param {string | Buffer} y Ponto Y que pode ser um buffer de {@link constants.ABN128_XY_BUFF_LEN} bytes ou uma string hexadecimal de {@link constants.ABN128_XY_HEX_LEN} caracteres.
     * @param {boolean} neg Se a chave privada deve ser negativada.
     * @returns {Promise<Buffer>} Retorna um buffer com o ponto calculado.
     * @throws {exceptions.InvalidKeyNameError} Caso algum parâmetro informado seja invalido.
     * @throws {@link exceptions.InvalidParameterError} Caso algum parâmetro informado seja invalido.
     * @throws {@link exceptions.HsmError} Caso ocorra algum erro na operação.
     */
    abn128PscMult(keyName: string, x: string | Buffer, y: string | Buffer, neg?: boolean): Promise<Buffer>;
}
