import * as interfaces from "../../interfaces";
import * as enums from "../../enums";
export default interface Cryptography {
    /**
     * Faz a divisão M de N de um segredo. Conforme o padrão de compartilhamento de segredos de Shamir.
     * @param {number} m Quantidade mínima de partes necessárias para reconstrução do segredo. Mínimo de {@link constants.M_OF_N_SECRET_MIN_N} e o máximo deve ser menor ou igual a n.
     * @param {number} n Quantidade total de partes geradas. Mínimo de {@link constants.M_OF_N_SECRET_MIN_N} e máximo de {@link constants.M_OF_N_SECRET_MAX_N}.
     * @param {string} secret Segredo que será compartilhado em várias partes. Deve ter tamanho de {@link constants.M_OF_N_SECRET_LEN} caracteres. Pode ser passado `NULL` para que um segredo seja gerado randomicamente pelo HSM, neste caso o valor será retornado em {@link interfaces.cryptography.MofNSplit}.
     * @returns {Promise<Buffer>} Retorna um buffer com o segredo dividido.
     * @throws {@link exceptions.HsmError} Caso não seja possível dividir o segredo ou ocorra algum erro na operação.
     * @see Código de exemplo: [Dividindo um segredo em M de N](<../../../../pages/Dividindo um segredo em M de N.md>)
     */
    mOfnSplit(m: number, n: number, secret?: string | null): Promise<interfaces.cryptography.MofNSplit>;
    /**
     * Reconstrói o segredo M de N a partir das partes dos custodiantes. Conforme o padrão de compartilhamento de segredos de Shamir.
     * @param {Buffer[]} parts Array de buffers com as partes do segredo geradas pela função {@link Cryptography.mOfnSplit}.
     * @returns {Promise<Buffer>} Retorna um buffer com o segredo reconstruído.
     * @throws {@link exceptions.HsmError} Caso não seja possível reconstruir o segredo ou ocorra algum erro na operação.
     * @see Código de exemplo: [Reconstruindo um segredo em M de N](<../../../../pages/Reconstruindo um segredo em M de N.md>)
     */
    mOfNRecover(parts: Buffer[]): Promise<Buffer>;
    /**
     * Assina um dado utilizando uma chave privada RSA.
     * @param {string} keyName Nome da chave.
     * @param {enums.HASH_ALGORITHMS} hashAlgorithm Algoritmo utilizado para gerar a hash do dado.
     * @param {Buffer} hash Hash do dado que será assinado.
     * @param {enums.PAD_TYPE} pad Tipo de padding que será utilizado na assinatura.
     * @returns {Promise<Buffer>} Retorna um buffer com a assinatura do dado.
     * @throws {@link exceptions.HsmError} Caso não seja possível assinar o dado ou ocorra algum erro na operação.
     * @see Código de exemplo: [Assinando hash com RSA](<../../../../pages/Assinando hash com RSA.md>)
     */
    rsaSign(keyName: string, hashAlgorithm: enums.HASH_ALGORITHMS, hash: Buffer, pad: enums.PAD_TYPE): Promise<Buffer>;
    /**
     * Verifica uma assinatura de um dado utilizando uma chave RSA.
     * @param {string} keyName Nome da chave.
     * @param {enums.HASH_ALGORITHMS} hashAlgorithm Algoritmo utilizado para gerar a hash do dado.
     * @param {enums.PAD_TYPE} pad Tipo de padding que será utilizado na assinatura.
     * @param {Buffer} hash Hash do dado que será verificado.
     * @param {Buffer} signature Assinatura do dado que será verificado.
     * @returns {Promise<boolean>} Retorna `true` caso a assinatura seja válida e `false` caso contrário.
     * @throws {@link exceptions.HsmError} Caso não seja possível verificar a assinatura ou ocorra algum erro na operação.
     * @see Código de exemplo: [Verificando assinatura de hash com RSA](<../../../../pages/Verificando assinatura de hash com RSA.md>)
     */
    rsaVerify(keyName: string, hashAlgorithm: enums.HASH_ALGORITHMS, pad: enums.PAD_TYPE, hash: Buffer, signature: Buffer): Promise<boolean>;
    /**
     * Assina um dado utilizando uma chave privada ECC.
     * @param {string} keyName Nome da chave.
     * @param {enums.HASH_ALGORITHMS} hashAlgorithm Algoritmo utilizado para gerar a hash do dado.
     * @param {Buffer} hash Hash do dado que será assinado.
     * @returns {Promise<Buffer>} Retorna um buffer com a assinatura do dado.
     * @throws {@link exceptions.HsmError} Caso não seja possível assinar o dado ou ocorra algum erro na operação.
     * @see Código de exemplo: [Assinando hash com ECC](<../../../../pages/Assinando hash com ECC.md>)
     */
    eccSign(keyName: string, hashAlgorithm: enums.HASH_ALGORITHMS, hash: Buffer): Promise<Buffer>;
    /**
     * Verifica uma assinatura de um dado utilizando uma chave ECC.
     * @param {string} keyName Nome da chave.
     * @param {enums.HASH_ALGORITHMS} hashAlgorithm Algoritmo utilizado para gerar a hash do dado.
     * @param {Buffer} hash Hash do dado que será verificado.
     * @param {Buffer} signature Assinatura do dado que será verificado.
     * @returns {Promise<boolean>} Retorna `true` caso a assinatura seja válida e `false` caso contrário.
     * @throws {@link exceptions.HsmError} Caso não seja possível verificar a assinatura ou ocorra algum erro na operação.
     * @see Código de exemplo: [Verificando assinatura de hash com ECC](<../../../../pages/Verificando assinatura de hash com ECC.md>)
     */
    eccVerify(keyName: string, hashAlgorithm: enums.HASH_ALGORITHMS, hash: Buffer, signature: Buffer): Promise<boolean>;
    /**
     * Assina um dado utilizando uma chave privada EdDSA.
     * @param {string} keyName Nome da chave.
     * @param {Buffer} hash Hash do dado que será assinado.
     * @returns {Promise<Buffer>} Retorna um buffer com a assinatura do dado.
     * @throws {@link exceptions.HsmError} Caso não seja possível assinar o dado ou ocorra algum erro na operação.
     * @see Código de exemplo: [Assinando hash com EdDSA](<../../../../pages/Assinando hash com EdDSA.md>)
     */
    eddsaSign(keyName: string, hash: Buffer): Promise<Buffer>;
    /**
     * Verifica uma assinatura de um dado utilizando uma chave EdDSA.
     * @param {string} keyName Nome da chave.
     * @param {Buffer} hash Hash do dado que será verificado.
     * @param {Buffer} signature Assinatura do dado que será verificado.
     * @returns {Promise<boolean>} Retorna `true` caso a assinatura seja válida e `false` caso contrário.
     * @throws {@link exceptions.HsmError} Caso não seja possível verificar a assinatura ou ocorra algum erro na operação.
     * @see Código de exemplo: [Verificando assinatura de hash com EdDSA](<../../../../pages/Verificando assinatura de hash com EdDSA.md>)
     */
    eddsaVerify(keyName: string, hash: Buffer, signature: Buffer): Promise<boolean>;
    /**
     * Desenvelopa dados utilizando uma chave RSA.
     * @param {string} keyName Nome da chave privada RSA.
     * @param {Buffer} data Dado que será desenvelopado.
     * @param {enums.ENC_DEC_PADDING} paddingOption Opção de preenchimento usada na criptografia dos dados.
     * @returns {Promise<Buffer>} Retorna o dado desenvelopado.
     * @throws {@link exceptions.HsmError} Caso não seja possível desenvelopar o dado ou ocorra algum erro na operação.
     */
    dataUnenvelop(keyName: string, data: Buffer, paddingOption: enums.ENC_DEC_PADDING): Promise<Buffer>;
    /**
     * Envelopa dados utilizando uma chave pública RSA.
     * @param {Buffer} pubKey Chave pública RSA que será utilizada para envelopar o dado.
     * @param {Buffer} data Dado que será envelopado.
     * @param {enums.ENC_DEC_PADDING} paddingOption Opção de preenchimento usada na criptografia dos dados.
     * @returns {Promise<Buffer>} Retorna o dado envelopado.
     * @throws {@link exceptions.HsmError} Caso não seja possível envelopar o dado ou ocorra algum erro na operação.
     */
    dataEnvelop(pubKey: Buffer, keyLength: enums.RSA_LENGTH_KEYS, data: Buffer, paddingOption: enums.ENC_DEC_PADDING): Promise<Buffer>;
    /**
     * Retorna um conjunto de bytes pseudo-aleatorios de tamanho len para uso em criptografia.
     * @param {string} len Número de bytes a serem gerados. O valor deverá estar entre 0 e 4294967295
     * @returns {Promise<Buffer>} Retorna um buffer contendo um conjunto de bytes pseudo-aleatórios de tamanho len.
     * @throws {@link exceptions.HsmError} Caso não seja possível recuperar os bytes ou ocorra algum erro na operação.
     * @see Código de exemplo: [Gerando um conjunto de bytes aleatórios](<../../../../pages/Gerando um conjunto de bytes aleatórios.md>)
     */
    genRand(len: number): Promise<Buffer>;
}
