import * as enums from "../../enums";
import * as interfaces from "../index";
export default interface Key {
    /**
     * Cria e armazena uma chave criptográfica associada a um algoritmo conforme os parâmetros informados, dentro do HSM.
     * @param {string} name Nome da chave.
     * @param {enums.SYMMETRICAL_KEYS | enums.RSA_ASYMMETRIC_KEYS | enums.ECC_ASYMMETRIC_SWITCHES | enums.ECX_ASYMMETRIC_SWITCHES | enums.HMAC_KEYS} algorithm Algoritmo da chave.
     * @param {boolean} exportable Se a chave será exportável.
     * @param {boolean} temporary Se a chave será temporária.
     * @param {boolean} blockchain Se a chave poderá ser usada em operações de blockchain.
     * <br><span style=color:#ffeb3b;><br>*ATENÇÃO:*</span> Apenas algumas chaves serão permitadas caso `blockchain` sejá informado:
     * <ul>
     *  <li>{@link enums.ECC_ASYMMETRIC_SWITCHES.ALG_ECC_SECP256K1}</li>
     *  <li>{@link enums.ECC_ASYMMETRIC_SWITCHES.ALG_ECC_SECP256R1}</li>
     *  <li>{@link enums.ECX_ASYMMETRIC_SWITCHES.ALG_ECX_ED25519}</li>
     *   <li>{@link enums.ECC_ASYMMETRIC_PBC_SWITCHES.ALT_BN128}</li>
     * </ul>
     * @returns {Promise<boolean>} Retorna true se a chave foi criada com sucesso.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na criação da chave.
     * @see Código de exemplo: [Criando uma chave](<../../../../pages/Criando uma chave.md>)
     */
    create(name: string, algorithm: enums.SYMMETRICAL_KEYS | enums.RSA_ASYMMETRIC_KEYS | enums.ECC_ASYMMETRIC_SWITCHES | enums.ECX_ASYMMETRIC_SWITCHES | enums.HMAC_KEYS | enums.ECC_ASYMMETRIC_PBC_SWITCHES, exportable?: boolean, temporary?: boolean, blockchain?: boolean): Promise<boolean>;
    /**
     * Deleta uma chave armazenada no HSM.
     * @param {string} name Nome da chave.
     * @returns {Promise<boolean>} Retorna true se a chave foi deletada com sucesso.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na deleção da chave.
     * @see Código de exemplo: [Excluindo uma chave](<../../../../pages/Excluindo uma chave.md>)
     */
    delete(name: string): Promise<boolean>;
    /**
     * Bloqueia uma chave no HSM.
     * @param {string} name Nome da chave.
     * @returns {Promise<boolean>} Retorna true se a chave foi bloqueada com sucesso.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na deleção da chave.
     * @see Código de exemplo: [Bloqueando uma chave](<../../../../pages/Bloqueando uma chave.md>)
     */
    block(name: string): Promise<boolean>;
    /**
     * Desbloqueia uma chave no HSM.
     * @param {string} name Nome da chave.
     * @returns {Promise<boolean>} Retorna true se a chave foi desbloqueada com sucesso.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na deleção da chave.
     * @see Código de exemplo: [Desbloqueando uma chave](<../../../../pages/Desbloqueando uma chave.md>)
     */
    unblock(name: string): Promise<boolean>;
    /**
     * Importa uma chave criptográfica para dentro do HSM.
     * @param {string} name Nome da chave.
     * @param {enums.SYMMETRICAL_KEYS | enums.RSA_ASYMMETRIC_KEYS | enums.HMAC_KEYS} algorithm Algoritmo da chave. Mesmo algoritmo usado na criação da chave pela função {@link create}
     * @param {Buffer} data Dados da chave a ser importada.
     * @param {boolean} exportable Se a chave será exportável.
     * @param {boolean} temporary Se a chave será temporária.
     * @param {boolean} blockchain Se a chave poderá ser usada em operações de blockchain.
     * @returns {Promise<boolean>} Retorna true se a chave foi importada com sucess
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.o.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na importação da chave.
     * @see Código de exemplo: [Importando uma chave simétrica](<../../../../pages/Importando uma chave simétrica.md>)
     */
    import(name: string, algorithm: enums.SYMMETRICAL_KEYS | enums.RSA_ASYMMETRIC_KEYS | enums.HMAC_KEYS | enums.ECC_ASYMMETRIC_PBC_SWITCHES, data: Buffer, exportable?: boolean, temporary?: boolean, blockchain?: boolean): Promise<boolean>;
    /**
     * Importa um certificado para o HSM.
     * @param {string} name Nome do certificado.
     * @param {Buffer} certData Certificado a ser importado.
     * @returns {Promise<boolean>} Retorna true se o certificado foi importado com sucesso.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome do certificado seja inválido.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na importação do certificado.
     * @see Código de exemplo: [Importando um certificado](<../../../../pages/Importando um certificado.md>)
     */
    importCertificate(name: string, certData: Buffer): Promise<boolean>;
    /**
     * Gera um CSR (Certificate Signing Request / Requisição de Assinatura de Certificado).<br />
     * É uma função especializada da API de geração de CSR PKCS#10 do HSM.
     * @param {string} keyName Nome da chave.
     * @param {interfaces.key.X500DistinguishedName} dn Dados do certificado.
     * @param {enums.PKCS10_HASH_ALGORITHM} hashAlgorith Algoritmo de hash a ser usado na geração do CSR. Caso não seja informado, será usado o algoritmo padrão do HSM.
     * @returns {Promise<Buffer>} Retorna o CSR no formato DER.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
     * @see Código de exemplo: [Gerando um PKCS#10](<../../../../pages/Gerando um P10.md>)
     */
    generatePKCS10(keyName: string, dn: interfaces.key.X500DistinguishedName, hashAlgorith?: enums.PKCS10_HASH_ALGORITHM): Promise<Buffer>;
    /**
     * Exporta uma chave criptográfica armazenada no HSM.
     * @param {string} name Nome da chave.
     * @param {boolean} x509 Se a chave será exportada no formato X509.
     * @returns {Promise<Buffer>} Buffer contendo os dados da chave conforme o formato {@link enums.KEY_EXPORT_FORMAT}.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.o.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na importação da chave.
     * @see Código de exemplo: [Exportando chave pública assimétrica](<../../../../pages/Exportando chave pública assimétrica.md>)
     */
    exportAsymmetricPub(name: string, x509: boolean): Promise<Buffer>;
    /**
     * Exporta a parte privada chave assimétrica armazenada no HSM.
     * @param {string} name Nome da chave.
     * @returns {Promise<Buffer>} Buffer contendo os dados da chave conforme o formato {@link enums.KEY_EXPORT_FORMAT}.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.o.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na importação da chave.
     * @see Código de exemplo: [Exportando chave privada assimétrica](<../../../../pages/Exportando chave privada assimétrica.md>)
     */
    exportAsymmetricPriv(name: string): Promise<Buffer>;
    /**
     * Exporta em texto claro a chave privada armazenada no HSM.
     * @param {string} name Nome da chave.
     * @returns {Promise<Buffer>} Buffer contendo os dados da chave conforme o formato {@link enums.KEY_EXPORT_FORMAT}.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.o.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na importação da chave.
     * @see Código de exemplo: [Exportando chave simétrica](<../../../../pages/Exportando chave simétrica.md>)
     */
    exportSymmetric(name: string): Promise<Buffer>;
    /**
     * Exporta em texto claro o certificado armazenada no HSM.
     * @param {string} name Nome da chave.
     * @returns {Promise<Buffer>} Buffer contendo o certificado.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.o.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na importação da chave.
     * @see Código de exemplo: [Exportando certificado em texto claro](<../../../../pages/Exportando certificado em texto claro.md>)
     */
    exportCertClearText(name: string): Promise<Buffer>;
    /**
     * Importa uma chave encriptada por uma KEK (Key Encryption Key).
     * @param {enums.KEK_MODE | enums.KEK_WRAP_MODE} mode Modo de operação para a importação da chave.
     * @param {enums.KEK_WRAP_PADDING} pad Opção de padding para a operação de KEK.
     * @param {string} name Nome da chave.
     * @param {string} kekKeyName Nome da Key Encryption Key (KEK) que será usada para descriptografar a chave importada.
     * @param {number} objType Tipo do objeto.
     * @param {Buffer} data Buffer que contém os dados da chave criptografada que será importada.
     * @param {string} iv Vetor de inicialização (Initialization Vector). Obriatório para o modo {@link enums.KEK_MODE.MODE_CBC}.
     * @param {boolean} exportable Se a chave será exportável.
     * @param {boolean} temporary Se a chave será temporária.
     * @param {boolean} blockchain Se a chave poderá ser usada em operações de blockchain.
     * @returns {Promise<boolean>} Retorna true se a chave foi importada.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na importação da chave.
     * @see Código de exemplo: [Importando chave KEKed](<../../../../pages/Importando chave KEKed.md>)
     */
    importKekWrap(mode: enums.KEK_MODE | enums.KEK_WRAP_MODE, pad: enums.KEK_WRAP_PADDING, name: string, kekKeyName: string, objType: enums.SYMMETRICAL_KEYS | enums.RSA_ASYMMETRIC_KEYS | enums.ECC_ASYMMETRIC_SWITCHES | enums.ECX_ASYMMETRIC_SWITCHES, data: Buffer, iv?: string, exportable?: boolean, temporary?: boolean, blockchain?: boolean): Promise<boolean>;
    /**
     * Exporta uma chave encriptada por uma KEK (Key Encryption Key).
     * @param {enums.KEK_MODE | enums.KEK_WRAP_MODE} mode Modo de operação para a importação da chave.
     * @param {enums.KEK_WRAP_PADDING} pad Opção de padding para a operação de KEK.
     * @param {string} name Nome da chave.
     * @param {string} kekKeyName Nome da Key Encryption Key (KEK) que será usada para descriptografar a chave importada.
     * @returns {Promise<Buffer>} Buffer contendo os dados da chave conforme o formato {@link enums.KEY_EXPORT_FORMAT}.
     * @param {string} iv Vetor de inicialização (Initialization Vector). Obriatório para o modo {@link enums.KEK_MODE.MODE_CBC}.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.o.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na importação da chave.
     * @see Código de exemplo: [Exportando chave KEKed](<../../../../pages/Exportando chave KEKed.md>)
     */
    exportKekWrap(mode: enums.KEK_MODE | enums.KEK_WRAP_MODE, pad: enums.KEK_WRAP_PADDING, name: string, kekKeyName: string, iv?: string): Promise<Buffer>;
    /**
       * Import uma chave PKCS#8 para o HSM.
       * @param {string} name Nome da chave.
       * @param {enums.RSA_ASYMMETRIC_KEYS | enums.ECC_ASYMMETRIC_SWITCHES} keyType Tipo da chave.
       * @param {string} password Senha da chave. Mínimo de ${@link constants.P8_IMPORT_EXPORT_SECRET_MIN_LEN} caracteres, máximo de ${@link constants.P8_IMPORT_EXPORT_SECRET_MAX_LEN} caracteres.
       * @param {boolean} exportable Se a chave será exportável.
       * @param {boolean} temporary Se a chave será temporária.
       * @param {boolean} blockchain Se a chave poderá ser usada em operações de blockchain.
       * <br><span style=color:#ffeb3b;><br>*ATENÇÃO:*</span> Apenas algumas chaves serão permitadas caso `blockchain` sejá informado:
       * <ul>
       *  <li>{@link enums.ECC_ASYMMETRIC_SWITCHES.ALG_ECC_SECP256K1}</li>
       *  <li>{@link enums.ECC_ASYMMETRIC_SWITCHES.ALG_ECC_SECP256R1}</li>
       *  <li>{@link enums.ECX_ASYMMETRIC_SWITCHES.ALG_ECX_ED25519}</li>
       <li>{@link enums.ECC_ASYMMETRIC_PBC_SWITCHES.ALT_BN128}</li>
       * </ul>
       * @param {string} p8 Dados da chave no formato PKCS#8 (base64).
       * @returns {Promise<boolean>} Retorna true se a chave foi importada com sucesso.
       * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
       * @throws {exceptions.InvalidParameterError} Caso a senha da chave seja não obedeçam aos requisitos mínimos.
       * @throws {exceptions.HsmError} Caso ocorra algum erro na importação da chave.
       */
    importPKCS8(name: string, keyType: enums.RSA_ASYMMETRIC_KEYS | enums.ECC_ASYMMETRIC_SWITCHES, password: string, p8: string, exportable?: boolean, temporary?: boolean, blockchain?: boolean): Promise<boolean>;
    /**
     * Exporta uma chave PKCS#8 do HSM.
     * @param {string} name Nome da chave. Mínimo de ${@link constants.P8_IMPORT_EXPORT_SECRET_MIN_LEN} caracteres, máximo de ${@link constants.P8_IMPORT_EXPORT_SECRET_MAX_LEN} caracteres.
     * @param {string} password Senha da chave.
     * @returns {Promise<boolean>} Retorna um buffer contendo os dados da chave.
     * @throws {exceptions.InvalidKeyNameError} Caso o nome da chave seja inválido.
     * @throws {exceptions.InvalidParameterError} Caso a senha da chave seja não obedeçam aos requisitos mínimos.
     * @throws {exceptions.HsmError} Caso ocorra algum erro na importação da chave.
     */
    exportPKCS8(name: string, password: string): Promise<Buffer>;
    /**
     * Importa uma chave privada e seu certificado correspondente no formato PKCS#12 para o HSM.
     *
     * O PKCS#12 (Public-Key Cryptography Standards #12) é um formato de arquivo padrão para armazenar chaves privadas, certificados e outros segredos criptográficos.
     * Ele permite que múltiplos objetos sejam armazenados em um único arquivo e protegidos por uma senha.
     *
     * @param {string} keyName O nome da chave a ser criada no HSM. Este nome deve ser único e seguir as regras de nomenclatura do HSM.
     * @param {string} certName O nome do certificado a ser criado no HSM. Este nome deve ser único e seguir as regras de nomenclatura do HSM.
     * @param {string} password A senha que protege o arquivo PKCS#12. O comprimento da senha deve estar entre `P8_IMPORT_EXPORT_SECRET_MIN_LEN` e `P8_IMPORT_EXPORT_SECRET_MAX_LEN`.
     * @param {Buffer} p12 O conteúdo do arquivo PKCS#12 no formato de um Buffer. Este buffer deve conter os dados binários do arquivo PKCS#12.
     * @param {string} pubKey Chave pública do certificado no formato hexadecimal.
     * @param {boolean} exportable Se a chave será exportável.
     * @param {boolean} temporary Se a chave será temporária.
     * @returns {Promise<boolean>} Uma promessa que resolve para `true` se a importação for bem-sucedida.
     * @throws {exceptions.InvalidKeyNameError} Se o nome da chave ou do certificado for inválido.
     * @throws {exceptions.InvalidParameterError} Se a senha for inválida (nula, vazia ou com comprimento fora dos limites).
     * @throws {exceptions.HsmError} Se ocorrer um erro durante a importação, como um erro de comunicação com o HSM ou uma senha incorreta.
     *
     * @see Código de exemplo: [Importando um PKCS#12](<../../../../pages/Importando um PKCS12.md>)
     *
     */
    importPKCS12(keyName: string, certName: string, password: string, p12: Buffer, pubKey?: string, exportable?: boolean, temporary?: boolean): Promise<boolean>;
}
