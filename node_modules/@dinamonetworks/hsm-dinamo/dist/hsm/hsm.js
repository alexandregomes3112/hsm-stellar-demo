"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(require("net"));
const tls_1 = __importDefault(require("tls"));
require("crypto");
const logger_1 = __importDefault(require("../utils/logger"));
const constants = __importStar(require("./constants"));
const exceptions = __importStar(require("./exceptions"));
const utils_1 = require("../utils");
const key_1 = __importDefault(require("./modules/key"));
const blockchain_1 = __importDefault(require("./modules/blockchain"));
const cryptography_1 = __importDefault(require("./modules/cryptography"));
const user_1 = __importDefault(require("./modules/user"));
const ocra_1 = __importDefault(require("./modules/ocra"));
const management_1 = __importDefault(require("./modules/management"));
const crypto = __importStar(require("crypto"));
const validators_1 = require("./validators");
const aescmac_1 = require("../utils/aescmac");
/**
 * Client para conexão e manipulação de objetos do HSM.
 */
class HSM {
    /**
     * @internal
     * Algoritmo de hash usado para a autenticação com o HSM
     * @private
     */
    // Uncomment this line when HMAC is implemented
    // private hashMethod: typeof constants.NOTIFY_OK | typeof constants.NOTIFY_OK_RM1 | typeof constants.NOTIFY_OK_RM2;
    /**
     * @internal
     * Inicializa uma nova instância da classe HSM
     * @constructor
     */
    constructor() {
        this.connecting = false;
        this.connected = false;
        this.isTokenSession = false;
    }
    /**
     * Inicializa a conexão com o HSM
     * @param {interfaces.session.HsmOptions} options - Opções de configuração do client
     * @param tlsOptions
     * @returns {Promise<HSM>} - Instância do client com a conexão estabelecida
     * @throws {@link exceptions.HsmError} - Alguma opção de configuração não foi especificada ou está incorreta
     * @throws {@link exceptions.ConnectionError} - Não foi possível estabelecer a conexão com o HSM
     * @throws {@link exceptions.HsmError} - Erro genérico do client
     */
    static connect(options, tlsOptions) {
        const dinamoClient = new HSM();
        return dinamoClient.connect(options, tlsOptions);
    }
    static disconnect() {
        return new Promise(async (resolve) => {
            await HSM.instance.closeConnection();
            resolve(true);
        });
    }
    disconnect() {
        return new Promise(async (resolve) => {
            await this.closeConnection();
            resolve(true);
        });
    }
    /**
     * @internal
     * @param {interfaces.session.HsmOptions} options - Opções de configuração do client
     * @param {interfaces.session.TlsOptions} tlsOptions - Opções de configuração de conexão TLS
     */
    connect(options, tlsOptions) {
        // Set that the client is connecting with the HSM
        this.connecting = true;
        return new Promise(async (resolve, reject) => {
            // Set the client options
            if (options) {
                this.options = options;
            }
            if (tlsOptions) {
                this.tlsOptions = tlsOptions;
            }
            const authUsernamePassword = this.options.authUsernamePassword;
            const authToken = this.options.authToken;
            // Set that the session is token
            this.isTokenSession = !!authToken;
            try {
                // Open TCP and TLS connections with the HSM
                await this.openConnection(this._tlsOptions);
                // Choose the authentication mode
                if (authUsernamePassword) {
                    await this.openSessionWithUsernamePassword(authUsernamePassword);
                }
                else if (authToken) {
                    await this.openSessionWithToken(authToken);
                }
                else {
                    logger_1.default.info("Authentication mode not specified, see the documentation for more information");
                    logger_1.default.info("Only connection test will be performed");
                }
            }
            catch (e) {
                // Close the connection with the HSM if an error occurs
                await this.closeConnection();
                reject(e);
            }
            // Set that the client is connected with the HSM
            this.connected = true;
            this.connecting = false;
            HSM.instance = this;
            resolve(this);
        });
    }
    /**
     * Host do HSM
     * @returns {string}
     * @readonly
     * @throws {@link exceptions.HsmError} - Host não definido
     */
    get host() {
        const host = this?.options?.host ?? process.env.HSM_HOST ?? "";
        if (!host) {
            throw new exceptions.HsmOptionError("Host não definido");
        }
        return host;
    }
    /**
     * Porta do HSM
     * @returns {number}
     * @readonly
     * @throws {@link exceptions.HsmError} - Porta não definida
     */
    get port() {
        const port = this?.options?.port ?? constants.HSM_DEFAULT_PORT;
        if (!port) {
            throw new exceptions.HsmOptionError("Porta não definida");
        }
        return port;
    }
    /**
     * Habilita as mensagens do OpenSSL
     * @returns {boolean} - True se as mensagens do OpenSSL estão habilitadas
     * @readonly
     * @default false
     */
    get enableTrace() {
        return this?.options?.enableTrace ?? false;
    }
    /**
     * Configurações do client
     * @param options
     */
    set options(options) {
        this._options = options;
    }
    set tlsOptions(tlsOptions) {
        this._tlsOptions = tlsOptions;
    }
    ;
    /**
     * Configurações do client
     * @returns {interfaces.session.HsmOptions}
     */
    get options() {
        if (this._options &&
            this._options.host &&
            (this._options.authUsernamePassword ?? this._options.authToken)) {
            return this._options;
        }
        const options = this._options ?? {};
        if (!options.port) {
            options.port = this.getEnvVar("HSM_PORT", constants.HSM_DEFAULT_PORT, (value) => parseInt(value));
        }
        if (!options.host) {
            options.host = this.getEnvVar("HSM_HOST", null, (value) => value);
        }
        if (!options.enableTrace) {
            options.enableTrace = this.getEnvVar("HSM_ENABLE_TRACE", false, (value) => value === "true");
        }
        const ipFormat = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
        const dnsFormat = /^([a-zA-Z0-9]+\.)*[a-zA-Z0-9]+\.[a-zA-Z]{2,}$/;
        if (!options.host || options.host === "") {
            throw new exceptions.HsmOptionError("The host is not defined.");
        }
        if (!options.host.match(ipFormat) && !options.host.match(dnsFormat)) {
            throw new exceptions.HsmOptionError("The host is not valid.");
        }
        if (!options.authUsernamePassword && !options.authToken) {
            const username = this.getEnvVar("HSM_USERNAME", null, (value) => value);
            const password = this.getEnvVar("HSM_PASSWORD", null, (value) => value);
            if (username && password) {
                options.authUsernamePassword = {
                    username: username,
                    password: password,
                };
            }
            else {
                const authToken = this.getEnvVar("HSM_AUTH_TOKEN", null, (value) => value);
                if (authToken) {
                    options.authToken = authToken;
                }
                else {
                    throw new exceptions.HsmOptionError("Authentication mode not specified. Please, check the documentation.");
                }
            }
        }
        this._options = options;
        return options;
    }
    getEnvVar(name, defaultValue, cast) {
        const envVar = process.env[name];
        if (!cast) {
            cast = (value) => value;
        }
        if (envVar) {
            return cast(envVar);
        }
        return defaultValue ?? null;
    }
    /**
     * Abrir uma conexão com o HSM via TCP
     * @returns {void}
     */
    async openConnection(tlsOptions) {
        const mTls = (typeof tlsOptions?.cert !== "undefined" && typeof tlsOptions?.key !== "undefined");
        await this.openTCPConnection(mTls);
        await this.openTlsConnection(mTls, tlsOptions);
    }
    /**
     * @internal
     * Fechar a conexão com o HSM
     * @returns {Promise<void>}
     */
    closeConnection() {
        return new Promise((resolve) => {
            const buf = utils_1.Aap.create(constants.NOTIFY_CLOSE, 0);
            if (this.tlsSocket === undefined) {
                if (this.tcpSocket !== undefined) {
                    this.tcpSocket.destroy();
                }
                resolve();
            }
            this.tlsSocket.write(buf, () => {
                this.tcpSocket.destroy();
                this.tlsSocket.destroy();
                // Set that the client is not connected with the HSM
                this.connected = false;
                resolve();
            });
        });
    }
    /**
     * @internal
     * Abre uma sessão com o HSM usando autenticação por usuário e senha
     * @param {interfaces.session.AuthUsernamePassword} auth - Credenciais de autenticação
     * @private
     * @returns {Promise<boolean>} - True se a sessão foi aberta com sucesso
     */
    openSessionWithUsernamePassword(auth) {
        return new Promise(async (resolve, reject) => {
            const tlsSocket = this.tlsSocket;
            const buf = utils_1.Aap.create(constants.MOD_CORE_AUTHENTICATE, constants.NOTIFY_CID);
            const sent = tlsSocket.write(buf);
            if (!sent) {
                reject(new exceptions.ConnectionError("Cannot connect to the HSM"));
            }
            tlsSocket.once("error", (error) => {
                reject(new exceptions.ConnectionError(error.message));
            });
            tlsSocket.once("data", (chap) => {
                const aapHdr = utils_1.Aap.read(chap);
                if (!this.notifyOk(aapHdr.id)) {
                    reject(new exceptions.ConnectionError("Cannot connect to the HSM"));
                    return;
                }
                const resp = Buffer.alloc(constants.AAP_CHAP_RESP_LEN);
                resp.fill(auth.username, constants.AAP_CHAP_HASH_LEN, constants.AAP_CHAP_HASH_LEN + auth.username.length);
                if (auth.password.length < constants.MIN_USR_PWD_LEN ||
                    auth.password.length > constants.MAX_USR_PWD_LEN) {
                    reject(new exceptions.HsmOptionError(`Invalid password length: ${auth.password.length}. Password length must be greater than or equal to ${constants.MIN_USR_PWD_LEN} and less than or equal to ${constants.MAX_USR_PWD_LEN}. Please, check the documentation.`));
                    return;
                }
                const hash = this.aapHash(auth.password, chap.subarray(constants.AAP_HDR_LEN));
                resp.fill(hash.subarray(0, constants.AAP_CHAP_HASH_LEN), 0, constants.AAP_CHAP_HASH_LEN);
                const req = tlsSocket.write(resp);
                if (!req) {
                    reject(new exceptions.ConnectionError("Cannot connect to the HSM"));
                    return;
                }
                tlsSocket.once("data", (data) => {
                    const aapHdr = utils_1.Aap.read(data);
                    if (utils_1.Aap.hasError(aapHdr)) {
                        reject(new exceptions.HsmError("Cannot connect to the HSM", aapHdr.len));
                        return;
                    }
                    logger_1.default.info("Authentication with the HSM was successful");
                    // Create the HSM objects instances
                    this.createHsmObjectsInstances();
                    resolve(true);
                });
            });
        });
    }
    /**
     * @internal
     * Abre uma sessão com o HSM usando autenticação por token
     * @param {string} authToken - Token de autenticação
     * @private
     * @returns {Promise<boolean>} - True se a sessão foi aberta com sucesso
     * @throws {@link exceptions.HsmError} - Gerar uma exceção se ocorrer algum erro.
     */
    openSessionWithToken(authToken) {
        // TODO: Refactor this method to use the same logic of openSessionWithUsernamePassword but using the token
        return new Promise(async (resolve, reject) => {
            (0, validators_1.base64Validate)({
                data: authToken,
                message: "Authentication token is not valid",
                required: true,
                reject,
            });
            const tokenBuff = Buffer.from(authToken, "base64");
            const username = tokenBuff.subarray(0, 16).toString().replace(/\W/g, "");
            const tokenKey = tokenBuff.subarray(constants.MAX_USR_LEN);
            const tlsSocket = this.tlsSocket;
            const buf = utils_1.Aap.create(constants.MOD_CORE_AUTHENTICATE, constants.NOTIFY_CID);
            const sent = tlsSocket.write(buf);
            if (!sent) {
                reject(new exceptions.ConnectionError("Cannot connect to the HSM"));
            }
            tlsSocket.once("error", (error) => {
                reject(new exceptions.ConnectionError(error.message));
            });
            tlsSocket.once("data", (chap) => {
                const aapHdr = utils_1.Aap.read(chap);
                if (!this.notifyOk(aapHdr.id)) {
                    reject(new exceptions.ConnectionError("Cannot connect to the HSM"));
                    return;
                }
                const resp = Buffer.alloc(constants.AAP_CHAP_RESP_LEN);
                const challenge = chap.subarray(constants.AAP_HDR_LEN);
                const dataToHash = Buffer.alloc(constants.MAX_USR_LEN +
                    constants.A_TOKEN_KLEN +
                    constants.AAP_CHAP_RND_LEN);
                let offset = 0;
                dataToHash.write(username, offset);
                offset += constants.MAX_USR_LEN;
                dataToHash.fill(tokenKey, offset, offset + tokenKey.length);
                offset += constants.A_TOKEN_KLEN;
                dataToHash.fill(challenge, offset, offset + challenge.length);
                const hash = (0, aescmac_1.aesCmac)(tokenKey, dataToHash);
                resp.fill(hash, 0, constants.AAP_CHAP_HASH_LEN);
                resp.write(username, constants.AAP_CHAP_HASH_LEN);
                const req = tlsSocket.write(resp);
                if (!req) {
                    reject(new exceptions.ConnectionError("Cannot connect to the HSM"));
                    return;
                }
                tlsSocket.once("data", (data) => {
                    const aapHdr = utils_1.Aap.read(data);
                    if (utils_1.Aap.hasError(aapHdr)) {
                        reject(new exceptions.HsmError("Cannot connect to the HSM", aapHdr.len));
                        return;
                    }
                    logger_1.default.info("Authentication with the HSM was successful");
                    // Create the HSM objects instances
                    this.createHsmObjectsInstances();
                    resolve(true);
                });
            });
        });
    }
    /**
     * @internal
     * Verifica se o id retornado pelo HSM é NOTIFY_OK
     * @param {number} id - Id retornado pelo HSM
     * @returns {boolean} - True se o id é NOTIFY_OK, NOTIFY_OK_RM1 ou NOTIFY_OK_RM2
     * @private
     */
    notifyOk(id) {
        // this.hashMethod = id; // Uncomment this line when HMAC is implemented
        return [
            constants.NOTIFY_OK,
            constants.NOTIFY_OK_RM1,
            constants.NOTIFY_OK_RM2,
        ].includes(id);
    }
    createHash(data) {
        // TODO: HMAC not implemented yet
        // if ([constants.NOTIFY_OK_RM1, constants.NOTIFY_OK_RM2].includes(this.hashMethod)) {
        //     const hMacKey = constants?.HMAC_KEY;
        //     return createHmac("sha256", hMacKey).update(data).digest();
        // }
        // If is NOTIFY_OK
        return crypto.createHash("md5").update(data);
    }
    /**
     * @internal
     * Abre uma conexão TCP com o HSM
     * @returns {Promise<boolean>} - True se a conexão foi aberta com sucesso
     * @private
     */
    openTCPConnection(mTlsStatus) {
        const HOST = this.host;
        const PORT = this.port;
        // New TCP socket instance
        const tcpSocket = new net_1.default.Socket();
        // TCP options
        const tcpOptions = {
            host: HOST,
            port: PORT,
            noDelay: true,
        };
        return new Promise((resolve, reject) => {
            // Add a 'error' event handler for the client socket
            tcpSocket.once("error", (error) => {
                reject(new exceptions.ConnectionError(error.message));
            });
            // Add a 'data' event handler for the client socket to verify the handshake with the HSM
            tcpSocket.once("data", (data) => {
                if (!this.acceptedTcpHandshake(data)) {
                    throw new exceptions.ConnectionError("Não foi possível efetuar o handshake com o HSM");
                }
                this.tcpSocket = tcpSocket;
                resolve(true);
            });
            // Connect to the HSM
            tcpSocket.connect(tcpOptions, () => {
                // Create a buffer with the handshake data
                let sessionToken = 0;
                if (this.isTokenSession) {
                    sessionToken = constants.SESSION_A_TOKEN_AUTH;
                }
                const sessionAuthx509 = mTlsStatus ? constants.AAP_SESSION_X509_AUTH : 0;
                const buf = utils_1.Aap.create(constants.AAP_HND_SHAKE, (constants.AAP_v1 << 16) | sessionToken | constants.AAP_TLS | sessionAuthx509);
                // Send the handshake data to the HSM
                const sent = tcpSocket.write(buf);
                // If the handshake data was not sent, throw an error
                if (!sent) {
                    reject(new exceptions.ConnectionError("Não foi possível efetuar o handshake com o HSM"));
                }
            });
        });
    }
    /**
     * @internal
     * Abre uma conexão TLS com o HSM
     * @private
     * @returns {void}
     */
    openTlsConnection(mTlsStatus, tlsOptions) {
        const ciphers = [
            "TLS_RSA_WITH_AES_128_CBC_SHA256",
            "TLS_RSA_WITH_AES_256_CBC_SHA256",
            "TLS_RSA_WITH_AES_128_GCM_SHA256",
            "TLS_RSA_WITH_AES_256_GCM_SHA384",
            "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
            "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
            "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
            "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
            "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
            "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
            "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
            "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
            "AES128-SHA256",
            "AES256-SHA256",
            "AES128-GCM-SHA256",
            "AES256-GCM-SHA384",
            "ECDHE-ECDSA-AES128-SHA256",
            "ECDHE-ECDSA-AES256-SHA384",
            "ECDH-ECDSA-AES128-SHA256",
            "ECDH-ECDSA-AES256-SHA384",
            "ECDHE-RSA-AES128-SHA256",
            "ECDHE-RSA-AES256-SHA384",
            "ECDH-RSA-AES128-SHA256",
            "ECDH-RSA-AES256-SHA384",
            "ECDHE-ECDSA-AES128-GCM-SHA256",
            "ECDHE-ECDSA-AES256-GCM-SHA384",
            "ECDH-ECDSA-AES128-GCM-SHA256",
            "ECDH-ECDSA-AES256-GCM-SHA384",
            "ECDHE-RSA-AES128-GCM-SHA256",
            "ECDHE-RSA-AES256-GCM-SHA384",
            "ECDH-RSA-AES128-GCM-SHA256",
            "ECDH-RSA-AES256-GCM-SHA384",
            "TLS_AES_128_GCM_SHA256:",
            "TLS_AES_256_GCM_SHA384"
        ].join(":");
        const tcpSocket = this.tcpSocket;
        const tlsOptions2 = {
            socket: tcpSocket,
            rejectUnauthorized: false,
            maxVersion: "TLSv1.3",
            minVersion: "TLSv1.2",
            enableTrace: this.enableTrace,
            ciphers: ciphers,
        };
        const rejectUnauthorizedStatus = typeof tlsOptions?.ca !== "undefined";
        if (tlsOptions) {
            if (mTlsStatus)
                tlsOptions2.key = tlsOptions.key;
            if (mTlsStatus)
                tlsOptions2.cert = tlsOptions.cert;
            if (tlsOptions.ca)
                tlsOptions2.ca = tlsOptions.ca;
            tlsOptions2.rejectUnauthorized = rejectUnauthorizedStatus;
        }
        return new Promise((resolve, reject) => {
            if (!tcpSocket) {
                reject(new exceptions.ConnectionError("Cannot connect to the HSM"));
                return;
            }
            const tlsSocket = tls_1.default.connect(tlsOptions2, () => {
                this.tlsSocket = tlsSocket;
                resolve(true);
            });
            tlsSocket.setNoDelay(true);
            tlsSocket.setMaxListeners(0);
            tlsSocket.once("secureConnect", () => {
                logger_1.default.info("Connection with the HSM was established successfully");
                resolve(true);
            });
            tlsSocket.on("close", (hadError) => {
                if (hadError) {
                    logger_1.default.error("The TLS connection was closed with an error");
                }
                else {
                    logger_1.default.info("The TLS connection was closed");
                }
            });
            // Show the TLS keylog
            if (this.enableTrace) {
                tlsSocket.on("keylog", (line) => {
                    logger_1.default.info("TLS keylog: " + line.toString());
                });
            }
            tlsSocket.once("error", (error) => {
                reject(new exceptions.ConnectionError(error.message));
            });
        });
    }
    /**
     * @internal
     * Cria o hash para a autenticação com o HSM
     * @param {string} password - Senha para a autenticação com o HSM
     * @param {Buffer} rnd - Buffer com o desafio enviado pelo HSM
     * @private
     */
    aapHash(password, rnd) {
        const bSenha = Buffer.alloc(constants.AAP_CHAP_HASH_LEN);
        bSenha.fill(password, 0, password.length);
        return this.createHash(this.createHash(bSenha).digest())
            .update(rnd)
            .digest();
    }
    /**
     * @internal
     * Verifica se o handshake via TCP foi aceito pelo HSM
     * @param {Buffer} data - Dados retornados pelo HSM
     * @returns {boolean} - True se o handshake foi aceito
     * @private
     */
    acceptedTcpHandshake(data) {
        const ret = data.readUInt32LE(0);
        return [
            constants.AAP_HND_SHAKE,
            constants.AAP_HSHAKE_OK_NT,
            constants.AAP_HSHAKE_OK_AT,
        ].includes(ret);
    }
    /**
     * @internal
     * Cria as instâncias dos objetos do HSM
     * @returns {void}
     * @private
     */
    createHsmObjectsInstances() {
        this.key = new key_1.default(this.tlsSocket);
        this.blockchain = new blockchain_1.default(this.tlsSocket);
        // this.hash = new Hash(this.tlsSocket);
        this.cryptography = new cryptography_1.default(this.tlsSocket);
        this.ocra = new ocra_1.default(this.tlsSocket);
        this.management = new management_1.default(this.tlsSocket);
        this.user = new user_1.default(this.tlsSocket, this.options.authUsernamePassword?.username ?? null);
    }
}
exports.default = HSM;
