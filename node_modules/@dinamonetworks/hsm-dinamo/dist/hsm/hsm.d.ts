import "crypto";
import * as interfaces from "./interfaces";
import * as crypto from "crypto";
/**
 * Client para conexão e manipulação de objetos do HSM.
 */
export default class HSM implements interfaces.Hsm {
    connecting: boolean;
    connected: boolean;
    key: interfaces.key.Key;
    blockchain: interfaces.blockchain.Blockchain;
    cryptography: interfaces.cryptography.Cryptography;
    user: interfaces.user.User;
    ocra: interfaces.ocra.Ocra;
    management: interfaces.management.Management;
    /**
     * @internal
     * Instância do HSM Conn (Singleton)
     */
    private static instance;
    /**
     * @internal
     * Socket usado para comunicação com o HSM
     * @private
     */
    private tcpSocket;
    /**
     * @internal
     * Socket usado para comunicação com o HSM via TLS
     * @private
     */
    private tlsSocket;
    /**
     * @internal
     * Opções para a conexão com o HSM
     */
    private _options;
    /**
     * @internal
     * Opções para configuração da conexão TLS
     */
    private _tlsOptions;
    private isTokenSession;
    /**
     * @internal
     * Algoritmo de hash usado para a autenticação com o HSM
     * @private
     */
    /**
     * @internal
     * Inicializa uma nova instância da classe HSM
     * @constructor
     */
    constructor();
    /**
     * Inicializa a conexão com o HSM
     * @param {interfaces.session.HsmOptions} options - Opções de configuração do client
     * @param tlsOptions
     * @returns {Promise<HSM>} - Instância do client com a conexão estabelecida
     * @throws {@link exceptions.HsmError} - Alguma opção de configuração não foi especificada ou está incorreta
     * @throws {@link exceptions.ConnectionError} - Não foi possível estabelecer a conexão com o HSM
     * @throws {@link exceptions.HsmError} - Erro genérico do client
     */
    static connect(options?: interfaces.session.HsmOptions, tlsOptions?: interfaces.session.TlsOptions): Promise<HSM>;
    static disconnect(): Promise<boolean>;
    disconnect(): Promise<boolean>;
    /**
     * @internal
     * @param {interfaces.session.HsmOptions} options - Opções de configuração do client
     * @param {interfaces.session.TlsOptions} tlsOptions - Opções de configuração de conexão TLS
     */
    connect(options?: interfaces.session.HsmOptions, tlsOptions?: interfaces.session.TlsOptions): Promise<HSM>;
    /**
     * Host do HSM
     * @returns {string}
     * @readonly
     * @throws {@link exceptions.HsmError} - Host não definido
     */
    get host(): string;
    /**
     * Porta do HSM
     * @returns {number}
     * @readonly
     * @throws {@link exceptions.HsmError} - Porta não definida
     */
    get port(): number;
    /**
     * Habilita as mensagens do OpenSSL
     * @returns {boolean} - True se as mensagens do OpenSSL estão habilitadas
     * @readonly
     * @default false
     */
    get enableTrace(): boolean;
    /**
     * Configurações do client
     * @param options
     */
    set options(options: interfaces.session.HsmOptions);
    set tlsOptions(tlsOptions: interfaces.session.TlsOptions);
    /**
     * Configurações do client
     * @returns {interfaces.session.HsmOptions}
     */
    get options(): interfaces.session.HsmOptions;
    private getEnvVar;
    /**
     * Abrir uma conexão com o HSM via TCP
     * @returns {void}
     */
    openConnection(tlsOptions?: interfaces.session.TlsOptions): Promise<void>;
    /**
     * @internal
     * Fechar a conexão com o HSM
     * @returns {Promise<void>}
     */
    closeConnection(): Promise<void>;
    /**
     * @internal
     * Abre uma sessão com o HSM usando autenticação por usuário e senha
     * @param {interfaces.session.AuthUsernamePassword} auth - Credenciais de autenticação
     * @private
     * @returns {Promise<boolean>} - True se a sessão foi aberta com sucesso
     */
    private openSessionWithUsernamePassword;
    /**
     * @internal
     * Abre uma sessão com o HSM usando autenticação por token
     * @param {string} authToken - Token de autenticação
     * @private
     * @returns {Promise<boolean>} - True se a sessão foi aberta com sucesso
     * @throws {@link exceptions.HsmError} - Gerar uma exceção se ocorrer algum erro.
     */
    private openSessionWithToken;
    /**
     * @internal
     * Verifica se o id retornado pelo HSM é NOTIFY_OK
     * @param {number} id - Id retornado pelo HSM
     * @returns {boolean} - True se o id é NOTIFY_OK, NOTIFY_OK_RM1 ou NOTIFY_OK_RM2
     * @private
     */
    notifyOk(id: number): boolean;
    createHash(data: crypto.BinaryLike): crypto.Hash;
    /**
     * @internal
     * Abre uma conexão TCP com o HSM
     * @returns {Promise<boolean>} - True se a conexão foi aberta com sucesso
     * @private
     */
    private openTCPConnection;
    /**
     * @internal
     * Abre uma conexão TLS com o HSM
     * @private
     * @returns {void}
     */
    private openTlsConnection;
    /**
     * @internal
     * Cria o hash para a autenticação com o HSM
     * @param {string} password - Senha para a autenticação com o HSM
     * @param {Buffer} rnd - Buffer com o desafio enviado pelo HSM
     * @private
     */
    private aapHash;
    /**
     * @internal
     * Verifica se o handshake via TCP foi aceito pelo HSM
     * @param {Buffer} data - Dados retornados pelo HSM
     * @returns {boolean} - True se o handshake foi aceito
     * @private
     */
    private acceptedTcpHandshake;
    /**
     * @internal
     * Cria as instâncias dos objetos do HSM
     * @returns {void}
     * @private
     */
    private createHsmObjectsInstances;
}
