"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const constants = __importStar(require("../constants"));
const exceptions = __importStar(require("../exceptions"));
const hsm_base_module_1 = __importDefault(require("./hsm_base_module"));
const utils_1 = require("../../utils");
const enums = __importStar(require("../enums"));
const validators = __importStar(require("../validators"));
const crypto_1 = __importDefault(require("crypto"));
class Cryptography extends hsm_base_module_1.default {
    constructor(conn) {
        super(conn);
    }
    mOfnSplit(m, n, secret) {
        return new Promise((resolve, reject) => {
            if (m > n) {
                reject(new exceptions.HsmError("M must be less than or equal to N"));
                return;
            }
            if (secret && secret.length !== constants.M_OF_N_SECRET_LEN) {
                reject(new exceptions.HsmError(`Secret must be ${constants.M_OF_N_SECRET_LEN} characters`));
                return;
            }
            const secretLen = constants.M_OF_N_SECRET_LEN;
            const payloadLen = constants.SIZE_OF_UINT_8 * 2 + secretLen;
            const mOfnBuf = utils_1.Aap.create(constants.MOD_CORE_M_OF_N_SPLIT, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            if (secret) {
                mOfnBuf.write(secret, offset, secretLen);
            }
            offset += secretLen;
            mOfnBuf.writeUInt8(m, offset); // M
            offset += constants.SIZE_OF_UINT_8;
            mOfnBuf.writeUInt8(n, offset); // N
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on divide secret", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("M of N split success");
                const payload = data.subarray(constants.AAP_HDR_LEN);
                resolve(this.bufToMOfNSplit(payload, n, reject));
            });
            this.conn.once("error", (err) => {
                reject(err);
                return;
            });
            this.conn.write(mOfnBuf);
        });
    }
    mOfNRecover(parts) {
        return new Promise((resolve, reject) => {
            const payloadLen = parts.length * constants.MC_M_OF_N_S_PARTLEN;
            const mOfnBuf = utils_1.Aap.create(constants.MOD_CORE_M_OF_N_RECOVER, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            for (const part of parts) {
                mOfnBuf.fill(part, offset, offset + part.length);
                offset += part.length;
            }
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on recover secret", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("M of N recover success");
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(err);
                return;
            });
            this.conn.write(mOfnBuf);
        });
    }
    rsaSign(keyName, hashAlgorithm, hash, pad) {
        return new Promise((resolve, reject) => {
            validators.maxLengthValidate({
                data: hash,
                max: constants.MAX_HASH_LEN,
                attribute: "hash",
                reject,
            });
            validators.keyNameValidator(keyName, reject);
            validators.enumValidate(pad, enums.PAD_TYPE, "Invalid pad type", reject);
            validators.enumValidate(hashAlgorithm, enums.HASH_ALGORITHMS, "Invalid hash algorithm", reject);
            const payloadLen = constants.MAX_OBJ_FQN_LEN +
                constants.SIZE_OF_UINT_8 * 2 +
                constants.MAX_HASH_LEN;
            const signBuf = utils_1.Aap.create(constants.MOD_CORE_RSA_SIGN, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            signBuf.write(keyName, offset);
            offset += constants.MAX_OBJ_FQN_LEN;
            signBuf.writeUInt8(pad, offset);
            offset += constants.SIZE_OF_UINT_8;
            signBuf.writeUInt8(hashAlgorithm, offset);
            offset += constants.SIZE_OF_UINT_8;
            signBuf.fill(hash, offset, offset + hash.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on sign hash", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Sign success");
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(err);
                return;
            });
            this.conn.write(signBuf);
        });
    }
    rsaVerify(keyName, hashAlgorithm, pad, hash, signature) {
        return new Promise((resolve, reject) => {
            validators.maxLengthValidate({
                data: hash,
                max: constants.MAX_HASH_LEN,
                attribute: "hash",
                reject,
            });
            validators.maxLengthValidate({
                data: signature,
                max: constants.MAX_RSA_MOD_LEN,
                attribute: "signature",
                reject,
            });
            validators.keyNameValidator(keyName, reject);
            validators.enumValidate(pad, enums.PAD_TYPE, "Invalid pad type", reject);
            validators.enumValidate(hashAlgorithm, enums.HASH_ALGORITHMS, "Invalid hash algorithm", reject);
            const payloadLen = constants.MAX_OBJ_FQN_LEN +
                constants.SIZE_OF_UINT_8 * 2 +
                constants.MAX_HASH_LEN +
                signature.length;
            const verifyBuf = utils_1.Aap.create(constants.MOD_CORE_RSA_VERIFY, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            verifyBuf.write(keyName, offset);
            offset += constants.MAX_OBJ_FQN_LEN;
            verifyBuf.writeUInt8(pad, offset);
            offset += constants.SIZE_OF_UINT_8;
            verifyBuf.writeUInt8(hashAlgorithm, offset);
            offset += constants.SIZE_OF_UINT_8;
            verifyBuf.fill(hash, offset, offset + hash.length);
            offset += constants.MAX_HASH_LEN;
            verifyBuf.fill(signature, offset, offset + signature.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    if (this.isInvalidSignature(aapHdr)) {
                        utils_1.Logger.info("RSA verify successfull");
                        resolve(false);
                        return;
                    }
                    reject(new exceptions.HsmError("Error on verify RSA signatue", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("RSA verify successfull");
                resolve(true);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
                return;
            });
            this.conn.write(verifyBuf);
        });
    }
    eccSign(keyName, hashAlgorithm, hash) {
        return new Promise((resolve, reject) => {
            validators.maxLengthValidate({
                data: hash,
                max: constants.MAX_HASH_LEN,
                attribute: "hash",
                reject,
            });
            validators.keyNameValidator(keyName, reject);
            const payloadLen = constants.MAX_OBJ_FQN_LEN + constants.SIZE_OF_UINT_8 + hash.length;
            const signBuf = utils_1.Aap.create(constants.MOD_CORE_ECC_SIGN, payloadLen | constants.MC_SO_FLAG_FQN, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            signBuf.write(keyName, offset);
            offset += constants.MAX_OBJ_FQN_LEN;
            signBuf.writeUInt8(hashAlgorithm, offset);
            offset += constants.SIZE_OF_UINT_8;
            signBuf.fill(hash, offset, offset + hash.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on sign hash", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Sign success");
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(err);
                return;
            });
            this.conn.write(signBuf);
        });
    }
    eccVerify(keyName, hashAlgorithm, hash, signature) {
        return new Promise((resolve, reject) => {
            validators.maxLengthValidate({
                data: hash,
                max: constants.MAX_HASH_LEN,
                attribute: "hash",
                reject,
            });
            validators.maxLengthValidate({
                data: signature,
                max: constants.MAX_ECC_SIGN_DER,
                attribute: "signature",
                reject,
            });
            validators.keyNameValidator(keyName, reject);
            validators.enumValidate(hashAlgorithm, enums.HASH_ALGORITHMS, "Invalid hash algorithm", reject);
            const payloadLen = constants.MAX_OBJ_FQN_LEN +
                constants.SIZE_OF_UINT_8 * 2 +
                constants.MAX_HASH_LEN +
                signature.length;
            const verifyBuf = utils_1.Aap.create(constants.MOD_CORE_ECC_VERIFY2, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            verifyBuf.write(keyName, offset);
            offset += constants.MAX_OBJ_FQN_LEN;
            // Increment for the padding position
            offset += constants.SIZE_OF_UINT_8;
            verifyBuf.writeUInt8(hashAlgorithm, offset);
            offset += constants.SIZE_OF_UINT_8;
            verifyBuf.fill(hash, offset, offset + hash.length);
            offset += constants.MAX_HASH_LEN;
            verifyBuf.fill(signature, offset, offset + signature.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    if (this.isInvalidSignature(aapHdr)) {
                        utils_1.Logger.info("ECC verify successfull");
                        resolve(false);
                        return;
                    }
                    reject(new exceptions.HsmError("Error on verify ECC signatue", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("ECC verify successfull");
                resolve(true);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
                return;
            });
            this.conn.write(verifyBuf);
        });
    }
    eddsaSign(keyName, hash) {
        return new Promise((resolve, reject) => {
            validators.maxLengthValidate({
                data: hash,
                max: constants.MAX_EdDSA_DATA_LEN,
                attribute: "hash",
                reject,
            });
            validators.keyNameValidator(keyName, reject);
            const payloadLen = constants.MAX_OBJ_FQN_LEN + constants.SIZE_OF_UINT_8 + hash.length;
            const signBuf = utils_1.Aap.create(constants.MOD_CORE_EdDSA_SIGN, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            signBuf.write(keyName, offset);
            offset += constants.MAX_OBJ_FQN_LEN;
            signBuf.writeUInt8(constants.PURE_EdDSA_MODE, offset);
            offset += constants.SIZE_OF_UINT_8;
            signBuf.fill(hash, offset, offset + hash.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on sign hash", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Sign success");
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(err);
                return;
            });
            this.conn.write(signBuf);
        });
    }
    eddsaVerify(keyName, hash, signature) {
        return new Promise((resolve, reject) => {
            validators.maxLengthValidate({
                data: hash,
                max: constants.MAX_EdDSA_DATA_LEN,
                attribute: "hash",
                reject,
            });
            validators.maxLengthValidate({
                data: signature,
                max: constants.MAX_EdDSA_SIG_LEN,
                attribute: "signature",
                reject,
            });
            validators.keyNameValidator(keyName, reject);
            const payloadLen = constants.MAX_OBJ_FQN_LEN +
                constants.SIZE_OF_UINT_8 +
                constants.MAX_EdDSA_SIG_LEN +
                hash.length;
            const verifyBuf = utils_1.Aap.create(constants.MOD_CORE_EdDSA_VERIFY, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            verifyBuf.write(keyName, offset);
            offset += constants.MAX_OBJ_FQN_LEN;
            verifyBuf.writeUInt8(constants.PURE_EdDSA_MODE, offset);
            offset += constants.SIZE_OF_UINT_8;
            verifyBuf.fill(signature, offset, offset + signature.length);
            offset += constants.MAX_EdDSA_SIG_LEN;
            verifyBuf.fill(hash, offset, offset + hash.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    if (this.isInvalidSignature(aapHdr)) {
                        utils_1.Logger.info("EdDSA verify successfull");
                        resolve(false);
                        return;
                    }
                    reject(new exceptions.HsmError("Error on verify EdDSA signatue", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("EdDSA verify successfull");
                resolve(true);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
                return;
            });
            this.conn.write(verifyBuf);
        });
    }
    decodeOaepPadding(ciphertext, hash) {
        const hashLength = hash === "SHA1" ? 20 : 32;
        const ciphertextLength = ciphertext.length;
        const paddingLength = hashLength + 1;
        if (ciphertextLength <= paddingLength) {
            throw new Error("Message too short to contain OAEP padding");
        }
        const maskedSeed = ciphertext.subarray(1, hashLength + 1);
        const maskedDB = ciphertext.subarray(hashLength + 1);
        const seedMask = this.mgf1(maskedDB, hashLength, hash);
        const seed = Buffer.from(maskedSeed.map((byte, index) => byte ^ seedMask[index]));
        const dbMask = this.mgf1(seed, ciphertextLength - hashLength - 1, hash);
        const db = Buffer.from(maskedDB.map((byte, index) => byte ^ dbMask[index]));
        const count = db.filter((item) => item === 0).length;
        return db.subarray(count + 1);
    }
    mgf1(seed, length, hash) {
        let t = Buffer.alloc(0);
        const hLen = hash === "SHA1" ? 20 : 32;
        const count = Math.ceil(length / hLen);
        for (let i = 0; i < count; i++) {
            const c = Buffer.alloc(4);
            c.writeUInt32BE(i, 0);
            const digest = crypto_1.default
                .createHash(hash)
                .update(Buffer.concat([seed, c]))
                .digest();
            t = Buffer.concat([t, digest]);
        }
        return t.subarray(0, length);
    }
    removePKCS1Padding(buffer) {
        let paddingIndex = 0;
        for (let i = 2; i < buffer.length; i++) {
            if (buffer[i] === 0x00) {
                paddingIndex = i;
                break;
            }
        }
        return buffer.subarray(paddingIndex + 1);
    }
    dataUnenvelop(keyName, data, paddingOption) {
        return new Promise((resolve, reject) => {
            validators.keyNameValidator(keyName, reject);
            const BLOCK_SIZE = data.length;
            const payloadLen = constants.MAX_OBJ_FQN_LEN + BLOCK_SIZE;
            const encBuf = utils_1.Aap.create(constants.MOD_CORE_ASYM_ENC, payloadLen | constants.MC_AE_FLAG_FQN, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            encBuf.write(keyName, offset);
            offset += constants.MAX_OBJ_FQN_LEN;
            encBuf.fill(data, offset, offset + data.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error when unenveloping data", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Data unenveloped successfully");
                switch (paddingOption) {
                    case enums.ENC_DEC_PADDING.PKCS1:
                        {
                            const decoded = this.removePKCS1Padding(data.subarray(constants.AAP_HDR_LEN));
                            resolve(decoded);
                        }
                        break;
                    case enums.ENC_DEC_PADDING.OAEP_SHA1:
                        {
                            const decoded = this.decodeOaepPadding(data.subarray(constants.AAP_HDR_LEN), "SHA1");
                            resolve(decoded);
                        }
                        break;
                    case enums.ENC_DEC_PADDING.OAEP_SHA256:
                        {
                            const decoded = this.decodeOaepPadding(data.subarray(constants.AAP_HDR_LEN), "SHA256");
                            resolve(decoded);
                        }
                        break;
                }
            });
            this.conn.once("error", (err) => {
                reject(err);
                return;
            });
            this.conn.write(encBuf);
        });
    }
    encodePKCS1Padding(buffer) {
        const paddingBuffer = Buffer.alloc(2);
        paddingBuffer[0] = 0x00;
        paddingBuffer[1] = 0x02;
        const randomNonZeroBuffer = Buffer.alloc(buffer.length - 3);
        for (let i = 0; i < randomNonZeroBuffer.length; i++) {
            const randomByte = Math.floor(Math.random() * 254) + 1;
            randomNonZeroBuffer[i] = randomByte;
        }
        const zeroBuffer = Buffer.alloc(1);
        zeroBuffer[0] = 0x00;
        return Buffer.concat([
            paddingBuffer,
            randomNonZeroBuffer,
            zeroBuffer,
            buffer,
        ]);
    }
    encodeOaepPadding(message, keyLength, hash) {
        const hashLength = hash === "SHA1" ? 20 : 32;
        const k = keyLength;
        const lHash = crypto_1.default.createHash(hash).update(Buffer.alloc(0)).digest();
        const PS = Buffer.alloc(k - message.length - 2 * hashLength - 2, 0);
        const DB = Buffer.concat([lHash, PS, Buffer.from([0x01]), message]);
        const seed = crypto_1.default.randomBytes(hashLength);
        const dbMask = this.mgf1(seed, k - hashLength - 1, hash);
        const maskedDB = Buffer.from(DB.map((byte, index) => byte ^ dbMask[index]));
        const seedMask = this.mgf1(maskedDB, hashLength, hash);
        const maskedSeed = Buffer.from(seed.map((byte, index) => byte ^ seedMask[index]));
        return Buffer.concat([Buffer.from([0x00]), maskedSeed, maskedDB]);
    }
    dataEnvelop(pubKey, keyLength, data, paddingOption) {
        return new Promise((resolve, reject) => {
            let block;
            switch (paddingOption) {
                case enums.ENC_DEC_PADDING.PKCS1:
                    block = this.encodePKCS1Padding(data);
                    break;
                case enums.ENC_DEC_PADDING.OAEP_SHA1:
                    block = this.encodeOaepPadding(data, keyLength, "SHA1");
                    break;
                case enums.ENC_DEC_PADDING.OAEP_SHA256:
                    block = this.encodeOaepPadding(data, keyLength, "SHA256");
                    break;
            }
            const BLOCK_LEN = keyLength;
            const PUBKEY_LEN = pubKey.length;
            const payloadLen = constants.SIZE_OF_UINT_16 +
                BLOCK_LEN +
                constants.SIZE_OF_UINT_16 +
                pubKey.length;
            const buf = utils_1.Aap.create(constants.MOD_CORE_ASYM_DEC, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.writeUint16LE(BLOCK_LEN, offset);
            offset += constants.SIZE_OF_UINT_16;
            buf.fill(block, offset, offset + block.length);
            offset += BLOCK_LEN;
            buf.writeUInt16LE(PUBKEY_LEN, offset);
            offset += constants.SIZE_OF_UINT_16;
            buf.fill(pubKey, offset, offset + PUBKEY_LEN);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error when enveloping data", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Data enveloped successfully");
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(err);
                return;
            });
            this.conn.write(buf);
        });
    }
    genRand(len) {
        return new Promise((resolve, reject) => {
            try {
                if (len < 0 || len > 4294967295) {
                    return reject(new exceptions.InvalidParameterError(`Invalid value for genRand method. The value must be between 0 and 4294967295.`));
                }
                len = Math.min(len, 2048);
                const genRandBuf = utils_1.Aap.create(constants.MOD_CORE_GEN_RAND, len, constants.AAP_HDR_LEN + len);
                const offset = constants.AAP_HDR_LEN;
                genRandBuf.writeUInt32LE(len, offset);
                this.conn.once("data", (data) => {
                    const aapHdr = utils_1.Aap.read(data);
                    if (utils_1.Aap.hasError(aapHdr)) {
                        return reject(new exceptions.HsmError("Error on generate random strings", aapHdr.len));
                    }
                    utils_1.Logger.info("Random strings generated successfully");
                    const randomData = data.slice(constants.AAP_HDR_LEN);
                    resolve(randomData);
                });
                this.conn.once("error", (err) => {
                    reject(new Error(err.message));
                });
                this.conn.write(genRandBuf);
            }
            catch (error) {
                reject(error);
            }
        });
    }
    bufToMOfNSplit(buf, n, reject) {
        let offset = 0;
        const secret = buf.subarray(offset, constants.M_OF_N_SECRET_LEN); // K
        offset += constants.M_OF_N_SECRET_LEN;
        const entropy = buf.subarray(offset, offset + constants.MC_M_OF_N_ES_LEN); // E
        offset += constants.MC_M_OF_N_ES_LEN;
        const partsBuf = buf.subarray(offset); // S
        const parts = [];
        let partsOffset = 0;
        const M_OF_N_S_LEN = constants.M_OF_N_SECRET_LEN + 3;
        while (partsOffset < partsBuf.length) {
            const part = partsBuf.subarray(partsOffset, partsOffset + M_OF_N_S_LEN);
            parts.push(part);
            partsOffset += M_OF_N_S_LEN;
        }
        if (parts.length < 2 || parts.length > n) {
            reject(new exceptions.HsmError("Invalid parts"));
        }
        return {
            secret,
            entropy,
            parts,
        };
    }
    isInvalidSignature(aapHdr) {
        return ((aapHdr.len & constants.ERR_INCREMENT) === constants.ERR_INVALID_SIGNATURE);
    }
}
exports.default = Cryptography;
