"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const enums = __importStar(require("../enums"));
const hsm_base_module_1 = __importDefault(require("./hsm_base_module"));
const constants = __importStar(require("../constants"));
const exceptions = __importStar(require("../exceptions"));
const utils_1 = require("../../utils");
const validators = __importStar(require("../validators"));
class Blockchain extends hsm_base_module_1.default {
    constructor(conn) {
        super(conn);
        this._scalars = [];
    }
    create(name, type, exportable, temporary, version, seed, passphrase) {
        return new Promise((resolve, reject) => {
            const payloadLen = constants.SIZE_OF_UINT_8 + constants.SIZE_OF_UINT_32 + constants.AAP_MAX_OBJ_ID + constants.MBLKC_CPK_MAX_DATA;
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_CREATE_PK, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.writeUint8(type, offset);
            offset += constants.SIZE_OF_UINT_8;
            let attributes = constants.BCHAIN_KEY;
            if (exportable) {
                attributes |= constants.EXPORTABLE_KEY;
            }
            if (temporary) {
                attributes |= constants.TEMPORARY_KEY;
            }
            buf.writeUInt32LE(attributes, offset);
            offset += constants.SIZE_OF_UINT_32;
            buf.fill(name, offset, offset + name.length);
            const xprvNotSeedKeys = [enums.BLOCKCHAIN_KEYS.BIP32_XPRV, enums.BLOCKCHAIN_KEYS.BIP32_ED25519_XPRV];
            if (xprvNotSeedKeys.includes(type)) {
                offset += constants.AAP_MAX_OBJ_ID;
                if (version) {
                    buf.writeUint8(version, offset);
                }
            }
            if (type === enums.BLOCKCHAIN_KEYS.BIP32_SEED_XPRV) {
                offset += constants.AAP_MAX_OBJ_ID;
                buf.writeUInt8(0, offset);
                offset += constants.SIZE_OF_UINT_8;
                if (seed) {
                    buf.writeUInt8(seed.length, offset);
                }
                offset += constants.SIZE_OF_UINT_8;
                buf.writeUInt8(0, offset);
                offset += constants.SIZE_OF_UINT_8;
                if (version) {
                    buf.writeUint8(version, offset);
                }
                offset += constants.SIZE_OF_UINT_8;
                if (seed) {
                    buf.fill(seed, offset, offset + seed.length);
                }
                // TODO trocar para constate
                offset += constants.MAX_SEED_LEN;
                const pad = (seed?.length || 0) + constants.SIZE_OF_UINT_8 + (seed?.length || 0);
                buf.writeUInt32LE(constants.MBLKC_CPK_MAX_DATA - pad, offset);
            }
            if (type === enums.BLOCKCHAIN_KEYS.BIP39_SEED_XPRV) {
                offset += constants.AAP_MAX_OBJ_ID;
                buf.writeUInt8(0, offset);
                offset += constants.SIZE_OF_UINT_8;
                if (seed) {
                    buf.writeUInt8(seed.length, offset);
                }
                offset += constants.SIZE_OF_UINT_8;
                buf.writeUInt8(0, offset);
                offset += constants.SIZE_OF_UINT_8;
                if (version) {
                    buf.writeUint8(version, offset);
                }
                offset += constants.SIZE_OF_UINT_8;
                if (passphrase) {
                    buf.writeUInt8(passphrase.length, offset);
                }
                offset += constants.SIZE_OF_UINT_8;
                if (seed) {
                    buf.write(seed, offset);
                }
                offset += constants.MAX_SEED_LEN;
                if (passphrase) {
                    buf.write(passphrase, offset);
                }
                offset += constants.MAX_PASSPHRASE_LEN;
                const pad = (constants.SIZE_OF_UINT_8 * 5) + (seed?.length || 0) + (passphrase?.length || 0);
                buf.writeUInt32LE(constants.MBLKC_CPK_MAX_DATA - pad, offset);
            }
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on create Extended Private Key (XPrv)", aapHdr.len));
                    return;
                }
                utils_1.Logger.info(`Key ${name} created successfully`);
                resolve(true);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    delete(name) {
        return new Promise((resolve, reject) => {
            validators.keyNameValidator(name, reject);
            this.deleteObject(name).then(resolve).catch(reject);
        });
    }
    block(name) {
        return new Promise((resolve, reject) => {
            validators.keyNameValidator(name, reject);
            this.blockUnblockObject(name, constants.MSBO_OP_BLOCK).then(resolve).catch(reject);
        });
    }
    unblock(name) {
        return new Promise((resolve, reject) => {
            validators.keyNameValidator(name, reject);
            this.blockUnblockObject(name, constants.MSBO_OP_UNBLOCK).then(resolve).catch(reject);
        });
    }
    getPubKey(type, privKeyName) {
        return new Promise((resolve, reject) => {
            const playloadLen = constants.SIZE_OF_UINT_8 + constants.MAX_OBJ_FQN_LEN;
            const pubKeyBuf = utils_1.Aap.create(constants.MOD_BCHAIN_GET_PBK, playloadLen, constants.AAP_HDR_LEN + playloadLen);
            let offset = constants.AAP_HDR_LEN;
            pubKeyBuf.writeUInt8(type, offset);
            offset += constants.SIZE_OF_UINT_8;
            pubKeyBuf.write(privKeyName, offset);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on get public key", aapHdr.len));
                    return;
                }
                utils_1.Logger.info(`Public key ${privKeyName} retrieved successfully`);
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(pubKeyBuf);
        });
    }
    createBip32ChildKeyDerivation(version, index, exportable, temporary, parentKeyName, childKeyName) {
        return new Promise((resolve, reject) => {
            const payloadLen = constants.SIZE_OF_UINT_8 + constants.SIZE_OF_UINT_32 + constants.SIZE_OF_UINT_32 + constants.AAP_MAX_OBJ_ID + constants.AAP_MAX_OBJ_ID;
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_BIP32_XPRV_CKD, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.fill(version, offset, offset + constants.SIZE_OF_UINT_8);
            offset += constants.SIZE_OF_UINT_8;
            buf.writeUInt32LE(index, offset);
            offset += constants.SIZE_OF_UINT_32;
            let attributes = constants.BCHAIN_KEY;
            if (exportable) {
                attributes |= constants.EXPORTABLE_KEY;
            }
            if (temporary) {
                attributes |= constants.TEMPORARY_KEY;
            }
            buf.writeUInt32LE(attributes, offset);
            offset += constants.SIZE_OF_UINT_32;
            buf.fill(parentKeyName, offset, offset + parentKeyName.length);
            offset += constants.AAP_MAX_OBJ_ID;
            buf.fill(childKeyName, offset, offset + childKeyName.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error in child key derivation", aapHdr.len));
                    return;
                }
                utils_1.Logger.info(`Successfully derived key ${childKeyName}`);
                const keyInfo = this.bufToBlockchainKeyInfo(data.subarray(constants.AAP_HDR_LEN));
                resolve(keyInfo);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    hashData(hashMode, data) {
        return new Promise((resolve, reject) => {
            if (data.length > constants.MBLKC_MAX_HDATA_LEN) {
                reject(new exceptions.HsmError(`Data length must be less o equal to ${constants.MBLKC_MAX_HDATA_LEN}`));
                return;
            }
            const payloadLen = constants.SIZE_OF_UINT_8 + data.length;
            const hashDataBuf = utils_1.Aap.create(constants.MOD_BCHAIN_HASH, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            hashDataBuf.writeUInt8(hashMode, offset);
            offset += constants.SIZE_OF_UINT_8;
            hashDataBuf.fill(data, offset, offset + data.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on hash data", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Data hashed successfully");
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(hashDataBuf);
        });
    }
    edDsaSign(type, privKeyName, data) {
        return new Promise((resolve, reject) => {
            validators.keyNameValidator(privKeyName, reject);
            validators.maxLengthValidate({
                max: constants.MBLKC_EdDSA_MAX_DL,
                data,
                attribute: 'data',
                required: true,
                reject
            });
            const payloadLen = constants.SIZE_OF_UINT_8 + constants.MBLKC_EdDSA_MAX_CSTRL + constants.MAX_OBJ_FQN_LEN + data.length;
            const edDsaBuf = utils_1.Aap.create(constants.MOD_BCHAIN_EdDSA_SIGN, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            edDsaBuf.writeUInt8(type, offset);
            offset += constants.SIZE_OF_UINT_8;
            // Reserved for context string (RFC-8032)
            offset += constants.MBLKC_EdDSA_MAX_CSTRL;
            edDsaBuf.write(privKeyName, offset);
            offset += constants.MAX_OBJ_FQN_LEN;
            edDsaBuf.fill(data, offset, offset + data.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on sign data", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Data signed successfully");
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(edDsaBuf);
        });
    }
    edDsaVerify(type, pubKeyType, pubKey, signature, data) {
        return new Promise((resolve, reject) => {
            if (data.length > constants.MBLKC_EdDSA_MAX_DL) {
                reject(new exceptions.HsmError(`Data length must be less o equal to ${constants.MBLKC_EdDSA_MAX_DL}`));
                return;
            }
            if (pubKey.length > constants.MBLKC_MAX_PBK_LEN) {
                reject(new exceptions.HsmError(`Public key length must be less o equal to ${constants.MBLKC_MAX_PBK_LEN}`));
                return;
            }
            if (signature.length > constants.MBLKC_MAX_SIG_LEN) {
                reject(new exceptions.HsmError(`Signature length must be less o equal to ${constants.MBLKC_MAX_SIG_LEN}`));
                return;
            }
            const payloadLen = (constants.SIZE_OF_UINT_8 * 2) + constants.MBLKC_EdDSA_MAX_CSTRL + constants.MBLKC_MAX_PBK_LEN + constants.MBLKC_MAX_SIG_LEN + data.length;
            const verifyBuf = utils_1.Aap.create(constants.MOD_BCHAIN_EdDSA_VERIFY, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            verifyBuf.writeUInt8(type, offset);
            offset += constants.SIZE_OF_UINT_8;
            // Reserved for context string (RFC-8032)
            offset += constants.MBLKC_EdDSA_MAX_CSTRL;
            verifyBuf.writeUInt8(pubKeyType, offset);
            offset += constants.SIZE_OF_UINT_8;
            verifyBuf.fill(pubKey, offset, offset + pubKey.length);
            offset += constants.MBLKC_MAX_PBK_LEN;
            verifyBuf.fill(signature, offset, offset + signature.length);
            offset += constants.MBLKC_MAX_SIG_LEN;
            verifyBuf.fill(data, offset, offset + data.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    if (this.isInvalidSignature(aapHdr)) {
                        resolve(false);
                        return;
                    }
                    reject(new exceptions.HsmError("Error on verify data", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Data verified successfully");
                resolve(true);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(verifyBuf);
        });
    }
    getAddress(type, version, hrp, pk) {
        return new Promise((resolve, reject) => {
            const MBLKC_MAX_HRP = constants.MBLKC_MAX_HRP + 1;
            const payloadLen = (constants.SIZE_OF_UINT_8 * 2) + MBLKC_MAX_HRP + constants.MAX_OBJ_FQN_LEN;
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_GET_ADDR, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.writeUInt8(type, offset);
            offset += constants.SIZE_OF_UINT_8;
            buf.writeUInt8(version, offset);
            offset += constants.SIZE_OF_UINT_8;
            buf.write(hrp, offset);
            offset += MBLKC_MAX_HRP;
            buf.write(pk, offset);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on get key address", aapHdr.len));
                    return;
                }
                utils_1.Logger.info(`Get address ${pk} successfully`);
                const address = data.subarray(constants.AAP_HDR_LEN);
                resolve(address);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    sign(type, hashMode, hash, pk) {
        return new Promise((resolve, reject) => {
            if (hash.length === 0) {
                reject(new exceptions.HsmError("Hash cannot empty"));
            }
            const payloadLen = constants.SIZE_OF_UINT_8 + constants.SIZE_OF_UINT_8 + constants.MAX_HASH_LEN + constants.AAP_MAX_OBJ_ID;
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_SIGN, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.writeUint8(type, offset);
            offset += constants.SIZE_OF_UINT_8;
            buf.writeUint8(hashMode, offset);
            offset += constants.SIZE_OF_UINT_8;
            buf.fill(hash, offset, offset + hash.length);
            offset += constants.MAX_HASH_LEN;
            buf.write(pk, offset);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on sign hash", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Hash signed successfully");
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    getKeyInfo(name) {
        return new Promise((resolve, reject) => {
            const payloadLen = constants.AAP_MAX_OBJ_ID;
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_KINFO, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            const offset = constants.AAP_HDR_LEN;
            buf.write(name, offset);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error retrieving BIP 32 key information", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Bip 32 key information successfully recovered.");
                const keyInfo = this.bufToBlockchainKeyInfo(data.subarray(constants.AAP_HDR_LEN));
                resolve(keyInfo);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    import(format, exportable, temporary, name, data) {
        return new Promise((resolve, reject) => {
            const dataEncoding = ((0, utils_1.isHex)(data) && format !== enums.IMPORT_EXPORT_FORMAT.HEX) ? "hex" : undefined;
            const dataBuff = Buffer.from(data, dataEncoding);
            const payloadLen = constants.SIZE_OF_UINT_8 + constants.SIZE_OF_UINT_32 + constants.MAX_OBJ_FQN_LEN + dataBuff.length;
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_PK_IMPORT, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.writeUint8(format, offset);
            offset += constants.SIZE_OF_UINT_8;
            let attributes = constants.BCHAIN_KEY;
            if (exportable) {
                attributes |= constants.EXPORTABLE_KEY;
            }
            if (temporary) {
                attributes |= constants.TEMPORARY_KEY;
            }
            buf.writeUInt32LE(attributes, offset);
            offset += constants.SIZE_OF_UINT_32;
            buf.write(name, offset);
            offset += constants.MAX_OBJ_FQN_LEN;
            buf.fill(dataBuff, offset, offset + dataBuff.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on import key", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Bip 32 key imported successfully");
                resolve(true);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    export(format, version, compressed, name) {
        return new Promise((resolve, reject) => {
            const payloadLen = constants.SIZE_OF_UINT_8 + constants.SIZE_OF_UINT_8 + constants.SIZE_OF_UINT_8 + constants.MAX_OBJ_FQN_LEN;
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_PK_EXPORT, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.writeUint8(format, offset);
            offset += constants.SIZE_OF_UINT_8;
            buf.writeUint8(version, offset);
            offset += constants.SIZE_OF_UINT_8;
            if (compressed) {
                buf.writeUint8(constants.COMPRESSED, offset);
            }
            else {
                buf.writeUint8(constants.NOT_COMPRESSED, offset);
            }
            offset += constants.SIZE_OF_UINT_8;
            buf.write(name, offset);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on export key", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Bip 32 key exported successfully");
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    pubKeyRecovery(sigType, hashMode, hashData, signature) {
        return new Promise((resolve, reject) => {
            const payloadLen = (constants.SIZE_OF_UINT_8 * 5) + constants.MAX_HASH_LEN + constants.MBLKC_MAX_PBK_LEN + constants.MBLKC_MAX_SIG_LEN;
            const recoverPubKeyBuf = utils_1.Aap.create(constants.MOD_BCHAIN_VERIFY, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            recoverPubKeyBuf.writeUInt8(sigType, offset);
            offset += constants.SIZE_OF_UINT_8;
            recoverPubKeyBuf.writeUInt8(hashMode, offset);
            offset += constants.SIZE_OF_UINT_8;
            recoverPubKeyBuf.fill(hashData, offset, offset + hashData.length);
            offset += constants.MAX_HASH_LEN;
            recoverPubKeyBuf.writeUInt8(constants.MBLKC_PBK_RECOVER, offset);
            offset += constants.SIZE_OF_UINT_16;
            offset += constants.MBLKC_MAX_PBK_LEN;
            recoverPubKeyBuf.writeUInt8(signature.length, offset);
            offset += constants.SIZE_OF_UINT_8;
            recoverPubKeyBuf.fill(signature, offset, offset + signature.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on recover public key from signature", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Public key recovered successfully");
                const payload = data.subarray(constants.AAP_HDR_LEN);
                const pubKeyLen = payload.readUInt8(1);
                const pubKeyStart = 2;
                resolve(payload.subarray(pubKeyStart, pubKeyStart + pubKeyLen));
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(recoverPubKeyBuf);
        });
    }
    verify(sigType, hashMode, hashData, signature, pubKeyType, pubSignature) {
        return new Promise((resolve, reject) => {
            const payloadLen = (constants.SIZE_OF_UINT_8 * 5) + constants.MAX_HASH_LEN + constants.MBLKC_MAX_PBK_LEN + constants.MBLKC_MAX_SIG_LEN;
            const signVerifyBuf = utils_1.Aap.create(constants.MOD_BCHAIN_VERIFY, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            signVerifyBuf.writeUInt8(sigType, offset);
            offset += constants.SIZE_OF_UINT_8;
            signVerifyBuf.writeUInt8(hashMode, offset);
            offset += constants.SIZE_OF_UINT_8;
            signVerifyBuf.fill(hashData, offset, offset + hashData.length);
            offset += constants.MAX_HASH_LEN;
            signVerifyBuf.writeUInt8(pubKeyType, offset);
            offset += constants.SIZE_OF_UINT_8;
            signVerifyBuf.writeUInt8(pubSignature.length, offset);
            offset += constants.SIZE_OF_UINT_8;
            signVerifyBuf.fill(pubSignature, offset, offset + pubSignature.length);
            offset += constants.MBLKC_MAX_PBK_LEN;
            signVerifyBuf.writeUInt8(signature.length, offset);
            offset += constants.SIZE_OF_UINT_8;
            signVerifyBuf.fill(signature, offset, offset + signature.length);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    if (this.isInvalidSignature(aapHdr)) {
                        resolve(false);
                        return;
                    }
                    reject(new exceptions.HsmError("Error on verify data", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Data verified successfully");
                resolve(true);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(signVerifyBuf);
        });
    }
    abn128RndCtxGetPt(x, y) {
        return new Promise((resolve, reject) => {
            if (typeof x === 'string') {
                validators.lengthValidate({
                    length: constants.ABN128_XY_HEX_LEN,
                    data: x,
                    attribute: 'x',
                    required: true,
                    reject,
                    message: `The x must be a hex string with ${constants.ABN128_XY_HEX_LEN} characters`
                });
                x = Buffer.from(x, 'hex');
            }
            else {
                validators.lengthValidate({
                    length: constants.ABN128_XY_BUFF_LEN,
                    data: x,
                    attribute: 'x',
                    required: true,
                    reject,
                    message: `The x must be a buffer with ${constants.ABN128_XY_BUFF_LEN} bytes`
                });
            }
            if (typeof y === 'string') {
                validators.lengthValidate({
                    length: constants.ABN128_XY_HEX_LEN,
                    data: y,
                    attribute: 'y',
                    required: true,
                    reject,
                    message: `The y must be a hex string with ${constants.ABN128_XY_HEX_LEN} characters`
                });
                y = Buffer.from(y, 'hex');
            }
            else {
                validators.lengthValidate({
                    length: constants.ABN128_XY_BUFF_LEN,
                    data: y,
                    attribute: 'y',
                    required: true,
                    reject,
                    message: `The y must be a buffer with ${constants.ABN128_XY_BUFF_LEN} bytes`
                });
            }
            const payloadLen = (constants.MBLKC_ABN128_XY_LEN * 2);
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_ABN128_RND_CTX_GET_PT, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.fill(x, offset, offset + constants.MBLKC_ABN128_XY_LEN);
            offset += constants.MBLKC_ABN128_XY_LEN;
            buf.fill(y, offset, offset + constants.MBLKC_ABN128_XY_LEN);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError(`Error on get point from the random context`, aapHdr.len));
                    return;
                }
                utils_1.Logger.info(`Got point from the random context successfully`);
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    abn128RndCtxMultAdd(keyName, scalar) {
        return new Promise((resolve, reject) => {
            validators.keyNameValidator(keyName, reject);
            if (typeof scalar === 'string') {
                validators.lengthValidate({
                    length: constants.ABN128_XY_HEX_LEN,
                    data: scalar,
                    attribute: 'scalar',
                    required: true,
                    reject,
                    message: `The scalar must be a hex string with ${constants.ABN128_XY_HEX_LEN} characters`
                });
                scalar = Buffer.from(scalar, 'hex');
            }
            else {
                validators.lengthValidate({
                    length: constants.ABN128_XY_BUFF_LEN,
                    data: scalar,
                    attribute: 'scalar',
                    required: true,
                    reject,
                    message: `The scalar must be a buffer with ${constants.ABN128_XY_BUFF_LEN} bytes`
                });
            }
            const payloadLen = constants.MAX_OBJ_FQN_LEN + constants.MBLKC_ABN128_XY_LEN;
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_ABN128_RND_CTX_MULT_ADD, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.write(keyName, offset);
            offset += constants.MAX_OBJ_FQN_LEN;
            buf.fill(scalar, offset, offset + constants.MBLKC_ABN128_XY_LEN);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError(`Error on multiple and add a scalar`, aapHdr.len));
                    return;
                }
                utils_1.Logger.info(`Multiple and add a scalar successfully`);
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    abn128RndScs() {
        return new Promise((resolve, reject) => {
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_ABN128_RND_SC, 0, constants.AAP_HDR_LEN);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError(`Error on get random scalars`, aapHdr.len));
                    return;
                }
                const scalers = data.subarray(constants.AAP_HDR_LEN);
                const scalersChuckes = [];
                const chunkSize = constants.ABN128_XY_BUFF_LEN;
                for (let i = 0; i < scalers.length; i += chunkSize) {
                    scalersChuckes.push(scalers.slice(i, i + chunkSize));
                }
                utils_1.Logger.info(`Random scalers got successfully`);
                resolve(scalersChuckes);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    abn128RndSc() {
        return new Promise((resolve, reject) => {
            if (this._scalars.length > 0) {
                utils_1.Logger.info(`Random scalar got successfully`);
                resolve((this._scalars.pop()));
                return;
            }
            this.abn128RndScs().then((scalers) => {
                this._scalars = scalers;
                utils_1.Logger.info(`Random scalar got successfully`);
                resolve((this._scalars.pop()));
            }).catch(reject);
        });
    }
    abn128RndCtxRefresh(x, y) {
        return new Promise((resolve, reject) => {
            if (typeof x === 'string') {
                validators.lengthValidate({
                    length: constants.ABN128_XY_HEX_LEN,
                    data: x,
                    attribute: 'x',
                    required: true,
                    reject,
                    message: `The x must be a hex string with ${constants.ABN128_XY_HEX_LEN} characters`
                });
                x = Buffer.from(x, 'hex');
            }
            else {
                validators.lengthValidate({
                    length: constants.ABN128_XY_BUFF_LEN,
                    data: x,
                    attribute: 'x',
                    required: true,
                    reject,
                    message: `The x must be a buffer with ${constants.ABN128_XY_BUFF_LEN} bytes`
                });
            }
            if (typeof y === 'string') {
                validators.lengthValidate({
                    length: constants.ABN128_XY_HEX_LEN,
                    data: y,
                    attribute: 'y',
                    required: true,
                    reject,
                    message: `The y must be a hex string with ${constants.ABN128_XY_HEX_LEN} characters`
                });
                y = Buffer.from(y, 'hex');
            }
            else {
                validators.lengthValidate({
                    length: constants.ABN128_XY_BUFF_LEN,
                    data: y,
                    attribute: 'y',
                    required: true,
                    reject,
                    message: `The y must be a buffer with ${constants.ABN128_XY_BUFF_LEN} bytes`
                });
            }
            const payloadLen = constants.MBLKC_ABN128_XY_LEN * 2;
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_ABN128_RND_CTX_REFRESH, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.fill(x, offset, offset + constants.MBLKC_ABN128_XY_LEN);
            offset += constants.MBLKC_ABN128_XY_LEN;
            buf.fill(y, offset, offset + constants.MBLKC_ABN128_XY_LEN);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError(`Error on context refresh`, aapHdr.len));
                    return;
                }
                utils_1.Logger.info(`Context refreshed successfully`);
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    abn128PscMult(keyName, x, y, neg = false) {
        return new Promise((resolve, reject) => {
            validators.keyNameValidator(keyName, reject);
            if (typeof x === 'string') {
                validators.lengthValidate({
                    length: constants.ABN128_XY_HEX_LEN,
                    data: x,
                    attribute: 'x',
                    required: true,
                    reject,
                    message: `The x must be a hex string with ${constants.ABN128_XY_HEX_LEN} characters`
                });
                x = Buffer.from(x, 'hex');
            }
            else {
                validators.lengthValidate({
                    length: constants.ABN128_XY_BUFF_LEN,
                    data: x,
                    attribute: 'x',
                    required: true,
                    reject,
                    message: `The x must be a buffer with ${constants.ABN128_XY_BUFF_LEN} bytes`
                });
            }
            if (typeof y === 'string') {
                validators.lengthValidate({
                    length: constants.ABN128_XY_HEX_LEN,
                    data: y,
                    attribute: 'y',
                    required: true,
                    reject,
                    message: `The y must be a hex string with ${constants.ABN128_XY_HEX_LEN} characters`
                });
                y = Buffer.from(y, 'hex');
            }
            else {
                validators.lengthValidate({
                    length: constants.ABN128_XY_BUFF_LEN,
                    data: y,
                    attribute: 'y',
                    required: true,
                    reject,
                    message: `The y must be a buffer with ${constants.ABN128_XY_BUFF_LEN} bytes`
                });
            }
            const payloadLen = constants.SIZE_OF_UINT_8 + constants.MAX_OBJ_FQN_LEN + (constants.MBLKC_ABN128_XY_LEN * 2);
            const buf = utils_1.Aap.create(constants.MOD_BCHAIN_ABN128_PSC_MULT, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.writeUInt8(neg ? 1 : 0, offset);
            offset += constants.SIZE_OF_UINT_8;
            buf.write(keyName, offset);
            offset += constants.MAX_OBJ_FQN_LEN;
            buf.fill(x, offset, offset + constants.MBLKC_ABN128_XY_LEN);
            offset += constants.MBLKC_ABN128_XY_LEN;
            buf.fill(y, offset, offset + constants.MBLKC_ABN128_XY_LEN);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError(`Error on context refresh`, aapHdr.len));
                    return;
                }
                utils_1.Logger.info(`Context refreshed successfully`);
                resolve(data.subarray(constants.AAP_HDR_LEN));
            });
            this.conn.once("error", (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    bufToBlockchainKeyInfo(buf) {
        const xVerBytes = [
            buf.readUInt8(5),
            buf.readUInt8(6),
            buf.readUInt8(7),
            buf.readUInt8(8)
        ];
        const xParentFpBytes = [
            buf.readUInt8(10),
            buf.readUInt8(11),
            buf.readUInt8(12),
            buf.readUInt8(13)
        ];
        const xChildNumBytes = [
            buf.readUInt8(14),
            buf.readUInt8(15),
            buf.readUInt8(16),
            buf.readUInt8(17)
        ];
        const byteArrayToString = (byteArray) => {
            return byteArray.map(byte => byte.toString(16).padStart(2, "0").toUpperCase()).join("");
        };
        return {
            ver: buf.readUInt8(0),
            type: buf.readUInt32LE(1),
            xVer: byteArrayToString(xVerBytes),
            xDepth: buf.readUInt8(9),
            xParentFp: byteArrayToString(xParentFpBytes),
            xChildNum: byteArrayToString(xChildNumBytes)
        };
    }
    isInvalidSignature(aapHdr) {
        return (aapHdr.len & constants.ERR_INCREMENT) === constants.ERR_INVALID_SIGNATURE;
    }
}
exports.default = Blockchain;
