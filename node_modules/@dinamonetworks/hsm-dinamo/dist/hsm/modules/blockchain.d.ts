import tls from "tls";
import * as interfaces from "../interfaces";
import * as enums from "../enums";
import HsmBaseModule from "./hsm_base_module";
export default class Blockchain extends HsmBaseModule implements interfaces.blockchain.Blockchain {
    private _scalars;
    constructor(conn: tls.TLSSocket);
    create(name: string, type: enums.BLOCKCHAIN_KEYS, exportable: boolean, temporary: boolean, version?: enums.VERSION_OPTIONS | null, seed?: string | null, passphrase?: string | null): Promise<boolean>;
    delete(name: string): Promise<boolean>;
    block(name: string): Promise<boolean>;
    unblock(name: string): Promise<boolean>;
    getPubKey(type: enums.BLOCKCHAIN_GET_PUB_KEY_TYPE, privKeyName: string): Promise<Buffer>;
    createBip32ChildKeyDerivation(version: enums.VERSION_OPTIONS, index: enums.BCHAIN_SECURE_BIP32_INDEX | number, exportable: boolean, temporary: boolean, parentKeyName: string, childKeyName: string): Promise<interfaces.blockchain.KeyInfo>;
    hashData(hashMode: enums.BLOCKCHAIN_HASH_MODE, data: Buffer): Promise<Buffer>;
    edDsaSign(type: enums.BLOCKCHAIN_EdDSA_TYPE, privKeyName: string, data: Buffer): Promise<Buffer>;
    edDsaVerify(type: enums.BLOCKCHAIN_EdDSA_TYPE, pubKeyType: enums.BLOCKCHAIN_PUB_KEY_TYPE, pubKey: Buffer, signature: Buffer, data: Buffer): Promise<boolean>;
    getAddress(type: enums.ADDRESS_TYPE, version: enums.ADDRESS_VERSION, hrp: enums.ADDRESS_HRP, pk: string): Promise<Buffer>;
    sign(type: enums.BLOCKCHAIN_SIG_TYPE, hashMode: enums.BLOCKCHAIN_HASH_MODE, hash: Buffer, pk: string): Promise<Buffer>;
    getKeyInfo(name: string): Promise<interfaces.blockchain.KeyInfo>;
    import(format: enums.IMPORT_EXPORT_FORMAT, exportable: boolean, temporary: boolean, name: string, data: string): Promise<boolean>;
    export(format: enums.IMPORT_EXPORT_FORMAT, version: enums.BLOCKCHAIN_EXPORT_VERSION, compressed: boolean, name: string): Promise<Buffer>;
    pubKeyRecovery(sigType: enums.BLOCKCHAIN_SIG_TYPE, hashMode: enums.BLOCKCHAIN_HASH_MODE, hashData: Buffer, signature: Buffer): Promise<Buffer>;
    verify(sigType: enums.BLOCKCHAIN_SIG_TYPE, hashMode: enums.BLOCKCHAIN_HASH_MODE, hashData: Buffer, signature: Buffer, pubKeyType: enums.BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE, pubSignature: Buffer): Promise<boolean>;
    abn128RndCtxGetPt(x: string | Buffer, y: string | Buffer): Promise<Buffer>;
    abn128RndCtxMultAdd(keyName: string, scalar: string | Buffer): Promise<Buffer>;
    abn128RndScs(): Promise<Array<Buffer>>;
    abn128RndSc(): Promise<Buffer>;
    abn128RndCtxRefresh(x: string | Buffer, y: string | Buffer): Promise<Buffer>;
    abn128PscMult(keyName: string, x: string | Buffer, y: string | Buffer, neg?: boolean): Promise<Buffer>;
    private bufToBlockchainKeyInfo;
    private isInvalidSignature;
}
