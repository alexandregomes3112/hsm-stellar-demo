import tls from "tls";
import * as interfaces from "../interfaces";
import HsmBaseModule from "./hsm_base_module";
import * as enums from "../enums";
export default class Cryptography extends HsmBaseModule implements interfaces.cryptography.Cryptography {
    constructor(conn: tls.TLSSocket);
    mOfnSplit(m: number, n: number, secret: string | null): Promise<interfaces.cryptography.MofNSplit>;
    mOfNRecover(parts: Buffer[]): Promise<Buffer>;
    rsaSign(keyName: string, hashAlgorithm: enums.HASH_ALGORITHMS, hash: Buffer, pad: enums.PAD_TYPE): Promise<Buffer>;
    rsaVerify(keyName: string, hashAlgorithm: enums.HASH_ALGORITHMS, pad: enums.PAD_TYPE, hash: Buffer, signature: Buffer): Promise<boolean>;
    eccSign(keyName: string, hashAlgorithm: enums.HASH_ALGORITHMS, hash: Buffer): Promise<Buffer>;
    eccVerify(keyName: string, hashAlgorithm: enums.HASH_ALGORITHMS, hash: Buffer, signature: Buffer): Promise<boolean>;
    eddsaSign(keyName: string, hash: Buffer): Promise<Buffer>;
    eddsaVerify(keyName: string, hash: Buffer, signature: Buffer): Promise<boolean>;
    private decodeOaepPadding;
    private mgf1;
    private removePKCS1Padding;
    dataUnenvelop(keyName: string, data: Buffer, paddingOption: enums.ENC_DEC_PADDING): Promise<Buffer>;
    private encodePKCS1Padding;
    private encodeOaepPadding;
    dataEnvelop(pubKey: Buffer, keyLength: enums.RSA_LENGTH_KEYS, data: Buffer, paddingOption: enums.ENC_DEC_PADDING): Promise<Buffer>;
    genRand(len: number): Promise<Buffer>;
    private bufToMOfNSplit;
    private isInvalidSignature;
}
