"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const hsm_base_module_1 = __importDefault(require("./hsm_base_module"));
const constants = __importStar(require("../constants"));
const enums = __importStar(require("../enums"));
const utils_1 = require("../../utils");
const path = __importStar(require("path"));
const os = __importStar(require("os"));
const fs = __importStar(require("fs"));
const cryptography_1 = __importDefault(require("./cryptography"));
const node_child_process_1 = require("node:child_process");
const exceptions_1 = require("../exceptions");
const index_1 = require("../index");
class Management extends hsm_base_module_1.default {
    constructor(conn) {
        super(conn);
        this.cryptography = new cryptography_1.default(conn);
    }
    getWindowsExecutablePath() {
        const registryKeys = [
            "HKLM\\SOFTWARE\\Google\\Chrome\\NativeMessagingHosts\\com.dinamonetworks.hsm",
            "HKCU\\SOFTWARE\\Google\\Chrome\\NativeMessagingHosts\\com.dinamonetworks.hsm"
        ];
        const defaultPath = "C:\\Program Files\\Dinamo Networks\\HSM Dinamo\\com.dinamonetworks.hsm.json";
        let manifestPath = null;
        for (const registryKey of registryKeys) {
            try {
                manifestPath = (0, node_child_process_1.execSync)(`reg query "${registryKey}" /ve`, { stdio: ['ignore', 'pipe', 'ignore'] })
                    .toString()
                    .split("REG_SZ")[1]
                    .trim();
                if (fs.existsSync(manifestPath)) {
                    break;
                }
                else {
                    manifestPath = null;
                }
            }
            catch {
                manifestPath = null;
            }
        }
        if (!manifestPath) {
            manifestPath = defaultPath;
            if (!fs.existsSync(manifestPath)) {
                throw new index_1.exceptions.HsmError("Não foi possível encontrar o arquivo de manifesto ou o executável.");
            }
        }
        let executablePath;
        if (manifestPath.endsWith('.json')) {
            const manifest = JSON.parse(fs.readFileSync(manifestPath, "utf-8"));
            executablePath = manifest.path;
            if (!path.isAbsolute(executablePath)) {
                const manifestDir = path.dirname(manifestPath);
                executablePath = path.resolve(manifestDir, executablePath);
            }
        }
        else {
            executablePath = manifestPath;
        }
        if (!fs.existsSync(executablePath)) {
            throw new index_1.exceptions.HsmError("O executável não foi encontrado.");
        }
        return executablePath;
    }
    setNsAuthState(aclMask, state, share) {
        return new Promise((resolve, reject) => {
            const isSVMK2 = share.every((part) => this.isSVMK2(part));
            this.validateParts(isSVMK2 ? enums.SVMK_VERSION.V2 : enums.SVMK_VERSION.V1, share);
            const selectNsAuthStateMode = isSVMK2 ? constants.MOD_STAT_SET_NSAUTH_STATE_2 : constants.MOD_STAT_SET_NSAUTH_STATE;
            if (share.length === 0 || share.length > constants.MC_M_OF_N_S_MAX) {
                return reject(new exceptions_1.HsmError(`The number of shares must be between 1 and ${constants.MC_M_OF_N_S_MAX}.`));
            }
            const shareBytes = share.map((s) => Buffer.from(s, "hex"));
            const m_vLength = shareBytes.reduce((total, share) => total + share.length, 0);
            const payloadLen = constants.SIZE_OF_UINT_32 + constants.SIZE_OF_UINT_8 + m_vLength;
            const buf = utils_1.Aap.create(selectNsAuthStateMode, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            buf.writeUInt32LE(aclMask, offset);
            offset += constants.SIZE_OF_UINT_32;
            buf.writeUInt8(state, offset);
            offset += constants.SIZE_OF_UINT_8;
            shareBytes.forEach((share) => {
                buf.set(share, offset);
                offset += share.length;
            });
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions_1.HsmError("Error setting NS Auth State", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("NS Auth State set successfully");
                resolve(true);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions_1.HsmError(err.message));
            });
            this.conn.write(buf);
        });
    }
    async listObjs() {
        return new Promise((resolve, reject) => {
            let buffer = Buffer.alloc(0);
            const objects = [];
            const request = utils_1.Aap.create(constants.MOD_CORE_LST_OBJS, 0, constants.AAP_HDR_LEN);
            this.conn.write(request);
            const handleData = (data) => {
                buffer = Buffer.concat([buffer, data]); // Acumula os dados recebidos.
                const aapHdr = utils_1.Aap.read(buffer);
                if (utils_1.Aap.hasError(aapHdr)) {
                    this.conn.off("data", handleData);
                    return reject(new exceptions_1.HsmError("Erro ao listar objetos", aapHdr.len));
                }
                const payload = buffer.subarray(constants.AAP_HDR_LEN);
                if (payload.equals(Buffer.from(''))) {
                    this.conn.off("data", handleData);
                    return resolve(objects);
                }
                if (objects.length === 0) {
                    let offset = 0;
                    while (offset < payload.length) {
                        const nullTerminatorIndex = payload.indexOf(0, offset);
                        if (nullTerminatorIndex === -1)
                            break;
                        const objName = payload.subarray(offset, nullTerminatorIndex).toString("ascii");
                        objects.push(objName);
                        offset = nullTerminatorIndex + 1;
                    }
                }
                else {
                    const expectedLength = payload.length - 1; // Remove terminador.
                    const objName = payload.subarray(0, expectedLength).toString("ascii");
                    objects.push(objName);
                }
                buffer = Buffer.alloc(0);
            };
            this.conn.on("data", handleData);
            this.conn.once("error", (err) => {
                this.conn.off("data", handleData);
                reject(new exceptions_1.HsmError(err.message));
            });
        });
    }
    generateSVMK(m, n, secret, version) {
        return new Promise((resolve, reject) => {
            let promise;
            this.validateSecret(secret ? secret : null, version);
            if (version === 1) {
                promise = this.cryptography.mOfnSplit(m, n, secret);
            }
            else {
                promise = this.mOfnSplit2(m, n, secret);
            }
            promise.then((response) => {
                utils_1.Logger.info("SVMK generated successfully");
                resolve(this.handleResponseSVMK(response, m, n, version));
            }).catch((error) => {
                utils_1.Logger.error(`Erro em generateSVMK: ${error instanceof Error ? error.message : 'Erro desconhecido'}`);
                if (error instanceof exceptions_1.HsmError) {
                    reject(error);
                }
                else {
                    reject(new exceptions_1.HsmError(`Erro ao gerar SVMK: ${error instanceof Error ? error.message : 'Erro desconhecido'}`));
                }
            });
        });
    }
    recoverSVMK(parts) {
        return new Promise((resolve) => {
            this.numberOfParts(parts);
            const isSVMK2 = parts.every((part) => this.isSVMK2(part));
            this.numberOfParts(parts);
            this.validateParts(isSVMK2 ? enums.SVMK_VERSION.V2 : enums.SVMK_VERSION.V1, parts);
            let promise;
            if (isSVMK2) {
                promise = this.mOfnRecover2(parts.map((part) => Buffer.from(part, 'hex')));
            }
            else {
                promise = this.cryptography.mOfNRecover(parts.map((part) => Buffer.from(part, 'hex')));
            }
            promise.then((response) => {
                utils_1.Logger.info("SVMK recovered successfully");
                resolve(response.toString('hex'));
            }).catch((error) => {
                utils_1.Logger.error(`Erro em recoverSVMK: ${error instanceof Error ? error.message : 'Erro desconhecido'}`);
            });
        });
    }
    validateSecret(secret, version) {
        if (secret) {
            if (!/^[ -~]+$/.test(secret)) {
                throw new exceptions_1.HsmError(`Secret must be an ASCII string.`);
            }
            const expectedLength = version === 1 ? constants.M_OF_N_SECRET_LEN : constants.MC_M_OF_N_S_LEN2;
            if (secret.length < expectedLength) {
                throw new exceptions_1.HsmError(`Secret must be at least ${expectedLength} characters long for version ${version}.`);
            }
            if (secret.length % 2 !== 0) {
                throw new exceptions_1.HsmError(`Secret length must be even.`);
            }
        }
        return;
    }
    handleResponseSVMK(obj, m, n, version) {
        return {
            SVMKVersion: version ?? 2,
            secret: obj.secret ? obj.secret.toString("hex") : null,
            entropy: obj.entropy ?? null,
            m: m,
            n: n,
            parts: obj.parts.map((part) => part.toString("hex"))
        };
    }
    isSVMK2(partHex) {
        try {
            const partLen = (constants.MC_M_OF_N_SCHEME_ML + constants.MC_M_OF_N_S_LEN2) * 2;
            if (partHex.length !== partLen) {
                utils_1.Logger.info(`Invalid length to SVMK2: ${partHex.length / 2}`);
                return false;
            }
            return true;
        }
        catch {
            return false;
        }
    }
    mOfnSplit2(m, n, secret) {
        return new Promise((resolve, reject) => {
            this.mOfnValidate(m, n);
            const secretLen = constants.MC_M_OF_N_S_LEN2;
            const payloadLen = constants.SIZE_OF_UINT_8 * 2 + secretLen;
            const mOfnBuf = utils_1.Aap.create(constants.MOD_CORE_M_OF_N_SPLIT2, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            if (secret) {
                const paddedSecret = Buffer.alloc(secretLen);
                paddedSecret.write(secret);
                mOfnBuf.set(paddedSecret, offset);
            }
            offset += secretLen;
            mOfnBuf.writeUInt8(m, offset);
            offset += constants.SIZE_OF_UINT_8;
            mOfnBuf.writeUInt8(n, offset);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions_1.HsmError("Error on divide secret", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("M of N split success");
                const payload = data.subarray(constants.AAP_HDR_LEN);
                resolve(this.bufToMOfNSplit2(payload, n, reject));
            });
            this.conn.once("error", (err) => {
                reject(err);
                return;
            });
            this.conn.write(mOfnBuf);
        });
    }
    mOfnRecover2(parts) {
        return new Promise((resolve, reject) => {
            const partLen = constants.MC_M_OF_N_SCHEME_ML + constants.MC_M_OF_N_S_LEN2;
            const payloadLen = parts.length * partLen;
            const mOfnBuf = utils_1.Aap.create(constants.MOD_CORE_M_OF_N_RECOVER2, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            let offset = constants.AAP_HDR_LEN;
            parts.forEach((part) => {
                mOfnBuf.set(part, offset);
                offset += partLen;
            });
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions_1.HsmError("Error on recover secret", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("M of N recover success");
                const payload = data.subarray(constants.AAP_HDR_LEN);
                resolve(payload);
            });
            this.conn.once("error", (err) => {
                reject(err);
                return;
            });
            this.conn.write(mOfnBuf);
        });
    }
    mOfnValidate(m, n) {
        if (m > n) {
            utils_1.Logger.error(`generateSVMK: m must be less than or equal to n`);
            throw new exceptions_1.HsmError("M must be less than or equal to N");
        }
    }
    numberOfParts(parts) {
        if (parts.length === 0) {
            utils_1.Logger.error(`recoverSVMK: no part informed to recover the SVMK`);
            throw new exceptions_1.HsmError(`The shadows must be informed to recover the secret`);
        }
        const part = Buffer.from(parts[0], 'hex');
        const m = part.readUInt8(0);
        if (parts && parts.length < m) {
            utils_1.Logger.error(`recoverSVMK: Invalid number of parts to recover the secret`);
            throw new exceptions_1.HsmError(`Secret must be ${constants.MC_M_OF_N_S_LEN2} characters`);
        }
    }
    bufToMOfNSplit2(buf, n, reject) {
        const partLen = constants.MC_M_OF_N_SCHEME_ML + constants.MC_M_OF_N_S_LEN2; // Tamanho fixo de 59 bytes
        const expectedLength = n * partLen;
        if (buf.length !== expectedLength) {
            reject(new exceptions_1.HsmError(`Invalid buffer length. Expected ${expectedLength}, received ${buf.length}.`));
            return { secret: Buffer.alloc(0), entropy: Buffer.alloc(0), parts: [] };
        }
        const parts = [];
        for (let i = 0; i < n; i++) {
            const part = buf.subarray(i * partLen, (i + 1) * partLen);
            parts.push(part);
        }
        return { secret: Buffer.alloc(0), entropy: Buffer.alloc(0), parts };
    }
    async getShadow(pin, path) {
        try {
            this.validatePin(pin);
            const command = { command: 'getShadow', pin };
            return this.executeNativeHostCommand(command, path);
        }
        catch (e) {
            if (e instanceof exceptions_1.HsmError) {
                throw e;
            }
            throw new exceptions_1.HsmError('Unknow erro');
        }
    }
    async getScInfo(path) {
        const command = { command: 'getScInfo' };
        return this.executeNativeHostCommand(command, path);
    }
    async getScLabel(pin, path) {
        try {
            this.validatePin(pin);
            const command = { command: 'getLabel', pin };
            return this.executeNativeHostCommand(command, path);
        }
        catch (e) {
            if (e instanceof exceptions_1.HsmError) {
                throw e;
            }
            throw new exceptions_1.HsmError('Unknow erro');
        }
    }
    async setScLabel(pin, label, path) {
        try {
            this.validatePin(pin);
            this.validateLabel(label);
            const command = { command: 'setLabel', pin, label };
            return this.executeNativeHostCommand(command, path);
        }
        catch (e) {
            if (e instanceof exceptions_1.HsmError) {
                throw e;
            }
            throw new exceptions_1.HsmError('Unknow erro');
        }
    }
    async changeScPin(oldPin, newPin, path) {
        try {
            this.validatePin(oldPin);
            this.validatePin(newPin);
            const command = { command: 'changePin', old_pin: oldPin, new_pin: newPin };
            return this.executeNativeHostCommand(command, path);
        }
        catch (e) {
            if (e instanceof exceptions_1.HsmError) {
                throw e;
            }
            throw new exceptions_1.HsmError('Unknow erro');
        }
    }
    async writeScSVMK(pin, shadow, overwrite, path) {
        try {
            this.validatePin(pin);
            const svmkVersion = this.isSVMK2(shadow);
            this.validateSVMK(svmkVersion ? enums.SVMK_VERSION.V2 : enums.SVMK_VERSION.V1, shadow);
            const command = {
                command: "writeSvmk",
                pin,
                version: svmkVersion ? enums.SVMK_VERSION.V2 : enums.SVMK_VERSION.V1,
                shadow,
                overwrite
            };
            return this.executeNativeHostCommand(command, path);
        }
        catch (e) {
            if (e instanceof exceptions_1.HsmError) {
                throw e;
            }
            throw new exceptions_1.HsmError('Unknow erro');
        }
    }
    async eraseSmartCard(pin, path) {
        try {
            this.validatePin(pin);
            const command = { command: 'eraseSmartCard', pin };
            return this.executeNativeHostCommand(command, path);
        }
        catch (e) {
            if (e instanceof exceptions_1.HsmError) {
                throw e;
            }
            throw new exceptions_1.HsmError('Unknow erro');
        }
    }
    async setTlsBundle(key, cert) {
        return new Promise((resolve, reject) => {
            try {
                if ((!key && cert) || (key && !cert)) {
                    throw new index_1.exceptions.HsmError("key or certificate id not set", 5023);
                }
                const maxObjFqnLen = constants.MAX_OBJ_FQN_LEN;
                const payloadLen = maxObjFqnLen * 2;
                const setTLSBundleBuffer = utils_1.Aap.create(constants.MOD_CORE_SET_TLS_BUNDLE, payloadLen, constants.AAP_HDR_LEN + payloadLen);
                let offset = constants.AAP_HDR_LEN;
                if (key) {
                    setTLSBundleBuffer.write(key, offset, maxObjFqnLen);
                }
                offset += maxObjFqnLen;
                if (cert) {
                    setTLSBundleBuffer.write(cert, offset, maxObjFqnLen);
                }
                this.conn.once("data", (data) => {
                    const aapHdr = utils_1.Aap.read(data);
                    if (utils_1.Aap.hasError(aapHdr)) {
                        utils_1.Logger.error("Error setting TLS Bundle");
                        reject(new index_1.exceptions.HsmError("Error setting TLS Bundle", aapHdr.len));
                        return;
                    }
                    utils_1.Logger.info("Sucess to set/unset TLS Bundle");
                    if (!key && !cert) {
                        resolve({ status: 0, message: "Sucess to reset TLS Bundle" });
                    }
                    else {
                        resolve({ status: 0, message: "Sucess to set TLS Bundle" });
                    }
                });
                this.conn.once("error", (err) => {
                    reject(err);
                    return;
                });
                this.conn.write(setTLSBundleBuffer);
            }
            catch (error) {
                utils_1.Logger.error(error instanceof Error ? error.message : 'Error setting TLS Bundle');
                reject(error);
            }
        });
    }
    validatePin(pin) {
        if (!/^[0-9]+$/.test(pin)) {
            throw new exceptions_1.HsmError(`PIN must be a numeric string.`);
        }
        if (pin.length !== constants.DN_SC_MAX_PIN_LEN) {
            throw new exceptions_1.HsmError(`PIN length must be exactly ${constants.DN_SC_MAX_PIN_LEN} characters.`);
        }
    }
    validateSVMK(version, shadow) {
        const maxLength = version === 1 ? constants.MC_M_OF_N_S_PARTLEN : constants.MC_M_OF_N_SCHEME_ML + constants.MC_M_OF_N_S_LEN2;
        if (!/^[0-9a-fA-F]*$/.test(shadow)) {
            throw new exceptions_1.HsmError(`Invalid part format: ${shadow}. Must be hexadecimal.`);
        }
        const byteLength = shadow.length / 2;
        if (byteLength !== maxLength) {
            throw new exceptions_1.HsmError(`Invalid shadow length: ${shadow.length} characters. Must be ${constants.MC_M_OF_N_S_PARTLEN * 2} characters for SVMK V1 or ${(constants.MC_M_OF_N_SCHEME_ML + constants.MC_M_OF_N_S_LEN2) * 2} characters for SVMK V2.`);
        }
    }
    validateParts(version, parts) {
        if (!parts || parts.length === 0) {
            throw new exceptions_1.HsmError("No parts provided.");
        }
        for (const part of parts) {
            this.validateSVMK(version, part);
        }
    }
    async executeNativeHostCommand(command, path) {
        return new Promise((resolve, reject) => {
            let executablePath;
            const isWindows = os.platform() === 'win32';
            if (path) {
                executablePath = path;
            }
            else {
                executablePath = isWindows ? this.getWindowsExecutablePath() : '/opt/dinamonetworks/dinamonh.exe';
            }
            if (!fs.existsSync(executablePath)) {
                return reject(new exceptions_1.HsmError(`Executable not found at path: ${executablePath}`));
            }
            this.nh = (0, node_child_process_1.spawn)(executablePath, [], { stdio: 'pipe' });
            const sendCommand = (data) => {
                const message = JSON.stringify(data);
                const messageLength = Buffer.alloc(Management.MESSAGE_LENGTH_SIZE);
                messageLength.writeUInt32LE(message.length, 0);
                this.nh.stdin.write(messageLength);
                this.nh.stdin.write(message);
            };
            sendCommand(command);
            const close = { command: 'close' };
            let buffer = Buffer.alloc(0);
            this.nh.stdout.on("data", (data) => {
                buffer = Buffer.concat([buffer, data]);
                while (buffer.length >= Management.MESSAGE_LENGTH_SIZE) {
                    const messageLength = buffer.readUInt32LE(0);
                    if (buffer.length >= Management.MESSAGE_LENGTH_SIZE + messageLength) {
                        const message = buffer
                            .subarray(Management.MESSAGE_LENGTH_SIZE, Management.MESSAGE_LENGTH_SIZE + messageLength)
                            .toString();
                        buffer = buffer.subarray(Management.MESSAGE_LENGTH_SIZE + messageLength);
                        try {
                            const response = JSON.parse(message);
                            switch (response.status) {
                                case enums.NH_RESPONSE_STATUS.STATUS_SUCCESS:
                                    resolve(response);
                                    sendCommand(close);
                                    break;
                                case enums.NH_RESPONSE_STATUS.STATUS_ERROR:
                                    reject(response);
                                    break;
                                case enums.NH_RESPONSE_STATUS.STATUS_UNKNOWN_COMMAND:
                                    reject(new exceptions_1.HsmError("The command sent is unknown."));
                                    break;
                                default:
                                    reject(new exceptions_1.HsmError(`Unexpected error code: ${response.status}`));
                            }
                        }
                        catch {
                            reject(new exceptions_1.HsmError("Failed to parse JSON"));
                        }
                        finally {
                            if (isWindows) {
                                sendCommand(close);
                            }
                            else {
                                this.nh.kill();
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            });
            this.nh.stderr.on("data", (data) => {
                reject(new exceptions_1.HsmError(data.toString()));
            });
        });
    }
    validateLabel(label) {
        if (!label) {
            throw new exceptions_1.HsmError("Label cannot be empty.");
        }
        if (!/^[ -~]+$/.test(label)) {
            throw new exceptions_1.HsmError("Label must contain only ASCII characters.");
        }
    }
    async setUserParam(user, der) {
        return new Promise((resolve, reject) => {
            try {
                const userLen = constants.MAX_USR_LEN + 1;
                const payloadLen = userLen + der.length;
                const setUserParamBuffer = utils_1.Aap.create(constants.MOD_CORE_NEW_AUTH_SA, payloadLen, constants.AAP_HDR_LEN + payloadLen);
                let offset = constants.AAP_HDR_LEN;
                setUserParamBuffer.write(user, offset, userLen);
                offset += userLen;
                setUserParamBuffer.set(der, offset);
                this.conn.once("data", (data) => {
                    const aapHdr = utils_1.Aap.read(data);
                    if (utils_1.Aap.hasError(aapHdr)) {
                        utils_1.Logger.error("Error setting User Param");
                        reject(new index_1.exceptions.HsmError("Error setting User Param", aapHdr.len));
                        return;
                    }
                    utils_1.Logger.info("Sucess setting User Param");
                    resolve({ status: 0, message: "Sucess setting User Param" });
                });
                this.conn.once("error", (err) => {
                    reject(err);
                    return;
                });
                this.conn.write(setUserParamBuffer);
            }
            catch (error) {
                utils_1.Logger.error(error instanceof Error ? error.message : 'Error to setting User Param');
                reject(error);
            }
        });
    }
    async deleteAuthSA(user, tfaType) {
        return new Promise((resolve, reject) => {
            try {
                const payloadLen = constants.MAX_USR_LEN + 1;
                const operation = tfaType === enums.TFA_TYPE.OTP ? constants.MOD_CORE_DEL_AUTH_SA_OTP : constants.MOD_CORE_DEL_AUTH_SA_X509;
                const deleteAuthBuffer = utils_1.Aap.create(constants.MOD_CORE_DEL_AUTH_SA, operation, constants.AAP_HDR_LEN + payloadLen);
                deleteAuthBuffer.write(user, constants.AAP_HDR_LEN, payloadLen, 'ascii');
                this.conn.once("data", (data) => {
                    const aapHdr = utils_1.Aap.read(data);
                    if (utils_1.Aap.hasError(aapHdr)) {
                        utils_1.Logger.error("Error to delete TFA");
                        reject(new index_1.exceptions.HsmError("Error to delete TFA", aapHdr.len));
                        return;
                    }
                    utils_1.Logger.info("Sucess to delete TFA");
                    resolve({ status: 0, message: "Sucess to delete TFA" });
                });
                this.conn.once("error", (err) => {
                    reject(err);
                    return;
                });
                this.conn.write(deleteAuthBuffer);
            }
            catch (error) {
                utils_1.Logger.error(error instanceof Error ? error.message : 'Error to delete auth sa');
                reject(error);
            }
        });
    }
    async getUserAcl(user) {
        return new Promise((resolve, reject) => {
            try {
                const payloadLen = constants.MAX_USR_LEN + 1;
                const getUserAclBuffer = utils_1.Aap.create(constants.MOD_CORE_GET_ACL, payloadLen, constants.AAP_HDR_LEN + payloadLen);
                getUserAclBuffer.write(user, constants.AAP_HDR_LEN, payloadLen);
                this.conn.once("data", (data) => {
                    const aapHdr = utils_1.Aap.read(data);
                    if (utils_1.Aap.hasError(aapHdr)) {
                        utils_1.Logger.error("Error getting User ACL");
                        reject(new index_1.exceptions.HsmError("Error getting User ACL", aapHdr.len));
                        return;
                    }
                    utils_1.Logger.info("Sucess getting User ACL");
                    const acl = data.subarray(constants.AAP_HDR_LEN);
                    const aclList = this.getPermissions(acl);
                    resolve({ acl, aclList });
                });
                this.conn.once("error", (err) => {
                    reject(err);
                    return;
                });
                this.conn.write(getUserAclBuffer);
            }
            catch (error) {
                utils_1.Logger.error(error instanceof Error ? error.message : 'Error to getting User ACL');
                reject(error);
            }
        });
    }
    async setUserAcl(user, acl) {
        return new Promise((resolve, reject) => {
            try {
                const payloadLen = constants.MAX_USR_LEN + 1 + constants.SIZE_OF_UINT_32;
                const setUserAclBuffer = utils_1.Aap.create(constants.MOD_CORE_UPDATE_ACL, payloadLen, constants.AAP_HDR_LEN + payloadLen);
                let offset = constants.AAP_HDR_LEN;
                setUserAclBuffer.write(user, offset, constants.MAX_USR_LEN + 1);
                offset += constants.MAX_USR_LEN + 1;
                const aclMask = acl.reduce((acc, value) => acc | value, 0);
                setUserAclBuffer.writeUInt32LE(aclMask, offset);
                this.conn.once("data", (data) => {
                    const aapHdr = utils_1.Aap.read(data);
                    if (utils_1.Aap.hasError(aapHdr)) {
                        utils_1.Logger.error("Error setting User ACL");
                        reject(new index_1.exceptions.HsmError("Error setting User ACL", aapHdr.len));
                        return;
                    }
                    utils_1.Logger.info("Success setting User ACL");
                    resolve({ status: 0, message: "Success setting User ACL" });
                });
                this.conn.once("error", (err) => {
                    reject(err);
                    return;
                });
                this.conn.write(setUserAclBuffer);
            }
            catch (error) {
                utils_1.Logger.error(error instanceof Error ? error.message : 'Error to setting User ACL');
                reject(error);
            }
        });
    }
    async listBlobs() {
        return new Promise((resolve, reject) => {
            let buffer = Buffer.alloc(0);
            const blobs = [];
            const request = utils_1.Aap.create(constants.MOD_CORE_LST_BLOBS, 0, constants.AAP_HDR_LEN);
            this.conn.write(request);
            const handleData = (data) => {
                buffer = Buffer.concat([buffer, data]);
                const aapHdr = utils_1.Aap.read(buffer);
                if (utils_1.Aap.hasError(aapHdr)) {
                    this.conn.off("data", handleData);
                    return reject(new exceptions_1.HsmError("Error listing blobs", aapHdr.len));
                }
                const payload = buffer.subarray(constants.AAP_HDR_LEN);
                if (payload.equals(Buffer.from(''))) {
                    this.conn.off("data", handleData);
                    return resolve(blobs);
                }
                if (blobs.length === 0) {
                    let offset = 0;
                    while (offset < payload.length) {
                        const nullTerminatorIndex = payload.indexOf(0, offset);
                        if (nullTerminatorIndex === -1)
                            break;
                        const objId = payload.subarray(offset, nullTerminatorIndex).toString("ascii");
                        blobs.push(objId);
                        offset = nullTerminatorIndex + 1;
                    }
                }
                else {
                    const expectedLength = payload.length - 1;
                    const objId = payload.subarray(0, expectedLength).toString("ascii");
                    blobs.push(objId);
                }
                buffer = Buffer.alloc(0);
            };
            this.conn.on("data", handleData);
            this.conn.once("error", (err) => {
                this.conn.off("data", handleData);
                reject(new exceptions_1.HsmError(err.message));
            });
        });
    }
    async getObjectInfo(objId) {
        return this.objectInfo(objId, false);
    }
    async getObjectInfoModprobe(objId) {
        return this.objectInfo(objId, true);
    }
    async objectInfo(objId, modProbe) {
        return new Promise((resolve, reject) => {
            const payloadLen = constants.MAX_OBJ_FQN_LEN;
            const objInfoBuffer = utils_1.Aap.create(modProbe ? constants.MOD_CORE_PROBE_OBJ_INFO : constants.MOD_CORE_GET_OBJ_INFO, payloadLen, constants.AAP_HDR_LEN + payloadLen);
            objInfoBuffer.write(objId, constants.AAP_HDR_LEN, constants.MAX_OBJ_FQN_LEN);
            this.conn.once("data", (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions_1.HsmError("Error getting object info", aapHdr.len));
                    return;
                }
                const payload = data.subarray(constants.AAP_HDR_LEN);
                const objInfo = this.parseObjectInfo(payload);
                resolve(objInfo);
            });
            this.conn.once("error", (err) => {
                reject(new exceptions_1.HsmError(err.message));
            });
            this.conn.write(objInfoBuffer);
        });
    }
    parseObjectInfo(payload) {
        const version = payload.subarray(0, constants.SIZE_OF_UINT_32).readUInt32LE();
        const typeBuffer = payload.subarray(constants.SIZE_OF_UINT_32, 2 * constants.SIZE_OF_UINT_32).readUInt32LE();
        const attribBuffer = payload.subarray(2 * constants.SIZE_OF_UINT_32, 3 * constants.SIZE_OF_UINT_32);
        const type = this.getType(typeBuffer);
        const attributes = this.getAttributes(attribBuffer);
        return { version, type, attributes };
    }
    getType(type) {
        let alg = "Unknown Object Type";
        for (const chave in constants.OBJ_TYPES) {
            if (constants.OBJ_TYPES[chave] === type) {
                alg = chave;
                break;
            }
        }
        return alg;
    }
    getPermissions(aclBuffer) {
        const aclValue = aclBuffer.readUInt32LE(0);
        const permissions = [];
        for (const key in enums.ACL_MASK) {
            if (isNaN(Number(key))) {
                const value = enums.ACL_MASK[key];
                if ((aclValue & value) !== 0) {
                    permissions.push(key);
                }
            }
        }
        return permissions;
    }
    getAttributes(attrib) {
        const attrValue = attrib.readUIntLE(0, 3);
        const aupValue = attrib.readUInt8(3);
        const attrList = [];
        for (const key in constants.ATTRIBUTES_OPTIONS) {
            if (isNaN(Number(key))) {
                const value = constants.ATTRIBUTES_OPTIONS[key];
                if ((attrValue & value) !== 0) {
                    attrList.push(key);
                }
            }
        }
        const attributes = {
            OBJ_NOP: attrList.includes("OBJ_NOP"),
            CMB: attrList.includes("BCHAIN_KEY"),
            EXPORTABLE: attrList.includes("EXPORTABLE_KEY"),
            TEMPORARY: attrList.includes("TEMPORARY_KEY"),
            OATH: attrList.includes("OATH"),
            OATH_USE_TIME: attrList.includes("OATH_USE_TIME"),
            PKCS11: attrList.includes("PKCS11"),
            RSA_PUB_EXP3: attrList.includes("RSA_PUB_EXP3"),
            SPB: attrList.includes("SPB"),
            HSM_GEN: attrList.includes("HSM_GEN"),
            TSP: attrList.includes("TSP"),
        };
        const aup = Object.keys(constants.AUP_OPTIONS).find(key => constants.AUP_OPTIONS[key] === aupValue) || "Unknown AUP";
        return { attributes, aup };
    }
}
Management.MESSAGE_LENGTH_SIZE = 4;
exports.default = Management;
