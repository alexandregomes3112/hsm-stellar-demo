"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const hsm_base_module_1 = __importDefault(require("./hsm_base_module"));
const utils_1 = require("../../utils");
const constants = __importStar(require("../constants"));
const exceptions = __importStar(require("../exceptions"));
const enums = __importStar(require("../enums"));
const validators = __importStar(require("../validators"));
class User extends hsm_base_module_1.default {
    constructor(conn, user) {
        super(conn);
        this._user = user || "";
    }
    create(userId, password, permissions) {
        return new Promise((resolve, reject) => {
            validators.betweenValidate({
                min: constants.MIN_USR_LEN,
                max: constants.MAX_USR_LEN,
                data: userId,
                attribute: "userId",
                required: true,
                reject
            });
            validators.betweenValidate({
                min: constants.MIN_USR_PWD_LEN,
                max: constants.MAX_USR_PWD_LEN,
                data: password,
                attribute: "password",
                required: true,
                reject
            });
            const payloadLen = (constants.MAX_USR_LEN + 1) + (constants.MAX_USR_PWD_LEN + 1) + constants.SIZE_OF_UINT_32;
            const userBuff = utils_1.Aap.create(constants.MOD_CORE_CREATE_USR, payloadLen, payloadLen + constants.AAP_HDR_LEN);
            let offset = constants.AAP_HDR_LEN;
            userBuff.write(userId, offset);
            offset += constants.MAX_USR_LEN + 1;
            userBuff.write(password, offset);
            offset += constants.MAX_USR_PWD_LEN + 1;
            const userPermissions = this.permissionsConcat(permissions);
            userBuff.writeUInt32LE(userPermissions, offset);
            this.conn.once('data', (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on create user", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("User created successfully");
                resolve(true);
            });
            this.conn.once('error', (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(userBuff);
        });
    }
    remove(userId) {
        return new Promise((resolve, reject) => {
            validators.betweenValidate({
                min: constants.MIN_USR_LEN,
                max: constants.MAX_USR_LEN,
                data: userId,
                attribute: "userId",
                required: true,
                reject
            });
            const payloadLen = constants.MAX_USR_LEN + 1 + constants.SIZE_OF_UINT_8;
            const deleteUserBuff = utils_1.Aap.create(constants.MOD_CORE_DELETE_USR, payloadLen, payloadLen + constants.AAP_HDR_LEN);
            let offset = constants.AAP_HDR_LEN;
            deleteUserBuff.writeUInt8(constants.OP_DELETE_COMMIT, offset);
            offset += constants.SIZE_OF_UINT_8;
            deleteUserBuff.write(userId, offset);
            this.conn.once('data', (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on remove user", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("User removed successfully");
                resolve(true);
            });
            this.conn.once('error', (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(deleteUserBuff);
        });
    }
    block(userId) {
        return new Promise((resolve, reject) => {
            validators.betweenValidate({
                min: constants.MIN_USR_LEN,
                max: constants.MAX_USR_LEN,
                data: userId,
                attribute: "userId",
                required: true,
                reject
            });
            this.blockUnblock(userId, constants.MSBU_OP_BLOCK).then(resolve).catch(reject);
        });
    }
    unblock(userId) {
        return new Promise((resolve, reject) => {
            validators.betweenValidate({
                min: constants.MIN_USR_LEN,
                max: constants.MAX_USR_LEN,
                data: userId,
                attribute: "userId",
                required: true,
                reject
            });
            this.blockUnblock(userId, constants.MSBU_OP_UNBLOCK).then(resolve).catch(reject);
        });
    }
    blockUnblock(userId, action) {
        return new Promise((resolve, reject) => {
            const actionStr = constants.MSBU_OP_BLOCK === action ? "block" : "unblock";
            const payloadLen = constants.MAX_USR_LEN + 1 + constants.SIZE_OF_UINT_8;
            const userBuff = utils_1.Aap.create(constants.MOD_STAT_BLOCK_USR, payloadLen, payloadLen + constants.AAP_HDR_LEN);
            let offset = constants.AAP_HDR_LEN;
            userBuff.write(userId, offset);
            offset += constants.MAX_USR_LEN + 1;
            userBuff.writeUInt8(action, offset);
            this.conn.once('data', (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError(`Error on ${actionStr} user`, aapHdr.len));
                    return;
                }
                utils_1.Logger.info(`User ${actionStr}ed successfully`);
                resolve(true);
            });
            this.conn.once('error', (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(userBuff);
        });
    }
    changePassword(newPassword) {
        return new Promise((resolve, reject) => {
            validators.betweenValidate({
                min: constants.MIN_USR_PWD_LEN,
                max: constants.MAX_USR_PWD_LEN,
                data: newPassword,
                attribute: "newPassword",
                required: true,
                reject
            });
            const payloadLen = constants.MAX_USR_PWD_LEN;
            const changePwdBuff = utils_1.Aap.create(constants.MOD_CORE_CHANGE_PWD, payloadLen, payloadLen + constants.AAP_HDR_LEN);
            changePwdBuff.write(newPassword, constants.AAP_HDR_LEN);
            this.conn.once('data', (data) => {
                const aapHdr = utils_1.Aap.read(data);
                if (utils_1.Aap.hasError(aapHdr)) {
                    reject(new exceptions.HsmError("Error on change password", aapHdr.len));
                    return;
                }
                utils_1.Logger.info("Password changed successfully");
                resolve(true);
            });
            this.conn.once('error', (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(changePwdBuff);
        });
    }
    listTokens() {
        return this.managerToken("Tokens listed successfully", "Error on list tokens", constants.MC_A_TOKEN_OP_LIST);
    }
    revokeToken(token) {
        return new Promise((resolve, reject) => {
            validators.base64Validate({
                data: token,
                attribute: "token",
                required: true,
                message: "Invalid token.",
                reject
            });
            this.managerToken("Token revoked successfully", "Error on revoke token", constants.MC_A_TOKEN_OP_REVOKE, { token })
                .then(r => resolve(r))
                .catch(reject);
        });
    }
    generateToken(expiration) {
        return this.managerToken("Token generated successfully", "Error on generate token", constants.MC_A_TOKEN_OP_ISSUE, { expiration });
    }
    managerToken(successMsg, rejectMsg, operation, extra) {
        const { expiration, token } = extra || {};
        return new Promise((resolve, reject) => {
            const payloadLen = constants.SIZE_OF_UINT_8 + constants.A_TOKEN_KLEN + constants.SIZE_OF_UINT_64;
            const tokenBuff = utils_1.Aap.create(constants.MOD_CORE_A_TOKEN, payloadLen, payloadLen + constants.AAP_HDR_LEN);
            let offset = constants.AAP_HDR_LEN;
            tokenBuff.writeInt8(operation, offset);
            offset += constants.SIZE_OF_UINT_8;
            if (operation === constants.MC_A_TOKEN_OP_REVOKE && token) {
                const tokenKey = Buffer.from(token, 'base64').subarray(constants.MAX_USR_LEN);
                tokenBuff.fill(tokenKey, offset, offset + tokenKey.length);
            }
            offset += constants.A_TOKEN_KLEN;
            if (expiration) {
                tokenBuff.writeBigInt64LE(BigInt(expiration.getTime()), offset);
            }
            else {
                const init = BigInt.asUintN(64, BigInt(constants.MC_A_TOKEN_INFINITE));
                tokenBuff.writeBigUInt64LE(init, offset);
            }
            switch (operation) {
                case constants.MC_A_TOKEN_OP_ISSUE:
                case constants.MC_A_TOKEN_OP_L_ISSUE: {
                    this.conn.once('data', (data) => {
                        const aapHdr = utils_1.Aap.read(data);
                        if (utils_1.Aap.hasError(aapHdr)) {
                            reject(new exceptions.HsmError(rejectMsg, aapHdr.len));
                            return;
                        }
                        const token = this.parseToken(data.subarray(constants.AAP_HDR_LEN));
                        utils_1.Logger.info(successMsg);
                        resolve(token.token);
                    });
                    break;
                }
                case constants.MC_A_TOKEN_OP_LIST: {
                    const conn = this.conn;
                    const tokens = [];
                    const onToken = (data) => {
                        conn.once('data', onToken);
                        const aapHdr = utils_1.Aap.read(data);
                        if (aapHdr.len === constants.LAST_OBJ_LEN_MARKER) {
                            utils_1.Logger.info("Tokens listed successfully");
                            const tokensList = tokens.map((token) => this.parseToken(token).token);
                            // @ts-ignore
                            resolve(tokensList);
                            return;
                        }
                        if (utils_1.Aap.hasError(aapHdr)) {
                            reject(new exceptions.HsmError("Error on list tokens", aapHdr.len));
                            return;
                        }
                        tokens.push(data.subarray(constants.AAP_HDR_LEN));
                    };
                    this.conn.once('data', onToken);
                    break;
                }
                case constants.MC_A_TOKEN_OP_REVOKE: {
                    this.conn.once('data', (data) => {
                        const aapHdr = utils_1.Aap.read(data);
                        if (utils_1.Aap.hasError(aapHdr)) {
                            reject(new exceptions.HsmError(rejectMsg, aapHdr.len));
                            return;
                        }
                        utils_1.Logger.info(successMsg);
                        // @ts-ignore
                        resolve(true);
                    });
                    break;
                }
            }
            this.conn.once('error', (err) => {
                reject(new exceptions.HsmError(err.message));
            });
            this.conn.write(tokenBuff);
        });
    }
    parseToken(data) {
        const tokenObj = {
            token: '',
            expiration: null
        };
        const tokenBuff = Buffer.alloc(constants.MAX_USR_LEN + constants.A_TOKEN_KLEN);
        tokenBuff.write(this._user);
        const key = data.subarray(0, constants.MAX_USR_LEN);
        tokenBuff.fill(key, 16, 16 + key.length);
        // TODO: Check time measurement
        // const startDate = new Date(1970, 1, 1, 0, 0, 0, 0);
        // const expirationSeconds = data.readBigUInt64LE(constants.MAX_USR_LEN);
        // startDate.setSeconds(Number(expirationSeconds));
        tokenObj.token = tokenBuff.toString('base64');
        // tokenObj.expiration = startDate;
        return tokenObj;
    }
    permissionsConcat(permissions) {
        if (!Array.isArray(permissions) || permissions.length === 0) {
            return enums.USER_PERMISSIONS.NOP;
        }
        return permissions.reduce((acc, curr) => acc | curr, 0);
    }
}
exports.default = User;
