"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TFA_TYPE = exports.SVMK_VERSION = exports.ACL_MASK = exports.NSAUTH_STATE = exports.NH_RESPONSE_STATUS = exports.MOD_OATH_OTP = exports.OCRA_MODE_LEN = exports.OCRA_MODE = exports.OCRA_PIN_HASH_TYPE = exports.RSA_LENGTH_KEYS = exports.ENC_DEC_PADDING = exports.KEK_MODE = exports.KEK_WRAP_OBJ_TYPE = exports.KEK_WRAP_MODE = exports.KEK_WRAP_PADDING = exports.PKCS10_HASH_ALGORITHM = exports.KEY_EXPORT_FORMAT = exports.USER_PERMISSIONS = exports.PAD_TYPE = exports.BLOCKCHAIN_EXPORT_VERSION = exports.IMPORT_EXPORT_FORMAT = exports.BLOCKCHAIN_PUB_SIG_REC_TYPE = exports.BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE = exports.BLOCKCHAIN_GET_PUB_KEY_TYPE = exports.ADDRESS_HRP = exports.ADDRESS_VERSION = exports.ADDRESS_TYPE = exports.BLOCKCHAIN_SIG_TYPE = exports.BLOCKCHAIN_PUB_KEY_TYPE = exports.BLOCKCHAIN_EdDSA_TYPE = exports.BLOCKCHAIN_HASH_MODE = exports.BCHAIN_SECURE_BIP32_INDEX = exports.VERSION_OPTIONS = exports.ATTRIBUTES_OPTIONS = exports.BLOCKCHAIN_KEYS = exports.GET_TOKEN_DATA_OPTIONS = exports.STR_FORMAT_PRESERVING_ENCRYPTION_OPTIONS = exports.CHECK_SUM_OPTIONS = exports.MASK_TYPE = exports.HASH_LEN = exports.HASH_ALGORITHMS = exports.ECC_ASYMMETRIC_PBC_SWITCHES = exports.HMAC_KEYS = exports.ECX_ASYMMETRIC_SWITCHES = exports.ECC_ASYMMETRIC_SWITCHES = exports.RSA_ASYMMETRIC_KEYS = exports.SYMMETRICAL_KEYS = exports.AAP_HSM_RETURNS = exports.MESSAGE_TYPES = void 0;
/**
 * @internal
 * Tipos de mensagens de log
 * @property {string} INFO Informação
 * @property {string} ERROR Erro
 * @property {string} WARN Aviso
 */
var MESSAGE_TYPES;
(function (MESSAGE_TYPES) {
    MESSAGE_TYPES["INFO"] = "info";
    MESSAGE_TYPES["ERROR"] = "error";
    MESSAGE_TYPES["WARN"] = "warn";
})(MESSAGE_TYPES || (exports.MESSAGE_TYPES = MESSAGE_TYPES = {}));
/**
 * @internal
 * Tipos de mensagens de retorno do HSM
 * @property {string} HELO Handshake TCP efetuado com sucesso
 */
exports.AAP_HSM_RETURNS = {
    HELO: "HELO",
};
/**
 * Chaves Simétricas
 * @property {number} ALG_DES DES de 56 bits e com paridade impar.
 * @property {number} ALG_3DES_112 3DES-EDE (Encrypt-Decrypt-Encrypt) de 112 bits e com paridade impar.
 * @property {number} ALG_3DES_168 3DES-EDE (Encrypt-Decrypt-Encrypt) de 168 bits e com paridade impar.
 * @property {number} ALG_DESX DESX de 192 bits. O tamanho efetivo é de 118 bits.
 * @property {number} ALG_ARC4 ARC4 com 128 bits.
 * @property {number} ALG_ARC5 ARC5 com 128 bits, bloco de 8 bytes e utilizando 16 rounds.
 * @property {number} ALG_AES_128 AES com 128 bits.
 * @property {number} ALG_AES_192 AES com 192 bits.
 * @property {number} ALG_AES_256 AES com 256 bits.
 */
var SYMMETRICAL_KEYS;
(function (SYMMETRICAL_KEYS) {
    SYMMETRICAL_KEYS[SYMMETRICAL_KEYS["ALG_DES"] = 1] = "ALG_DES";
    SYMMETRICAL_KEYS[SYMMETRICAL_KEYS["ALG_3DES_112"] = 2] = "ALG_3DES_112";
    SYMMETRICAL_KEYS[SYMMETRICAL_KEYS["ALG_3DES_168"] = 3] = "ALG_3DES_168";
    SYMMETRICAL_KEYS[SYMMETRICAL_KEYS["ALG_DESX"] = 91] = "ALG_DESX";
    SYMMETRICAL_KEYS[SYMMETRICAL_KEYS["ALG_ARC4"] = 10] = "ALG_ARC4";
    SYMMETRICAL_KEYS[SYMMETRICAL_KEYS["ALG_ARC5"] = 89] = "ALG_ARC5";
    SYMMETRICAL_KEYS[SYMMETRICAL_KEYS["ALG_AES_128"] = 7] = "ALG_AES_128";
    SYMMETRICAL_KEYS[SYMMETRICAL_KEYS["ALG_AES_192"] = 8] = "ALG_AES_192";
    SYMMETRICAL_KEYS[SYMMETRICAL_KEYS["ALG_AES_256"] = 9] = "ALG_AES_256";
})(SYMMETRICAL_KEYS || (exports.SYMMETRICAL_KEYS = SYMMETRICAL_KEYS = {}));
/**
 * Chaves Assimétricas RSA
 * @property {number} ALG_RSA_512 Par de chaves RSA com módulo de 512 bits.
 * @property {number} ALG_RSA_1024 Par de chaves RSA com módulo de 1024 bits.
 * @property {number} ALG_RSA_2048 Par de chaves RSA com módulo de 2048 bits.
 * @property {number} ALG_RSA_4096 Par de chaves RSA com módulo de 4096 bits.
 * @property {number} ALG_RSA_1152 Par de chaves RSA com módulo de 1152 bits.
 * @property {number} ALG_RSA_1408 Par de chaves RSA com módulo de 1408 bits.
 * @property {number} ALG_RSA_1536 Par de chaves RSA com módulo de 1536 bits.
 * @property {number} ALG_RSA_1976 Par de chaves RSA com módulo de 1976 bits.
 * @property {number} ALG_RSA_1984 Par de chaves RSA com módulo de 1984 bits.
 * @property {number} ALG_RSA_8192 Par de chaves RSA com módulo de 8192 bits.
 * @property {number} ALG_RSA_2304 Par de chaves RSA com módulo de 2304 bits.
 * @property {number} ALG_RSA_2560 Par de chaves RSA com módulo de 2560 bits.
 * @property {number} ALG_RSA_2816 Par de chaves RSA com módulo de 2816 bits.
 * @property {number} ALG_RSA_3072 Par de chaves RSA com módulo de 3072 bits.
 */
var RSA_ASYMMETRIC_KEYS;
(function (RSA_ASYMMETRIC_KEYS) {
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_512"] = 4] = "ALG_RSA_512";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_1024"] = 5] = "ALG_RSA_1024";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_2048"] = 6] = "ALG_RSA_2048";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_4096"] = 11] = "ALG_RSA_4096";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_1152"] = 121] = "ALG_RSA_1152";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_1408"] = 122] = "ALG_RSA_1408";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_1536"] = 131] = "ALG_RSA_1536";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_1976"] = 130] = "ALG_RSA_1976";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_1984"] = 123] = "ALG_RSA_1984";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_8192"] = 124] = "ALG_RSA_8192";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_2304"] = 126] = "ALG_RSA_2304";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_2560"] = 127] = "ALG_RSA_2560";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_2816"] = 128] = "ALG_RSA_2816";
    RSA_ASYMMETRIC_KEYS[RSA_ASYMMETRIC_KEYS["ALG_RSA_3072"] = 129] = "ALG_RSA_3072";
})(RSA_ASYMMETRIC_KEYS || (exports.RSA_ASYMMETRIC_KEYS = RSA_ASYMMETRIC_KEYS = {}));
/**
 * Chaves Assimétricas ECC
 * @property {number} ALG_ECC_SECP112R1 curva SECG/WTLS sobre um corpo finito primo de 112 bits (verifiably random elliptic curve domain parameters).
 * @property {number} ALG_ECC_SECP112R2 curva SECG sobre um corpo finito primo de 112 bits (verifiably random elliptic curve domain parameters 2).
 * @property {number} ALG_ECC_SECP128R1 curva SECG sobre um corpo finito primo de 128 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP128R2 curva SECG sobre um corpo finito primo de 128 bits (verifiably random elliptic curve domain parameters 2).
 * @property {number} ALG_ECC_SECP160K1 curva SECG sobre um corpo finito primo de 160 bits (koblitz domain parameters ).
 * @property {number} ALG_ECC_SECP160R1 curva SECG sobre um corpo finito primo de 160 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP160R2 curva SECG/WTLS sobre um corpo finito primo de 160 bits (verifiably random elliptic curve domain parameters 2).
 * @property {number} ALG_ECC_SECP192K1 curva SECG sobre um corpo finito primo de 192 bits (koblitz domain parameters ).
 * @property {number} ALG_ECC_SECP192R1 curva SECG/X9.62/NIST sobre um corpo finito primo de 192 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP224K1 curva SECG sobre um corpo finito primo de 224 bits (koblitz domain parameters ).
 * @property {number} ALG_ECC_SECP224R1 curva SECG/NIST sobre um corpo finito primo de 224 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP256K1 curva SECG sobre um corpo finito primo de 256 bits (koblitz domain parameters ).
 * @property {number} ALG_ECC_SECP256R1 curva SECG/X9.62 sobre um corpo finito primo de 256 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP384R1 curva SECG/NIST sobre um corpo finito primo de 384 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP521R1 curva SECG/NIST sobre um corpo finito primo de 521 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_X9_62_PRIME192V1 curva X9.62 sobre um corpo finito primo de 192 bits (version 1 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME192V2 curva X9.62 sobre um corpo finito primo de 192 bits (version 2 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME192V3 curva X9.62 sobre um corpo finito primo de 192 bits (version 3 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME239V1 curva X9.62 sobre um corpo finito primo de 239 bits (version 1 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME239V2 curva X9.62 sobre um corpo finito primo de 239 bits (version 2 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME239V3 curva X9.62 sobre um corpo finito primo de 239 bits (version 3 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME256V1 curva X9.62 sobre um corpo finito primo de 256 bits (version 1 domain parameters).
 * @property {number} ALG_ECC_BRAINPOOL_P160R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 160 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P160T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 160 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P192R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 192 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P192T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 192 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P224R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 224 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P224T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 224 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P256R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 256 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P256T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 256 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P320R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 320 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P320T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 320 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P384R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 384 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P384T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 384 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P512R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 512 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P512T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 512 bits (twisted domain parameters 1)
 */
var ECC_ASYMMETRIC_SWITCHES;
(function (ECC_ASYMMETRIC_SWITCHES) {
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP112R1"] = 18] = "ALG_ECC_SECP112R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP112R2"] = 19] = "ALG_ECC_SECP112R2";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP128R1"] = 20] = "ALG_ECC_SECP128R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP128R2"] = 21] = "ALG_ECC_SECP128R2";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP160K1"] = 22] = "ALG_ECC_SECP160K1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP160R1"] = 23] = "ALG_ECC_SECP160R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP160R2"] = 24] = "ALG_ECC_SECP160R2";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP192K1"] = 25] = "ALG_ECC_SECP192K1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP192R1"] = 26] = "ALG_ECC_SECP192R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP224K1"] = 27] = "ALG_ECC_SECP224K1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP224R1"] = 28] = "ALG_ECC_SECP224R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP256K1"] = 29] = "ALG_ECC_SECP256K1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP256R1"] = 30] = "ALG_ECC_SECP256R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP384R1"] = 31] = "ALG_ECC_SECP384R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_SECP521R1"] = 32] = "ALG_ECC_SECP521R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_X9_62_PRIME192V1"] = 26] = "ALG_ECC_X9_62_PRIME192V1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_X9_62_PRIME192V2"] = 33] = "ALG_ECC_X9_62_PRIME192V2";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_X9_62_PRIME192V3"] = 34] = "ALG_ECC_X9_62_PRIME192V3";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_X9_62_PRIME239V1"] = 35] = "ALG_ECC_X9_62_PRIME239V1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_X9_62_PRIME239V2"] = 36] = "ALG_ECC_X9_62_PRIME239V2";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_X9_62_PRIME239V3"] = 37] = "ALG_ECC_X9_62_PRIME239V3";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_X9_62_PRIME256V1"] = 30] = "ALG_ECC_X9_62_PRIME256V1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P160R1"] = 38] = "ALG_ECC_BRAINPOOL_P160R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P160T1"] = 39] = "ALG_ECC_BRAINPOOL_P160T1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P192R1"] = 40] = "ALG_ECC_BRAINPOOL_P192R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P192T1"] = 41] = "ALG_ECC_BRAINPOOL_P192T1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P224R1"] = 42] = "ALG_ECC_BRAINPOOL_P224R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P224T1"] = 43] = "ALG_ECC_BRAINPOOL_P224T1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P256R1"] = 44] = "ALG_ECC_BRAINPOOL_P256R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P256T1"] = 45] = "ALG_ECC_BRAINPOOL_P256T1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P320R1"] = 46] = "ALG_ECC_BRAINPOOL_P320R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P320T1"] = 47] = "ALG_ECC_BRAINPOOL_P320T1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P384R1"] = 48] = "ALG_ECC_BRAINPOOL_P384R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P384T1"] = 49] = "ALG_ECC_BRAINPOOL_P384T1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P512R1"] = 50] = "ALG_ECC_BRAINPOOL_P512R1";
    ECC_ASYMMETRIC_SWITCHES[ECC_ASYMMETRIC_SWITCHES["ALG_ECC_BRAINPOOL_P512T1"] = 51] = "ALG_ECC_BRAINPOOL_P512T1";
})(ECC_ASYMMETRIC_SWITCHES || (exports.ECC_ASYMMETRIC_SWITCHES = ECC_ASYMMETRIC_SWITCHES = {}));
/**
 * Chaves Assimétricas ECX
 * @property {number} ALG_ECX_ED25519 curva RFC 8032(apenas assinatura) sobre um corpo finito primo de ~256 bits.
 * @property {number} ALG_ECX_ED448 curva RFC 8032(apenas assinatura) sobre um corpo finito primo de ~448 bits.
 * @property {number} ALG_ECX_X25519 curva RFC 7748(apenas key-agreement) sobre um corpo finito primo de ~256 bits.
 * @property {number} ALG_ECX_X448 curva RFC 7748(apenas key-agreement) sobre um corpo finito primo de ~448 bits.
 */
var ECX_ASYMMETRIC_SWITCHES;
(function (ECX_ASYMMETRIC_SWITCHES) {
    ECX_ASYMMETRIC_SWITCHES[ECX_ASYMMETRIC_SWITCHES["ALG_ECX_ED25519"] = 201] = "ALG_ECX_ED25519";
    ECX_ASYMMETRIC_SWITCHES[ECX_ASYMMETRIC_SWITCHES["ALG_ECX_ED448"] = 202] = "ALG_ECX_ED448";
    ECX_ASYMMETRIC_SWITCHES[ECX_ASYMMETRIC_SWITCHES["ALG_ECX_X25519"] = 203] = "ALG_ECX_X25519";
    ECX_ASYMMETRIC_SWITCHES[ECX_ASYMMETRIC_SWITCHES["ALG_ECX_X448"] = 204] = "ALG_ECX_X448";
})(ECX_ASYMMETRIC_SWITCHES || (exports.ECX_ASYMMETRIC_SWITCHES = ECX_ASYMMETRIC_SWITCHES = {}));
/**
 * Chaves HMAC
 * @property {number} ALG_HMAC_MD5 Chave HMAC MD5 com tamanho de 16 bytes.
 * @property {number} ALG_HMAC_SHA1 Chave HMAC SHA1 com tamanho de 20 bytes.
 * @property {number} ALG_HMAC_SHA2_256 Chave HMAC SHA2 256 com tamanho de 32 bytes.
 * @property {number} ALG_HMAC_SHA2_384 Chave HMAC SHA2 384 com tamanho de 48 bytes.
 * @property {number} ALG_HMAC_SHA2_512 Chave HMAC SHA2 512 com tamanho de 64 bytes.
 */
var HMAC_KEYS;
(function (HMAC_KEYS) {
    HMAC_KEYS[HMAC_KEYS["ALG_HMAC_MD5"] = 92] = "ALG_HMAC_MD5";
    HMAC_KEYS[HMAC_KEYS["ALG_HMAC_SHA1"] = 93] = "ALG_HMAC_SHA1";
    HMAC_KEYS[HMAC_KEYS["ALG_HMAC_SHA2_256"] = 94] = "ALG_HMAC_SHA2_256";
    HMAC_KEYS[HMAC_KEYS["ALG_HMAC_SHA2_384"] = 95] = "ALG_HMAC_SHA2_384";
    HMAC_KEYS[HMAC_KEYS["ALG_HMAC_SHA2_512"] = 96] = "ALG_HMAC_SHA2_512";
})(HMAC_KEYS || (exports.HMAC_KEYS = HMAC_KEYS = {}));
/**
 * Chaves PBC (Pairing-Based Cryptography)
 * @property {number} ALT_BN128 Curva ALT BN128.
 */
var ECC_ASYMMETRIC_PBC_SWITCHES;
(function (ECC_ASYMMETRIC_PBC_SWITCHES) {
    ECC_ASYMMETRIC_PBC_SWITCHES[ECC_ASYMMETRIC_PBC_SWITCHES["ALT_BN128"] = 2771] = "ALT_BN128";
})(ECC_ASYMMETRIC_PBC_SWITCHES || (exports.ECC_ASYMMETRIC_PBC_SWITCHES = ECC_ASYMMETRIC_PBC_SWITCHES = {}));
/**
 * Define o algoritmo associado ao contexto de hash.
 * Hash algorithms supported by create hash
 * @property {number} ALG_MD5 Algoritmo de hash MD5. *keyName* deve ser NULL.
 * @property {number} ALG_SHA1 Algoritmo de hash SHA1. *keyName* deve ser NULL.
 * @property {number} ALG_SSL_SHA1_MD5 Hash para autenticação de cliente em SSLv3. *keyName* deve ser NULL.
 * @property {number} ALG_SHA2_224 Algoritmo de hash SHA2 - 224. *keyName* deve ser NULL.
 * @property {number} ALG_SHA2_256 Algoritmo de hash SHA2 - 256. *keyName* deve ser NULL.
 * @property {number} ALG_SHA2_384 Algoritmo de hash SHA2 - 384. *keyName* deve ser NULL.
 * @property {number} ALG_SHA2_512 Algoritmo de hash SHA2 - 512. *keyName* deve ser NULL.
 * @property {number} ALG_SHA3_224 Algoritmo de hash SHA3 - 224. *keyName* deve ser NULL.
 * @property {number} ALG_SHA3_256 Algoritmo de hash SHA3 - 256. *keyName* deve ser NULL.
 * @property {number} ALG_SHA3_384 Algoritmo de hash SHA3 - 384. *keyName* deve ser NULL.
 * @property {number} ALG_SHA3_512 Algoritmo de hash SHA3 - 512. *keyName* deve ser NULL.
 * @property {number} ALG_HMAC_MD5 Algoritmo HMAC MD5. *keyName* deve ser o contexto para a chave utilizada no HMAC.
 * @property {number} ALG_HMAC_SHA1 Algoritmo HMAC SHA1. *keyName* deve ser o contexto para a chave utilizada no HMAC.
 * @property {number} ALG_HMAC_SHA2_256 Algoritmo HMAC SHA2 - 256. *keyName* deve ser o contexto para a chave utilizada no HMAC.
 * @property {number} ALG_HMAC_SHA2_384 Algoritmo HMAC SHA2 - 384. *keyName* deve ser o contexto para a chave utilizada no HMAC.
 * @property {number} ALG_HMAC_SHA2_512 Algoritmo HMAC SHA2 - 512. *keyName* deve ser o contexto para a chave utilizada no HMAC.
 * @property {number} ALG_CMAC_DES Algoritmo CMAC 3DES. *keyName* deve ser o contexto para a chave 3DES utilizada no CMAC.
 * @property {number} ALG_CMAC_AES Algoritmo CMAC AES. *keyName* deve ser o contexto para a chave AES utilizada no CMAC.
 * @property {number} ALG_IDENTITY_FUNC Função identidade. Os dados de entrada são iguais aos dados de saída. *keyName* NULL.
 */
var HASH_ALGORITHMS;
(function (HASH_ALGORITHMS) {
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_MD5"] = 1] = "ALG_MD5";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_SHA1"] = 2] = "ALG_SHA1";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_SSL_SHA1_MD5"] = 3] = "ALG_SSL_SHA1_MD5";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_SHA2_224"] = 7] = "ALG_SHA2_224";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_SHA2_256"] = 4] = "ALG_SHA2_256";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_SHA2_384"] = 5] = "ALG_SHA2_384";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_SHA2_512"] = 6] = "ALG_SHA2_512";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_SHA3_224"] = 8] = "ALG_SHA3_224";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_SHA3_256"] = 9] = "ALG_SHA3_256";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_SHA3_384"] = 10] = "ALG_SHA3_384";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_SHA3_512"] = 11] = "ALG_SHA3_512";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_HMAC_MD5"] = 92] = "ALG_HMAC_MD5";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_HMAC_SHA1"] = 93] = "ALG_HMAC_SHA1";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_HMAC_SHA2_256"] = 94] = "ALG_HMAC_SHA2_256";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_HMAC_SHA2_384"] = 95] = "ALG_HMAC_SHA2_384";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_HMAC_SHA2_512"] = 96] = "ALG_HMAC_SHA2_512";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_CMAC_DES"] = 251] = "ALG_CMAC_DES";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_CMAC_AES"] = 250] = "ALG_CMAC_AES";
    HASH_ALGORITHMS[HASH_ALGORITHMS["ALG_IDENTITY_FUNC"] = 255] = "ALG_IDENTITY_FUNC";
})(HASH_ALGORITHMS || (exports.HASH_ALGORITHMS = HASH_ALGORITHMS = {}));
/**
 * Tamanho de hashs gerados
 * @property {number} MAX_HASH_LEN tamanho máximo para um hash gerado por função de hash
 */
var HASH_LEN;
(function (HASH_LEN) {
    HASH_LEN[HASH_LEN["MAX_HASH_LEN"] = 64] = "MAX_HASH_LEN";
})(HASH_LEN || (exports.HASH_LEN = HASH_LEN = {}));
/**
 * Tipos de máscaras para a geração de tokens.
 * @property {number} NONE Não utiliza máscaras para geração do token ou recuperação do secret.
 * @property {number} TOKEN Utiliza máscaras para geração do token.
 * @property {number} SECRET Utiliza máscaras para geração do secret.
 */
var MASK_TYPE;
(function (MASK_TYPE) {
    MASK_TYPE[MASK_TYPE["NONE"] = 0] = "NONE";
    MASK_TYPE[MASK_TYPE["TOKEN"] = 1] = "TOKEN";
    MASK_TYPE[MASK_TYPE["SECRET"] = 2] = "SECRET";
})(MASK_TYPE || (exports.MASK_TYPE = MASK_TYPE = {}));
/**
 * Tipos de checksum para a geração de tokens.
 * @property {number} NULL Não faz geração de checksum. Apenas gera o token.
 * @property {number} CPF Gera os 2 dígitos verificadores no padrão CPF (Cadastro de Pessoas Físicas) no token. O secret deverá conter apenas números e incluir os dígitos verificadores.
 * @property {number} CNPJ Gera os 2 dígitos verificadores no padrão CNPJ (Cadastro Nacional da Pessoa Jurídica) no token. O secret deverá conter apenas números e incluir os dígitos verificadores.
 * @property {number} PAN Gera um PAN (Primary Account Number) com o dígito verificador válido no token. O secret deverá ser completo e conter apenas números.
 * @property {number} IEL Gera os 2 dígitos verificadores no padrão do número do título de eleitor no token. O secret deverá conter apenas números e incluir os dígitos verificadores.
 */
var CHECK_SUM_OPTIONS;
(function (CHECK_SUM_OPTIONS) {
    CHECK_SUM_OPTIONS[CHECK_SUM_OPTIONS["NULL"] = 0] = "NULL";
    CHECK_SUM_OPTIONS[CHECK_SUM_OPTIONS["CPF"] = 1] = "CPF";
    CHECK_SUM_OPTIONS[CHECK_SUM_OPTIONS["CNPJ"] = 2] = "CNPJ";
    CHECK_SUM_OPTIONS[CHECK_SUM_OPTIONS["PAN"] = 3] = "PAN";
    CHECK_SUM_OPTIONS[CHECK_SUM_OPTIONS["IEL"] = 4] = "IEL";
})(CHECK_SUM_OPTIONS || (exports.CHECK_SUM_OPTIONS = CHECK_SUM_OPTIONS = {}));
/**
 * Define a base de representação da string UTF-8 do secret para o FPE (Format-Preserving-Encryption). Pode ser uma das opções da tabela abaixo.
 * @property {number} BASE10 Apenas decimais.
 * @property {number} BASE62 Caracteres que são letras A-Z, a-z ou os números 0–9.
 */
var STR_FORMAT_PRESERVING_ENCRYPTION_OPTIONS;
(function (STR_FORMAT_PRESERVING_ENCRYPTION_OPTIONS) {
    STR_FORMAT_PRESERVING_ENCRYPTION_OPTIONS[STR_FORMAT_PRESERVING_ENCRYPTION_OPTIONS["BASE10"] = 10] = "BASE10";
    STR_FORMAT_PRESERVING_ENCRYPTION_OPTIONS[STR_FORMAT_PRESERVING_ENCRYPTION_OPTIONS["BASE62"] = 62] = "BASE62";
})(STR_FORMAT_PRESERVING_ENCRYPTION_OPTIONS || (exports.STR_FORMAT_PRESERVING_ENCRYPTION_OPTIONS = STR_FORMAT_PRESERVING_ENCRYPTION_OPTIONS = {}));
/**
 * Tipos de operações para obtenção de dados do token.
 * @property {number} SECRET Recupera o secret.
 * @property {number} TOKEN Recupera o token.
 */
var GET_TOKEN_DATA_OPTIONS;
(function (GET_TOKEN_DATA_OPTIONS) {
    GET_TOKEN_DATA_OPTIONS[GET_TOKEN_DATA_OPTIONS["SECRET"] = 1] = "SECRET";
    GET_TOKEN_DATA_OPTIONS[GET_TOKEN_DATA_OPTIONS["TOKEN"] = 2] = "TOKEN";
})(GET_TOKEN_DATA_OPTIONS || (exports.GET_TOKEN_DATA_OPTIONS = GET_TOKEN_DATA_OPTIONS = {}));
/**
 * Tipos de geração da chave.
 * @property {number} BITCOIN_MINI_KEY Bitcoin minikey. Data deve ser NULL. Version deve ser NULL.
 * @property {number} BIP32_SEED_XPRV BIP32 seed XPrv. Data deve conter a estrutura DN_BCHAIN_BIP32_SEED_XPRV_DATA preenchida. Version deve ser NULL.
 * @property {number} BIP39_SEED_XPRV BIP39 seed XPrv. Data deve conter a estrutura DN_BCHAIN_BIP39_SEED_XPRV_DATA preenchida. Version deve ser NULL.
 * @property {number} BIP32_XPRV BIP32 XPrv. Data deve ser NULL. Version deve ser uma das opções de versão da chave.
 * @property {number} BIP32_ED25519_XPRV BIP32 Ed25519 XPrv. Data deve ser NULL. Version deve ser uma das opções de versão da chave.
 */
var BLOCKCHAIN_KEYS;
(function (BLOCKCHAIN_KEYS) {
    BLOCKCHAIN_KEYS[BLOCKCHAIN_KEYS["BITCOIN_MINI_KEY"] = 1] = "BITCOIN_MINI_KEY";
    BLOCKCHAIN_KEYS[BLOCKCHAIN_KEYS["BIP32_SEED_XPRV"] = 2] = "BIP32_SEED_XPRV";
    BLOCKCHAIN_KEYS[BLOCKCHAIN_KEYS["BIP39_SEED_XPRV"] = 3] = "BIP39_SEED_XPRV";
    BLOCKCHAIN_KEYS[BLOCKCHAIN_KEYS["BIP32_XPRV"] = 4] = "BIP32_XPRV";
    BLOCKCHAIN_KEYS[BLOCKCHAIN_KEYS["BIP32_ED25519_XPRV"] = 5] = "BIP32_ED25519_XPRV";
})(BLOCKCHAIN_KEYS || (exports.BLOCKCHAIN_KEYS = BLOCKCHAIN_KEYS = {}));
/**
 * Objects Attributes.
 * @property {number} EXPORTABLE_KEY Exportable key.
 * @property {number} TEMPORARY_KEY Temporary key.
 * @property {number} BCHAIN_KEY BChain keys: PBKs are handled specially.
 * @property {number} TSP TSP keys: don't replicate, export, backup.
 * @property {number} OATH HOTP stuff, without ST's, with open secret.
 * @property {number} OATH_USE_TIME HOTP stuff, time-based
 * @property {number} PKCS11 PKCS#11 related information.
 * @property {number} RSA_PUB_EXP3 Fallback to problematic RSA small exponent.
 * @property {number} SPB Object related to SPB module.
 * @property {number} HSM_GEN set on HSM generated keys.
 */
var ATTRIBUTES_OPTIONS;
(function (ATTRIBUTES_OPTIONS) {
    ATTRIBUTES_OPTIONS[ATTRIBUTES_OPTIONS["OBJ_NOP"] = 0] = "OBJ_NOP";
    ATTRIBUTES_OPTIONS[ATTRIBUTES_OPTIONS["BCHAIN_KEY"] = 16384] = "BCHAIN_KEY";
    ATTRIBUTES_OPTIONS[ATTRIBUTES_OPTIONS["EXPORTABLE_KEY"] = 1] = "EXPORTABLE_KEY";
    ATTRIBUTES_OPTIONS[ATTRIBUTES_OPTIONS["TEMPORARY_KEY"] = 4] = "TEMPORARY_KEY";
    ATTRIBUTES_OPTIONS[ATTRIBUTES_OPTIONS["OATH"] = 16] = "OATH";
    ATTRIBUTES_OPTIONS[ATTRIBUTES_OPTIONS["OATH_USE_TIME"] = 128] = "OATH_USE_TIME";
    ATTRIBUTES_OPTIONS[ATTRIBUTES_OPTIONS["PKCS11"] = 1024] = "PKCS11";
    ATTRIBUTES_OPTIONS[ATTRIBUTES_OPTIONS["RSA_PUB_EXP3"] = 2048] = "RSA_PUB_EXP3";
    ATTRIBUTES_OPTIONS[ATTRIBUTES_OPTIONS["SPB"] = 4096] = "SPB";
    ATTRIBUTES_OPTIONS[ATTRIBUTES_OPTIONS["HSM_GEN"] = 32768] = "HSM_GEN";
    ATTRIBUTES_OPTIONS[ATTRIBUTES_OPTIONS["TSP"] = 8192] = "TSP";
})(ATTRIBUTES_OPTIONS || (exports.ATTRIBUTES_OPTIONS = ATTRIBUTES_OPTIONS = {}));
/**
 * Opções de versão para a chave XPrv.
 * @property {number} BIP32_MAIN_NET Mainnet BIP32.
 * @property {number} BIP32_TEST_NET Testnet BIP32.
 * @property {number} BIP32_HTR_MAIN_NET Mainnet BIP32 Hathor.
 * @property {number} BIP32_HTR_TEST_NET Testnet BIP32 Hathor.
 * @property {number} BIP32_FPRV1 FPRV1.
 */
var VERSION_OPTIONS;
(function (VERSION_OPTIONS) {
    VERSION_OPTIONS[VERSION_OPTIONS["BIP32_MAIN_NET"] = 128] = "BIP32_MAIN_NET";
    VERSION_OPTIONS[VERSION_OPTIONS["BIP32_TEST_NET"] = 239] = "BIP32_TEST_NET";
    VERSION_OPTIONS[VERSION_OPTIONS["BIP32_HTR_MAIN_NET"] = 1] = "BIP32_HTR_MAIN_NET";
    VERSION_OPTIONS[VERSION_OPTIONS["BIP32_HTR_TEST_NET"] = 2] = "BIP32_HTR_TEST_NET";
    VERSION_OPTIONS[VERSION_OPTIONS["BIP32_FPRV1"] = 3] = "BIP32_FPRV1";
})(VERSION_OPTIONS || (exports.VERSION_OPTIONS = VERSION_OPTIONS = {}));
/**
 * Índice da chave que será derivada. Chaves non hardened usam índice de 0 a 231-1 e chaves hardened (irrestritamente seguras) usam índices de 231 a 232-1, como especificado no padrão BIP32. É altamente recomendado gerar chaves hardened.
 * @property {number} BASE Base para gerar índices hardened.
 */
var BCHAIN_SECURE_BIP32_INDEX;
(function (BCHAIN_SECURE_BIP32_INDEX) {
    BCHAIN_SECURE_BIP32_INDEX[BCHAIN_SECURE_BIP32_INDEX["BASE"] = 2147483648] = "BASE";
})(BCHAIN_SECURE_BIP32_INDEX || (exports.BCHAIN_SECURE_BIP32_INDEX = BCHAIN_SECURE_BIP32_INDEX = {}));
/**
 * Tipo do hash para geração da hash de dados.
 * @property {number} BTC_H160 Bitcoin H160.
 * @property {number} RIPEMD160 RIPEMD160.
 * @property {number} SHA256 SHA256
 * @property {number} BTC_SHA256_2X Bitcoin SHA256 2x.
 * @property {number} KECCAK256 KECCAK256.
 * @property {number} BLAKE2B224 BLAKE2B224.
 * @property {number} BLAKE2B256 BLAKE2B256.
 */
var BLOCKCHAIN_HASH_MODE;
(function (BLOCKCHAIN_HASH_MODE) {
    BLOCKCHAIN_HASH_MODE[BLOCKCHAIN_HASH_MODE["BTC_H160"] = 1] = "BTC_H160";
    BLOCKCHAIN_HASH_MODE[BLOCKCHAIN_HASH_MODE["RIPEMD160"] = 2] = "RIPEMD160";
    BLOCKCHAIN_HASH_MODE[BLOCKCHAIN_HASH_MODE["SHA256"] = 3] = "SHA256";
    BLOCKCHAIN_HASH_MODE[BLOCKCHAIN_HASH_MODE["BTC_SHA256_2X"] = 4] = "BTC_SHA256_2X";
    BLOCKCHAIN_HASH_MODE[BLOCKCHAIN_HASH_MODE["KECCAK256"] = 5] = "KECCAK256";
    BLOCKCHAIN_HASH_MODE[BLOCKCHAIN_HASH_MODE["BLAKE2B224"] = 6] = "BLAKE2B224";
    BLOCKCHAIN_HASH_MODE[BLOCKCHAIN_HASH_MODE["BLAKE2B256"] = 7] = "BLAKE2B256";
})(BLOCKCHAIN_HASH_MODE || (exports.BLOCKCHAIN_HASH_MODE = BLOCKCHAIN_HASH_MODE = {}));
/**
 * Tipo da assinatura a ser gerada.
 * @property {number} SIG_PURE Assinatura EdDSA Pure.
 * @property {number} SIG_ALGORAND Assinatura EdDSA Algorand.
 * @property {number} SIG_XRP Assinatura EdDSA XRP.
 * @property {number} SIG_SOL Assinatura EdDSA Solana.
 * @property {number} EdDSA_SIG_XLM Assinatura EdDSA Stellar.
 * @property {number} EdDSA_SIG_ADA Assinatura EdDSA Cardano.
 * @property {number} EdDSA_SIG_DOT Assinatura EdDSA Polkadot.
 * @property {number} EdDSA_SIG_XTZ Assinatura EdDSA Tezos.
 * @property {number} EdDSA_SIG_XTZ_PH Assinatura EdDSA Tezos com hash.
 */
var BLOCKCHAIN_EdDSA_TYPE;
(function (BLOCKCHAIN_EdDSA_TYPE) {
    BLOCKCHAIN_EdDSA_TYPE[BLOCKCHAIN_EdDSA_TYPE["SIG_PURE"] = 254] = "SIG_PURE";
    BLOCKCHAIN_EdDSA_TYPE[BLOCKCHAIN_EdDSA_TYPE["SIG_ALGORAND"] = 253] = "SIG_ALGORAND";
    BLOCKCHAIN_EdDSA_TYPE[BLOCKCHAIN_EdDSA_TYPE["SIG_XRP"] = 252] = "SIG_XRP";
    BLOCKCHAIN_EdDSA_TYPE[BLOCKCHAIN_EdDSA_TYPE["SIG_SOL"] = 251] = "SIG_SOL";
    BLOCKCHAIN_EdDSA_TYPE[BLOCKCHAIN_EdDSA_TYPE["EdDSA_SIG_XLM"] = 250] = "EdDSA_SIG_XLM";
    BLOCKCHAIN_EdDSA_TYPE[BLOCKCHAIN_EdDSA_TYPE["EdDSA_SIG_ADA"] = 249] = "EdDSA_SIG_ADA";
    BLOCKCHAIN_EdDSA_TYPE[BLOCKCHAIN_EdDSA_TYPE["EdDSA_SIG_DOT"] = 248] = "EdDSA_SIG_DOT";
    BLOCKCHAIN_EdDSA_TYPE[BLOCKCHAIN_EdDSA_TYPE["EdDSA_SIG_XTZ"] = 247] = "EdDSA_SIG_XTZ";
    BLOCKCHAIN_EdDSA_TYPE[BLOCKCHAIN_EdDSA_TYPE["EdDSA_SIG_XTZ_PH"] = 246] = "EdDSA_SIG_XTZ_PH";
})(BLOCKCHAIN_EdDSA_TYPE || (exports.BLOCKCHAIN_EdDSA_TYPE = BLOCKCHAIN_EdDSA_TYPE = {}));
/**
 * Formato da chave pública.
 * @property {number} ED25519 Ed25519.
 * @property {number} AT_ALGORAND Algorand.
 * @property {number} BIP32_XPUB BIP32 XPub.
 * @property {number} AT_SOL Solana.
 */
var BLOCKCHAIN_PUB_KEY_TYPE;
(function (BLOCKCHAIN_PUB_KEY_TYPE) {
    BLOCKCHAIN_PUB_KEY_TYPE[BLOCKCHAIN_PUB_KEY_TYPE["ED25519"] = 4] = "ED25519";
    BLOCKCHAIN_PUB_KEY_TYPE[BLOCKCHAIN_PUB_KEY_TYPE["AT_ALGORAND"] = 5] = "AT_ALGORAND";
    BLOCKCHAIN_PUB_KEY_TYPE[BLOCKCHAIN_PUB_KEY_TYPE["BIP32_XPUB"] = 6] = "BIP32_XPUB";
    BLOCKCHAIN_PUB_KEY_TYPE[BLOCKCHAIN_PUB_KEY_TYPE["AT_SOL"] = 7] = "AT_SOL";
})(BLOCKCHAIN_PUB_KEY_TYPE || (exports.BLOCKCHAIN_PUB_KEY_TYPE = BLOCKCHAIN_PUB_KEY_TYPE = {}));
/**
 * Tipo da assinatura a ser gerada.
 * @property {number} SIG_DER_ECDSA Assinatura DER, no formato v || DER. SECG!SEC1 strict DER com low S como descrito em BIP62/66, BIP146, EIP2. Tendo 'v' o tamanho de 1 byte. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1.
 * @property {number} SIG_RAW_ECDSA Assinatura RAW, no formato v || r || s. Tendo 'v' o tamanho de 1 byte e 'r' e 's' cada uma o tamanho de 32 bytes. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1.
 * @property {number} SIG_BIP340 Assinatura BIP340 - Schnorr 64 bytes.
 * @property {number} SIG_DER_RFC_6979_ECDSA Assinatura ECDSA determinística padrão RFC-6979. Tipo DER no formato v || DER, tendo 'v' o tamanho de 1 byte. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1
 * @property {number} SIG_RAW_RFC_6979_ECDSA Assinatura ECDSA determinística padrão RFC-6979. Tipo RAW no formato v || r || s, tendo 'v' o tamanho de 1 byte e 'r' e 's' cada uma o tamanho de 32 bytes. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1.
 */
var BLOCKCHAIN_SIG_TYPE;
(function (BLOCKCHAIN_SIG_TYPE) {
    BLOCKCHAIN_SIG_TYPE[BLOCKCHAIN_SIG_TYPE["SIG_DER_ECDSA"] = 1] = "SIG_DER_ECDSA";
    BLOCKCHAIN_SIG_TYPE[BLOCKCHAIN_SIG_TYPE["SIG_RAW_ECDSA"] = 2] = "SIG_RAW_ECDSA";
    BLOCKCHAIN_SIG_TYPE[BLOCKCHAIN_SIG_TYPE["SIG_BIP340"] = 3] = "SIG_BIP340";
    BLOCKCHAIN_SIG_TYPE[BLOCKCHAIN_SIG_TYPE["SIG_DER_RFC_6979_ECDSA"] = 4] = "SIG_DER_RFC_6979_ECDSA";
    BLOCKCHAIN_SIG_TYPE[BLOCKCHAIN_SIG_TYPE["SIG_RAW_RFC_6979_ECDSA"] = 5] = "SIG_RAW_RFC_6979_ECDSA";
})(BLOCKCHAIN_SIG_TYPE || (exports.BLOCKCHAIN_SIG_TYPE = BLOCKCHAIN_SIG_TYPE = {}));
/**
 * Opções de tipo do endereço.
 * @property {number} BTC_P2PKH Endereço P2PKH. Version deve ser BTC_A1_MAIN_NET, BTC_A3_MAIN_NET, BTC_AMN_TEST_NET, HTR_MAIN_NET ou HTR_TEST_NET. Hrp deve ser HRP_UNUSED.
 * @property {number} BTC_P2SH Endereço P2SH BIP13. Version deve ser BTC_A1_MAIN_NET, BTC_A3_MAIN_NET, BTC_AMN_TEST_NET, HTR_MAIN_NET ou HTR_TEST_NET. Hrp deve ser HRP_UNUSED. Pk deve ser o script-hash.
 * @property {number} BTC_B32_PKH Endereço BIP32 P2PKH BIP173. Version deve ser BTC_B32_WITVER. Hrp pode ser BTC_MAIN_NET ou BTC_TEST_NET.
 * @property {number} BTC_B32_SH Endereço BIP32 P2SH. Version deve ser BTC_A1_MAIN_NET, BTC_A3_MAIN_NET, BTC_AMN_TEST_NET, HTR_MAIN_NET ou HTR_TEST_NET. Hrp deve ser HRP_UNUSED. Pk deve ser o script-hash.
 * @property {number} ETH_EOA Endereço ETH EOA. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} ETH_EOA_MC_CKS Endereço ETH EOA MC CKS. EIP55. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} ETH_EOA_ICAP Endereço ETH EOA ICAP. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} ALGORAND Endereço Algorand. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} TRON_HEX Endereço TRON hexadecimal. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} TRON_B58 Endereço TRON Base 58. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} XRP Endereço XRP Ledger/Ripple. Version deve ser VER_XRP_CLASSIC. Hrp deve ser HRP_UNUSED.
 * @property {number} SOL Endereço Solana. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} XLM Endereço Stellar.
 * @property {number} ADA_PKH Endereço Cardano.
 * @property {number} ADA_SH Endereço Cardano.
 * @property {number} LUNC Endereço Terra Classic.
 * @property {number} SS58
 * @property {number} XTZ Endereço Tezos.
 * @property {number} TON Endereço Toncoin.
 * @property {number} TON_SH Endereço Toncoin.
 * @property {number} LTC_P2PKH Endereço Litecoin P2PKH.
 * @property {number} LTC_P2SH Endereço Litecoin P2SH.
 * @property {number} LTC_B32_PKH Endereço Litecoin BIP32 P2PKH.
 * @property {number} LTC_B32_SH Endereço Litecoin BIP32 P2SH.
 * @property {number} ATOM Endereço Cosmos (ATOM).
 * @property {number} BTC_P2TR Endereço Bitcoin P2TR BIP350. Version deve ser BTC_SEGWIT1. Hrp deve ser BTC_MAINNET ou BTC_TESTNET.
 */
var ADDRESS_TYPE;
(function (ADDRESS_TYPE) {
    ADDRESS_TYPE[ADDRESS_TYPE["BTC_P2PKH"] = 1] = "BTC_P2PKH";
    ADDRESS_TYPE[ADDRESS_TYPE["BTC_P2SH"] = 2] = "BTC_P2SH";
    ADDRESS_TYPE[ADDRESS_TYPE["BTC_B32_PKH"] = 3] = "BTC_B32_PKH";
    ADDRESS_TYPE[ADDRESS_TYPE["BTC_B32_SH"] = 4] = "BTC_B32_SH";
    ADDRESS_TYPE[ADDRESS_TYPE["ETH_EOA"] = 5] = "ETH_EOA";
    ADDRESS_TYPE[ADDRESS_TYPE["ETH_EOA_MC_CKS"] = 6] = "ETH_EOA_MC_CKS";
    ADDRESS_TYPE[ADDRESS_TYPE["ETH_EOA_ICAP"] = 7] = "ETH_EOA_ICAP";
    ADDRESS_TYPE[ADDRESS_TYPE["ALGORAND"] = 8] = "ALGORAND";
    ADDRESS_TYPE[ADDRESS_TYPE["TRON_HEX"] = 9] = "TRON_HEX";
    ADDRESS_TYPE[ADDRESS_TYPE["TRON_B58"] = 10] = "TRON_B58";
    ADDRESS_TYPE[ADDRESS_TYPE["XRP"] = 11] = "XRP";
    ADDRESS_TYPE[ADDRESS_TYPE["SOL"] = 12] = "SOL";
    ADDRESS_TYPE[ADDRESS_TYPE["XLM"] = 13] = "XLM";
    ADDRESS_TYPE[ADDRESS_TYPE["ADA_PKH"] = 14] = "ADA_PKH";
    ADDRESS_TYPE[ADDRESS_TYPE["ADA_SH"] = 15] = "ADA_SH";
    ADDRESS_TYPE[ADDRESS_TYPE["LUNC"] = 16] = "LUNC";
    ADDRESS_TYPE[ADDRESS_TYPE["SS58"] = 17] = "SS58";
    ADDRESS_TYPE[ADDRESS_TYPE["XTZ"] = 18] = "XTZ";
    ADDRESS_TYPE[ADDRESS_TYPE["TON"] = 19] = "TON";
    ADDRESS_TYPE[ADDRESS_TYPE["TON_SH"] = 20] = "TON_SH";
    ADDRESS_TYPE[ADDRESS_TYPE["ATOM"] = 21] = "ATOM";
    ADDRESS_TYPE[ADDRESS_TYPE["BTC_P2TR"] = 22] = "BTC_P2TR";
    ADDRESS_TYPE[ADDRESS_TYPE["LTC_P2PKH"] = 1] = "LTC_P2PKH";
    ADDRESS_TYPE[ADDRESS_TYPE["LTC_P2SH"] = 2] = "LTC_P2SH";
    ADDRESS_TYPE[ADDRESS_TYPE["LTC_B32_PKH"] = 3] = "LTC_B32_PKH";
    ADDRESS_TYPE[ADDRESS_TYPE["LTC_B32_SH"] = 4] = "LTC_B32_SH";
    ADDRESS_TYPE[ADDRESS_TYPE["LTC_P2TR"] = 22] = "LTC_P2TR";
})(ADDRESS_TYPE || (exports.ADDRESS_TYPE = ADDRESS_TYPE = {}));
/**
 * Opções de versão do endereço.
 * @property {number} UNUSED Parâmetro não utilizado.
 * @property {number} BTC_A1_MAIN_NET Bitcoin A1 mainnet.
 * @property {number} BTC_AMN_TEST_NET Bitcoin P2PKH testnet.
 * @property {number} BTC_A3_MAIN_NET Bitcoin A3 mainnet.
 * @property {number} BTC_SEGWIT0 Bitcoin Segwit v0.
 * @property {number} BTC_SEGWIT1 Bitcoin Segwit v1.
 * @property {number} HTR_MAIN_NET Hathor mainnet.
 * @property {number} HTR_TEST_NET Hathor testnet.
 * @property {number} HTR_P2SH_MAIN_NET Hathor P2PSH main net.
 * @property {number} HTR_P2SH_TEST_NET Hathor P2PSH testnet.
 * @property {number} XRP_CLASSIC XRP Ledger/Ripple Classic.
 * @property {number} LTC_SEGWIT0 Litecoin Segwit v0.
 * @property {number} LTC_SEGWIT1 Litecoin Segwit v1.
 * @property {number} LTC_AL_MAIN_NET
 * @property {number} LTC_Amn_TEST_NET Litecoin P2PKH testnet.
 * @property {number} LTC_AM_MAIN_NET Litecoin main net.
 * @property {number} LTC_AQ_TEST_NET Litecoin test net.
 * @property {number} ADA_MAIN_NET Cardano main net.
 * @property {number} ADA_TEST_NET Cardano test net.
 * @property {number} SS58_POLKADOT
 * @property {number} SS58_GEN_SUBST
 * @property {number} TON_MN_BWORK Toncoin main net basic workchain.
 * @property {number} TON_MN_MCHAIN Toncoin main net masterchain.
 * @property {number} TON_TN_BWORK Toncoin test net basic workchain.
 * @property {number} TON_TN_MCHAIN Toncoin test net masterchain.
 */
var ADDRESS_VERSION;
(function (ADDRESS_VERSION) {
    ADDRESS_VERSION[ADDRESS_VERSION["UNUSED"] = 0] = "UNUSED";
    ADDRESS_VERSION[ADDRESS_VERSION["BTC_A1_MAIN_NET"] = 0] = "BTC_A1_MAIN_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["BTC_AMN_TEST_NET"] = 111] = "BTC_AMN_TEST_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["BTC_A3_MAIN_NET"] = 5] = "BTC_A3_MAIN_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["BTC_SEGWIT0"] = 0] = "BTC_SEGWIT0";
    ADDRESS_VERSION[ADDRESS_VERSION["BTC_SEGWIT1"] = 1] = "BTC_SEGWIT1";
    ADDRESS_VERSION[ADDRESS_VERSION["HTR_MAIN_NET"] = 40] = "HTR_MAIN_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["HTR_TEST_NET"] = 73] = "HTR_TEST_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["HTR_P2SH_MAIN_NET"] = 100] = "HTR_P2SH_MAIN_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["HTR_P2SH_TEST_NET"] = 135] = "HTR_P2SH_TEST_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["XRP_CLASSIC"] = 0] = "XRP_CLASSIC";
    ADDRESS_VERSION[ADDRESS_VERSION["LTC_SEGWIT0"] = 0] = "LTC_SEGWIT0";
    ADDRESS_VERSION[ADDRESS_VERSION["LTC_SEGWIT1"] = 1] = "LTC_SEGWIT1";
    ADDRESS_VERSION[ADDRESS_VERSION["LTC_AL_MAIN_NET"] = 48] = "LTC_AL_MAIN_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["LTC_Amn_TEST_NET"] = 111] = "LTC_Amn_TEST_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["LTC_AM_MAIN_NET"] = 50] = "LTC_AM_MAIN_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["LTC_AQ_TEST_NET"] = 58] = "LTC_AQ_TEST_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["ADA_MAIN_NET"] = 1] = "ADA_MAIN_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["ADA_TEST_NET"] = 0] = "ADA_TEST_NET";
    ADDRESS_VERSION[ADDRESS_VERSION["SS58_POLKADOT"] = 0] = "SS58_POLKADOT";
    ADDRESS_VERSION[ADDRESS_VERSION["SS58_GEN_SUBST"] = 42] = "SS58_GEN_SUBST";
    ADDRESS_VERSION[ADDRESS_VERSION["TON_MN_BWORK"] = 1] = "TON_MN_BWORK";
    ADDRESS_VERSION[ADDRESS_VERSION["TON_MN_MCHAIN"] = 2] = "TON_MN_MCHAIN";
    ADDRESS_VERSION[ADDRESS_VERSION["TON_TN_BWORK"] = 3] = "TON_TN_BWORK";
    ADDRESS_VERSION[ADDRESS_VERSION["TON_TN_MCHAIN"] = 4] = "TON_TN_MCHAIN";
})(ADDRESS_VERSION || (exports.ADDRESS_VERSION = ADDRESS_VERSION = {}));
/**
 * Opções de HRP (Human Readable Part).
 * @property {string} UNUSED Parâmetro não utilizado.
 * @property {string} BTC_MAIN_NET Bitcoin main net.
 * @property {string} BTC_TEST_NET Bitcoin test net.
 * @property {string} BTC_REGTEST_NET Bitcoin regtest net.
 * @property {string} LTC_MAIN_NET Litecoin main net.
 * @property {string} LTC_TEST_NET Litecoin test net.
 * @property {string} TON_BNCBLE Toncoin bounceable.
 * @property {string} TON_NBNCBLE Toncoin non-bounceable.
 */
var ADDRESS_HRP;
(function (ADDRESS_HRP) {
    ADDRESS_HRP["UNUSED"] = "";
    ADDRESS_HRP["BTC_MAIN_NET"] = "bc";
    ADDRESS_HRP["BTC_TEST_NET"] = "tb";
    ADDRESS_HRP["BTC_REGTEST_NET"] = "bcrt";
    ADDRESS_HRP["LTC_MAIN_NET"] = "ltc";
    ADDRESS_HRP["LTC_TEST_NET"] = "tltc";
    ADDRESS_HRP["TON_BNCBLE"] = "bounceable";
    ADDRESS_HRP["TON_NBNCBLE"] = "non-bounceable";
})(ADDRESS_HRP || (exports.ADDRESS_HRP = ADDRESS_HRP = {}));
/**
 * Formato da chave pública a ser exportada.
 * @property {number} SEC1_UNCOMP ECDSA SEC1 não comprimida.
 * @property {number} SEC1_COMP ECDSA SEC1 comprimida.
 * @property {number} BIP340 Schnorr, BIP-340.
 * @property {number} ED25519 Ed25519.
 * @property {number} AT_ALGORAND Algorand.
 * @property {number} BIP32_XPUB BIP32 XPub.
 * @property {number} AT_SOL Solana.
 * @property {number} AT_XLM Stellar.
 * @property {number} ADA_VK Cardano.
 * @property {number} AT_SS58 SS58.
 * @property {number} TON Toncoin.
 * @property {number} E_UNCOMP SEC1_UNCOMP com o prefixo 0x04 removido; alt_bn128 (EIPs 196/197) apenas.
 */
var BLOCKCHAIN_GET_PUB_KEY_TYPE;
(function (BLOCKCHAIN_GET_PUB_KEY_TYPE) {
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["SEC1_UNCOMP"] = 1] = "SEC1_UNCOMP";
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["SEC1_COMP"] = 2] = "SEC1_COMP";
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["BIP340"] = 3] = "BIP340";
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["ED25519"] = 4] = "ED25519";
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["AT_ALGORAND"] = 5] = "AT_ALGORAND";
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["BIP32_XPUB"] = 6] = "BIP32_XPUB";
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["AT_SOL"] = 7] = "AT_SOL";
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["AT_XLM"] = 8] = "AT_XLM";
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["ADA_VK"] = 9] = "ADA_VK";
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["AT_SS58"] = 10] = "AT_SS58";
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["TON"] = 11] = "TON";
    BLOCKCHAIN_GET_PUB_KEY_TYPE[BLOCKCHAIN_GET_PUB_KEY_TYPE["E_UNCOMP"] = 12] = "E_UNCOMP";
})(BLOCKCHAIN_GET_PUB_KEY_TYPE || (exports.BLOCKCHAIN_GET_PUB_KEY_TYPE = BLOCKCHAIN_GET_PUB_KEY_TYPE = {}));
/**
 * Formato da chave pública para verificação da assinatura.
 * @property {number} SEC1_UNCOMP ECDSA SEC1 não comprimida.
 * @property {number} SEC1_COMP ECDSA SEC1 comprimida.
 * @property {number} BIP340 Schnorr, BIP-340.
 * @property {number} ED25519 Ed25519.
 */
var BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE;
(function (BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE) {
    BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE[BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE["SEC1_UNCOMP"] = 1] = "SEC1_UNCOMP";
    BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE[BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE["SEC1_COMP"] = 2] = "SEC1_COMP";
    BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE[BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE["BIP340"] = 3] = "BIP340";
    BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE[BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE["ED25519"] = 4] = "ED25519";
})(BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE || (exports.BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE = BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE = {}));
/**
 * Tipo da assinatura a ser gerada.
 * @property {number} DER_ECDSA Assinatura DER, no formato v || DER. SECG!SEC1 strict DER com low S como descrito em BIP62/66, BIP146, EIP2. Tendo 'v' o tamanho de 1 byte. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1.
 * @property {number} RAW_ECDSA Assinatura RAW, no formato v || r || s. Tendo 'v' o tamanho de 1 byte e 'r' e 's' cada uma o tamanho de 32 bytes. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1.
 */
var BLOCKCHAIN_PUB_SIG_REC_TYPE;
(function (BLOCKCHAIN_PUB_SIG_REC_TYPE) {
    BLOCKCHAIN_PUB_SIG_REC_TYPE[BLOCKCHAIN_PUB_SIG_REC_TYPE["DER_ECDSA"] = 1] = "DER_ECDSA";
    BLOCKCHAIN_PUB_SIG_REC_TYPE[BLOCKCHAIN_PUB_SIG_REC_TYPE["RAW_ECDSA"] = 2] = "RAW_ECDSA";
})(BLOCKCHAIN_PUB_SIG_REC_TYPE || (exports.BLOCKCHAIN_PUB_SIG_REC_TYPE = BLOCKCHAIN_PUB_SIG_REC_TYPE = {}));
/**
 * Formato da chave a ser importada.
 * @property {number} WIF Wallet Import Format (WIF).
 * @property {number} MINI Bitcoin minikey.
 * @property {number} HEX Escalar da chave privada em hexadecimal. Importada como uma chave do tipo {@link enums.ECC_ASYMMETRIC_SWITCHES.ALG_ECC_SECP256K1}.
 * @property {number} SEC1 SEC1.
 * @property {number} XPRIV XPriv.
 * @property {number} ED25529_B64 Ed25519 no formato Base 64.
 * @property {number} ED25529_XPRIV Ed25519 no formato XPriv.
 * @property {number} Ed25519_SKPK Ed25519 no formato SKPK.
 * @property {number} Ed25519_SK Ed25519 no formato SK.
 */
var IMPORT_EXPORT_FORMAT;
(function (IMPORT_EXPORT_FORMAT) {
    IMPORT_EXPORT_FORMAT[IMPORT_EXPORT_FORMAT["WIF"] = 1] = "WIF";
    IMPORT_EXPORT_FORMAT[IMPORT_EXPORT_FORMAT["MINI"] = 2] = "MINI";
    IMPORT_EXPORT_FORMAT[IMPORT_EXPORT_FORMAT["HEX"] = 3] = "HEX";
    IMPORT_EXPORT_FORMAT[IMPORT_EXPORT_FORMAT["SEC1"] = 4] = "SEC1";
    IMPORT_EXPORT_FORMAT[IMPORT_EXPORT_FORMAT["XPRIV"] = 5] = "XPRIV";
    IMPORT_EXPORT_FORMAT[IMPORT_EXPORT_FORMAT["ED25529_B64"] = 6] = "ED25529_B64";
    IMPORT_EXPORT_FORMAT[IMPORT_EXPORT_FORMAT["ED25529_XPRIV"] = 7] = "ED25529_XPRIV";
    IMPORT_EXPORT_FORMAT[IMPORT_EXPORT_FORMAT["Ed25519_SKPK"] = 8] = "Ed25519_SKPK";
    IMPORT_EXPORT_FORMAT[IMPORT_EXPORT_FORMAT["Ed25519_SK"] = 9] = "Ed25519_SK";
    IMPORT_EXPORT_FORMAT[IMPORT_EXPORT_FORMAT["Ed25519_XTZ"] = 10] = "Ed25519_XTZ";
})(IMPORT_EXPORT_FORMAT || (exports.IMPORT_EXPORT_FORMAT = IMPORT_EXPORT_FORMAT = {}));
/**
 * Versão da chave.
 * @property {number} UNUSED Parâmetro não utilizado.
 * @property {number} WIF_MAIN_NET WIF main net.
 * @property {number} WIF_TEST_NET WIF test net.
 * @property {number} WIF_LTC_MAIN_NET WIF LTC main net.
 */
var BLOCKCHAIN_EXPORT_VERSION;
(function (BLOCKCHAIN_EXPORT_VERSION) {
    BLOCKCHAIN_EXPORT_VERSION[BLOCKCHAIN_EXPORT_VERSION["UNUSED"] = 0] = "UNUSED";
    BLOCKCHAIN_EXPORT_VERSION[BLOCKCHAIN_EXPORT_VERSION["WIF_MAIN_NET"] = 128] = "WIF_MAIN_NET";
    BLOCKCHAIN_EXPORT_VERSION[BLOCKCHAIN_EXPORT_VERSION["WIF_TEST_NET"] = 239] = "WIF_TEST_NET";
    BLOCKCHAIN_EXPORT_VERSION[BLOCKCHAIN_EXPORT_VERSION["WIF_LTC_MAIN_NET"] = 176] = "WIF_LTC_MAIN_NET";
})(BLOCKCHAIN_EXPORT_VERSION || (exports.BLOCKCHAIN_EXPORT_VERSION = BLOCKCHAIN_EXPORT_VERSION = {}));
/**
 * Padding da assinatura.
 * @property {number} PKCS1_V1_5 PKCS#1 v1.5.
 * @property {number} PSS PSS.
 * @property {number} X931 X9.31.
 */
var PAD_TYPE;
(function (PAD_TYPE) {
    PAD_TYPE[PAD_TYPE["PKCS1_V1_5"] = 2] = "PKCS1_V1_5";
    PAD_TYPE[PAD_TYPE["PSS"] = 3] = "PSS";
    PAD_TYPE[PAD_TYPE["X931"] = 4] = "X931";
})(PAD_TYPE || (exports.PAD_TYPE = PAD_TYPE = {}));
/**
 * Permissões do usuário.
 * @property {number} NOP Usuário apenas com autorizações ordinárias.
 *
 * @property {number} OBJ_CREATE Permissão para criar objetos. A permissão de leitura (OBJ_READ) é atribuída implicitamente.
 * @property {number} OBJ_DEL Permissão para remover objetos. A permissão de leitura (OBJ_READ) é atribuída implicitamente.
 * @property {number} OBJ_READ Permissão para ler o conteúdo de objetos.
 * @property {number} OBJ_UPDATE Permissão para atualizar atributos dos objetos. OBJ_UPDATE = OBJ_WRITE
 * @property {number} OBJ_WRITE Permissão para atualizar atributos dos objetos. OBJ_UPDATE = OBJ_WRITE
 *
 * @property {number} USR_LIST Permissão para listar usuários.
 * @property {number} USR_CREATE Permissão para criar e remover usuários. USR_CREATE = USR_DELETE
 * @property {number} USR_DELETE Permissão para criar e remover usuários. USR_CREATE = USR_DELETE
 * @property {number} USR_REMOTE_LOG Permissão para receber notificações de log remota.
 *
 * @property {number} SYS_OPERATOR Permissão para operar como o usuário ‘master’.
 * @property {number} SYS_BACKUP Permissão para criar e restaurar cópias de segurança dos dados do HSM. SYS_BACKUP = SYS_RESTORE
 * @property {number} SYS_RESTORE Permissão para criar e restaurar cópias de segurança dos dados do HSM. SYS_BACKUP = SYS_RESTORE
 * @property {number} SYS_UDATE_HSM Permissão para atualizar o firmware.
 */
var USER_PERMISSIONS;
(function (USER_PERMISSIONS) {
    USER_PERMISSIONS[USER_PERMISSIONS["NOP"] = 0] = "NOP";
    USER_PERMISSIONS[USER_PERMISSIONS["OBJ_DEL"] = 1] = "OBJ_DEL";
    USER_PERMISSIONS[USER_PERMISSIONS["OBJ_READ"] = 2] = "OBJ_READ";
    USER_PERMISSIONS[USER_PERMISSIONS["OBJ_CREATE"] = 4] = "OBJ_CREATE";
    USER_PERMISSIONS[USER_PERMISSIONS["OBJ_LIST"] = 2] = "OBJ_LIST";
    USER_PERMISSIONS[USER_PERMISSIONS["OBJ_UPDATE"] = 8] = "OBJ_UPDATE";
    USER_PERMISSIONS[USER_PERMISSIONS["OBJ_WRITE"] = 8] = "OBJ_WRITE";
    USER_PERMISSIONS[USER_PERMISSIONS["USR_CREATE"] = 16] = "USR_CREATE";
    USER_PERMISSIONS[USER_PERMISSIONS["USR_DELETE"] = 16] = "USR_DELETE";
    USER_PERMISSIONS[USER_PERMISSIONS["USR_REMOTE_LOG"] = 32] = "USR_REMOTE_LOG";
    USER_PERMISSIONS[USER_PERMISSIONS["USR_LIST"] = 64] = "USR_LIST";
    USER_PERMISSIONS[USER_PERMISSIONS["SYS_OPERATOR"] = 128] = "SYS_OPERATOR";
    USER_PERMISSIONS[USER_PERMISSIONS["SYS_BACKUP"] = 256] = "SYS_BACKUP";
    USER_PERMISSIONS[USER_PERMISSIONS["SYS_RESTORE"] = 256] = "SYS_RESTORE";
    USER_PERMISSIONS[USER_PERMISSIONS["SYS_UDATE_HSM"] = 512] = "SYS_UDATE_HSM";
    USER_PERMISSIONS[USER_PERMISSIONS["NS_AUTHORIZATION"] = 1024] = "NS_AUTHORIZATION";
    USER_PERMISSIONS[USER_PERMISSIONS["COLD_PRT"] = 2048] = "COLD_PRT";
    USER_PERMISSIONS[USER_PERMISSIONS["VIRTUAL_OTP_AUTH"] = 536870912] = "VIRTUAL_OTP_AUTH";
    USER_PERMISSIONS[USER_PERMISSIONS["VIRTUAL_X509_AUTH"] = 268435456] = "VIRTUAL_X509_AUTH";
    USER_PERMISSIONS[USER_PERMISSIONS["CHANGE_PWD_NEXT_TIME"] = 1073741824] = "CHANGE_PWD_NEXT_TIME";
})(USER_PERMISSIONS || (exports.USER_PERMISSIONS = USER_PERMISSIONS = {}));
/**
 * Formatos das chaves a serem exportadas.
 * @property {number} PRIVATE_KEY_BLOB_STRICT Será exportado um par de chaves RSA ou EC no formato PRIVATE_KEY_BLOB.
 * hKEKey deve ser o contexto de uma chave simétrica, uma chave pública(interna ao HSM ver PUBLIC_KEY_BLOB_HSM) ou ainda NULL.
 * Os seguintes formatos são aceitos.
 * Para RSA: Chave privada (que contém as informações de módulo e expoente público), definido na PKCS#1 v1.5 seção 7.2.
 * Para chaves ECC devem ter o formato ECPrivateKey descrito na RFC 5915.
 * Para chaves ECX(EdDSA e XECDH) o formato é o descrito na RFC 8410.
 * @property {number} PRIVATE_KEY_BLOB Mesmo comportamento de PRIVATE_KEY_BLOB_STRICT mas em versões antigas de HSM pode retornar chaves RSA como uma concatenação de chave privada e chave pública nos formatos definidos no PKCS#1 v1.5, nas seções 7.1 e 7.2. Esta opção é mantida por compatibilidade. Utilizar PRIVATE_KEY_BLOB_STRICT.
 * @property {number} PRIVATE_KEY_BLOB_P8 Será importado um par de chaves RSA no formato PRIVATE_KEY_BLOB_P8.
 * hKEKey deve ser o contexto de uma chave de simétrica.
 * O formato do blob da chave é o PrivateKeyInfo definido no PKCS#8.
 * @property {number} PUBLIC_KEY_BLOB Será exportada uma chave pública de um par de chaves RSA ou EC no formato PUBLIC_KEY_BLOB.hKEKey deve ser igual a NULL. O contexto retornado pela exportação de chave pública deve ser utilizado apenas nas operações de envelope digital, pois o HSM não cria de forma persistente objetos RSA com apenas a parte pública da chave seguindo o padrão PKCS#1 v2.2 formato DER.Para chaves públicas EC (ECC e ECX) o padrão é o SubjectPublicKeyInfo formato DER.
 * @property {number} SIMPLE_BLOB Será exportada uma chave simétrica no formato SIMPLE_BLOB.hKEKey deve ser o contexto de uma chave privada associada à chave pública usada para criptografar o blob a ser importado.O tipo do padding usado para criptografia da chave deve ser 2, como definido no PKCS#1 v1.5 seção 8.1.
 * @property {number} PLAINTEXT_KEY_BLOB Será exportada uma chave simétrica ou HMAC em claro.Essa flag ainda não é suportada para chaves RSA.
 * @property {number} SIMPLE_BLOB_OAEP Define a exportação através de envelope digital usando o padrão PKCS#1 versão 2.1, com esquema de cifragem RSAES-OAEP. A KEK deverá ser uma chave privada no HSM, cuja chave pública correspondente foi utilizada na criação do envelope. O contexto para esta KEK pode ser obtido via uma chamada à DGetUserKey, onde será informado o id da chave RSA do HSM usada para abrir o envelope. Este método de exportação pode ser utilizado nos modos de operação restritos.
 * @property {number} SYM_WRAPPED_KEY_BLOB Define uma chave simétrica encriptada por uma KEK (Key Encryption Key) também simétrica.O parâmetro hKEKey deverá conter o contexto de uma chave simétrica com os devidos parâmetros de utilização já definidos, como modo e padding.A chave será decriptada e importada para a base do HSM diretamente, sem formatação específica.
 * @property {number} HOTP_BLOB Define a importação de um objeto tipo HTOP para a partição do usuário.
 * @property {number} PUBLIC_KEY_BLOB_HSM Será importada uma chave pública de um par de chaves RSA/ECC no formato DER para dentro do HSM. hKEKey deve ser igual a NULL.
 * @property {number} PUBLIC_KEY_RSA_PARTS_HSM Será importada uma chave pública, a partir do módulo e do expoente público, para dentro do HSM. hKEKey deve ser igual a NULL. Deve ser passado em pbData a estrutura RSA_PUB_KEY_PARTS devidamente preenchida.
 * @property {number} WRAPPED_KEY_BLOB Importa uma chave encriptada por uma KEK (Key Encryption Key).O parâmetro hKEKey deverá conter o contexto de uma chave simétrica com os devidos parâmetros de utilização já definidos, como modo(de acordo com o algoritmo) e padding. A chave será decriptada e importada para a base do HSM diretamente, sem formatação específica.
 * @property {number} WRAPPED_KEY_BLOB_P8 Importa uma chave encriptada por uma KEK (Key Encryption Key).O parâmetro hKEKey deverá conter o contexto de uma chave simétrica com os devidos parâmetros de utilização já definidos, como modo(de acordo com o algoritmo) e padding. A chave será decriptada e importada para a base do HSM diretamente, sem formatação específica. Na operação de exportação de chave o formato da chave privada será PKCS#8.
 */
var KEY_EXPORT_FORMAT;
(function (KEY_EXPORT_FORMAT) {
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["PRIVATE_KEY_BLOB_STRICT"] = 14] = "PRIVATE_KEY_BLOB_STRICT";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["PRIVATE_KEY_BLOB"] = 1] = "PRIVATE_KEY_BLOB";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["PRIVATE_KEY_BLOB_P8"] = 13] = "PRIVATE_KEY_BLOB_P8";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["PUBLIC_KEY_BLOB"] = 2] = "PUBLIC_KEY_BLOB";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["SIMPLE_BLOB"] = 3] = "SIMPLE_BLOB";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["PLAINTEXT_KEY_BLOB"] = 4] = "PLAINTEXT_KEY_BLOB";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["SIMPLE_BLOB_OAEP"] = 7] = "SIMPLE_BLOB_OAEP";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["SYM_WRAPPED_KEY_BLOB"] = 9] = "SYM_WRAPPED_KEY_BLOB";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["HOTP_BLOB"] = 6] = "HOTP_BLOB";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["PUBLIC_KEY_BLOB_HSM"] = 11] = "PUBLIC_KEY_BLOB_HSM";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["PUBLIC_KEY_RSA_PARTS_HSM"] = 12] = "PUBLIC_KEY_RSA_PARTS_HSM";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["WRAPPED_KEY_BLOB"] = 16] = "WRAPPED_KEY_BLOB";
    KEY_EXPORT_FORMAT[KEY_EXPORT_FORMAT["WRAPPED_KEY_BLOB_P8"] = 18] = "WRAPPED_KEY_BLOB_P8";
})(KEY_EXPORT_FORMAT || (exports.KEY_EXPORT_FORMAT = KEY_EXPORT_FORMAT = {}));
/**
 * Algoritmos de hash para assinatura do CSR.
 */
var PKCS10_HASH_ALGORITHM;
(function (PKCS10_HASH_ALGORITHM) {
    PKCS10_HASH_ALGORITHM[PKCS10_HASH_ALGORITHM["SHA1"] = 1] = "SHA1";
    PKCS10_HASH_ALGORITHM[PKCS10_HASH_ALGORITHM["SHA224"] = 2] = "SHA224";
    PKCS10_HASH_ALGORITHM[PKCS10_HASH_ALGORITHM["SHA256"] = 3] = "SHA256";
    PKCS10_HASH_ALGORITHM[PKCS10_HASH_ALGORITHM["SHA384"] = 4] = "SHA384";
    PKCS10_HASH_ALGORITHM[PKCS10_HASH_ALGORITHM["SHA512"] = 5] = "SHA512";
    PKCS10_HASH_ALGORITHM[PKCS10_HASH_ALGORITHM["SHA3_224"] = 6] = "SHA3_224";
    PKCS10_HASH_ALGORITHM[PKCS10_HASH_ALGORITHM["SHA3_256"] = 7] = "SHA3_256";
    PKCS10_HASH_ALGORITHM[PKCS10_HASH_ALGORITHM["SHA3_384"] = 8] = "SHA3_384";
    PKCS10_HASH_ALGORITHM[PKCS10_HASH_ALGORITHM["SHA3_512"] = 9] = "SHA3_512";
})(PKCS10_HASH_ALGORITHM || (exports.PKCS10_HASH_ALGORITHM = PKCS10_HASH_ALGORITHM = {}));
/**
 * Opções de padding para operação de KEK.
 * @property {number} UNUSED_PAD Padding não utilizado.
 * @property {number} P5_PAD Padding P5.
 * @property {number} 0_PAD Padding 0.
 * @property {number} OAEP_PAD Padding OAEP com SHA1.
 * @property {number} P1_PAD Padding P1.
 * @property {number} OAEP2_PAD Padding OAEP com SHA256.
 */
var KEK_WRAP_PADDING;
(function (KEK_WRAP_PADDING) {
    KEK_WRAP_PADDING[KEK_WRAP_PADDING["UNUSED_PAD"] = 0] = "UNUSED_PAD";
    KEK_WRAP_PADDING[KEK_WRAP_PADDING["P5_PAD"] = 1] = "P5_PAD";
    KEK_WRAP_PADDING[KEK_WRAP_PADDING["_0_PAD"] = 2] = "_0_PAD";
    KEK_WRAP_PADDING[KEK_WRAP_PADDING["OAEP_PAD"] = 3] = "OAEP_PAD";
    KEK_WRAP_PADDING[KEK_WRAP_PADDING["P1_PAD"] = 4] = "P1_PAD";
    KEK_WRAP_PADDING[KEK_WRAP_PADDING["OAEP2_PAD"] = 5] = "OAEP2_PAD";
})(KEK_WRAP_PADDING || (exports.KEK_WRAP_PADDING = KEK_WRAP_PADDING = {}));
/**
 * Modo suportado pela operação de KEK.
 * @property {number} UNUSED_MODE Modo não utilizado.
 */
var KEK_WRAP_MODE;
(function (KEK_WRAP_MODE) {
    KEK_WRAP_MODE[KEK_WRAP_MODE["UNUSED_MODE"] = 0] = "UNUSED_MODE";
})(KEK_WRAP_MODE || (exports.KEK_WRAP_MODE = KEK_WRAP_MODE = {}));
/**
 * Classe pseudo obj_type suportada pela operação de KEK.
 * @property {number} T_P_RSA Tipo RSA.
 * @property {number} T_P_ECC Tipo ECC.
 * @property {number} T_P8 Tipo P8.
 * @property {number} T_P_ECX Tipo ECX.
 * @property {number} T_P_DSA Tipo DSA.
 * @property {number} T_P_DH Tipo DH.
 */
var KEK_WRAP_OBJ_TYPE;
(function (KEK_WRAP_OBJ_TYPE) {
    KEK_WRAP_OBJ_TYPE[KEK_WRAP_OBJ_TYPE["T_P_RSA"] = 4294967265] = "T_P_RSA";
    KEK_WRAP_OBJ_TYPE[KEK_WRAP_OBJ_TYPE["T_P_ECC"] = 4294967264] = "T_P_ECC";
    KEK_WRAP_OBJ_TYPE[KEK_WRAP_OBJ_TYPE["T_P8"] = 4294967263] = "T_P8";
    KEK_WRAP_OBJ_TYPE[KEK_WRAP_OBJ_TYPE["T_P_ECX"] = 4294967262] = "T_P_ECX";
    KEK_WRAP_OBJ_TYPE[KEK_WRAP_OBJ_TYPE["T_P_DSA"] = 4294967261] = "T_P_DSA";
    KEK_WRAP_OBJ_TYPE[KEK_WRAP_OBJ_TYPE["T_P_DH"] = 4294967260] = "T_P_DH";
})(KEK_WRAP_OBJ_TYPE || (exports.KEK_WRAP_OBJ_TYPE = KEK_WRAP_OBJ_TYPE = {}));
/**
 * Modo KEK.
 * @property {number} MODE_CBC Modo de Cifra de Bloco em Cadeia (CBC).
 * @property {number} MODE_ECB Modo de Cifra de Bloco Eletrônico (ECB).
 */
var KEK_MODE;
(function (KEK_MODE) {
    KEK_MODE[KEK_MODE["MODE_ECB"] = 1] = "MODE_ECB";
    KEK_MODE[KEK_MODE["MODE_CBC"] = 2] = "MODE_CBC";
})(KEK_MODE || (exports.KEK_MODE = KEK_MODE = {}));
/**
 * Modo de preenchimento de criptografia e descriptografia.
 * @property {number} PKCS1 Preenchimento PKCS #1.
 * @property {number} OAEP_SHA1 Preenchimento OAEP com SHA-1.
 * @property {number} OAEP_SHA256 Preenchimento OAEP com SHA-256.
 */
var ENC_DEC_PADDING;
(function (ENC_DEC_PADDING) {
    ENC_DEC_PADDING[ENC_DEC_PADDING["PKCS1"] = 1] = "PKCS1";
    ENC_DEC_PADDING[ENC_DEC_PADDING["OAEP_SHA1"] = 2] = "OAEP_SHA1";
    ENC_DEC_PADDING[ENC_DEC_PADDING["OAEP_SHA256"] = 3] = "OAEP_SHA256";
})(ENC_DEC_PADDING || (exports.ENC_DEC_PADDING = ENC_DEC_PADDING = {}));
/**
 * Tamanhos de chave RSA.
 * @property {number} RSA_512 Chave RSA de 512 bits.
 * @property {number} RSA_1024 Chave RSA de 1024 bits.
 * @property {number} RSA_2048 Chave RSA de 2048 bits.
 * @property {number} RSA_4096 Chave RSA de 4096 bits.
 * @property {number} RSA_1152 Chave RSA de 1152 bits.
 * @property {number} RSA_1408 Chave RSA de 1408 bits.
 * @property {number} RSA_1536 Chave RSA de 1536 bits.
 * @property {number} RSA_1976 Chave RSA de 1976 bits.
 * @property {number} RSA_1984 Chave RSA de 1984 bits.
 * @property {number} RSA_8192 Chave RSA de 8192 bits.
 * @property {number} RSA_2304 Chave RSA de 2304 bits.
 * @property {number} RSA_2560 Chave RSA de 2560 bits.
 * @property {number} RSA_2816 Chave RSA de 2816 bits.
 * @property {number} RSA_3072 Chave RSA de 3072 bits.
 */
var RSA_LENGTH_KEYS;
(function (RSA_LENGTH_KEYS) {
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_512"] = 64] = "RSA_512";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_1024"] = 128] = "RSA_1024";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_2048"] = 256] = "RSA_2048";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_4096"] = 512] = "RSA_4096";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_1152"] = 144] = "RSA_1152";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_1408"] = 176] = "RSA_1408";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_1536"] = 192] = "RSA_1536";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_1976"] = 247] = "RSA_1976";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_1984"] = 248] = "RSA_1984";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_8192"] = 1024] = "RSA_8192";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_2304"] = 288] = "RSA_2304";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_2560"] = 320] = "RSA_2560";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_2816"] = 352] = "RSA_2816";
    RSA_LENGTH_KEYS[RSA_LENGTH_KEYS["RSA_3072"] = 384] = "RSA_3072";
})(RSA_LENGTH_KEYS || (exports.RSA_LENGTH_KEYS = RSA_LENGTH_KEYS = {}));
/**
 * Tipo da chave utilizada para a função OCRA
 * @property {number} MOD_OATH_OCRA_USE_PH20 indica o uso da função SHA1
 * @property {number} MOD_OATH_OCRA_USE_PH32 indica o uso da função SHA256
 * @property {number} MOD_OATH_OCRA_USE_PH64 indica o uso da função SHA512
 */
var OCRA_PIN_HASH_TYPE;
(function (OCRA_PIN_HASH_TYPE) {
    OCRA_PIN_HASH_TYPE[OCRA_PIN_HASH_TYPE["MOD_OATH_OCRA_USE_PH20"] = 2] = "MOD_OATH_OCRA_USE_PH20";
    OCRA_PIN_HASH_TYPE[OCRA_PIN_HASH_TYPE["MOD_OATH_OCRA_USE_PH32"] = 4] = "MOD_OATH_OCRA_USE_PH32";
    OCRA_PIN_HASH_TYPE[OCRA_PIN_HASH_TYPE["MOD_OATH_OCRA_USE_PH64"] = 8] = "MOD_OATH_OCRA_USE_PH64";
})(OCRA_PIN_HASH_TYPE || (exports.OCRA_PIN_HASH_TYPE = OCRA_PIN_HASH_TYPE = {}));
/**
 * Modos de preenchimento OCRA
 * @property {number} MOD_OATH_OCRA_USE_CTR indica o uso de um contador para a função OCRA
 * @property {number} MOD_OATH_OCRA_USE_TS indica o uso de um timestamp para a função OCRA
 */
var OCRA_MODE;
(function (OCRA_MODE) {
    OCRA_MODE[OCRA_MODE["MOD_OATH_OCRA_USE_CTR"] = 1] = "MOD_OATH_OCRA_USE_CTR";
    OCRA_MODE[OCRA_MODE["MOD_OATH_OCRA_USE_TS"] = 16] = "MOD_OATH_OCRA_USE_TS";
})(OCRA_MODE || (exports.OCRA_MODE = OCRA_MODE = {}));
/**
 * Tamanhos de variáveis no payload OCRA
 * @property {number} MOD_OATH_OCRA_MAX_SUITE_LEN tamanho máximo para o ocraSuite
 * @property {number} MOD_OATH_OCRA_CTR_LEN tamanho máximo para o contador
 * @property {number} MOD_OATH_OCRA_MAX_Q_LEN tamanho máximo para o challenger
 * @property {number} MOD_OATH_OCRA_CSESS_MAX_LEN tamanho máximo para dados de sessão
 * @property {number} MOD_OATH_OCRA_TIME_STEPS_LEN tamanho máximo para o timestamp
 */
var OCRA_MODE_LEN;
(function (OCRA_MODE_LEN) {
    OCRA_MODE_LEN[OCRA_MODE_LEN["MOD_OATH_OCRA_MAX_SUITE_LEN"] = 128] = "MOD_OATH_OCRA_MAX_SUITE_LEN";
    OCRA_MODE_LEN[OCRA_MODE_LEN["MOD_OATH_OCRA_CTR_LEN"] = 8] = "MOD_OATH_OCRA_CTR_LEN";
    // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
    OCRA_MODE_LEN[OCRA_MODE_LEN["MOD_OATH_OCRA_MAX_Q_LEN"] = 128] = "MOD_OATH_OCRA_MAX_Q_LEN";
    OCRA_MODE_LEN[OCRA_MODE_LEN["MOD_OATH_OCRA_CSESS_MAX_LEN"] = 512] = "MOD_OATH_OCRA_CSESS_MAX_LEN";
    // eslint-disable-next-line @typescript-eslint/no-duplicate-enum-values
    OCRA_MODE_LEN[OCRA_MODE_LEN["MOD_OATH_OCRA_TIME_STEPS_LEN"] = 8] = "MOD_OATH_OCRA_TIME_STEPS_LEN";
})(OCRA_MODE_LEN || (exports.OCRA_MODE_LEN = OCRA_MODE_LEN = {}));
/**
 * Tamanhos de variáveis MOD_OATH_OTP
 * @property {number} MOD_OATH_MIN_OTP_LEN Menor tamanho possível para um PIN HASH OTP
 * @property {number} MOD_OATH_LOOKAHEAD_WND Tamanho máximo para o look-ahead window.
 * @property {number} MOD_OATH_MAX_OTP_LEN Maior tamanho possível para um PIN HASH OTP
 */
var MOD_OATH_OTP;
(function (MOD_OATH_OTP) {
    MOD_OATH_OTP[MOD_OATH_OTP["MOD_OATH_MIN_OTP_LEN"] = 6] = "MOD_OATH_MIN_OTP_LEN";
    MOD_OATH_OTP[MOD_OATH_OTP["MOD_OATH_LOOKAHEAD_WND"] = 10] = "MOD_OATH_LOOKAHEAD_WND";
    MOD_OATH_OTP[MOD_OATH_OTP["MOD_OATH_MAX_OTP_LEN"] = 16] = "MOD_OATH_MAX_OTP_LEN";
})(MOD_OATH_OTP || (exports.MOD_OATH_OTP = MOD_OATH_OTP = {}));
/**
 * @internal
 * Status de resposta do Dinamo Native Host
 * @property {number} STATUS_SUCCESS Indica que a operação foi bem-sucedida.
 * @property {number} STATUS_ERROR Indica que ocorreu um erro na operação.
 * @property {number} STATUS_UNKNOWN_COMMAND Indica que o comando enviado é desconhecido.
 * @property {number} STATUS_CLOSING Indica que o Native Host está fechando.
 */
var NH_RESPONSE_STATUS;
(function (NH_RESPONSE_STATUS) {
    NH_RESPONSE_STATUS[NH_RESPONSE_STATUS["STATUS_SUCCESS"] = 0] = "STATUS_SUCCESS";
    NH_RESPONSE_STATUS[NH_RESPONSE_STATUS["STATUS_ERROR"] = 1] = "STATUS_ERROR";
    NH_RESPONSE_STATUS[NH_RESPONSE_STATUS["STATUS_UNKNOWN_COMMAND"] = 2] = "STATUS_UNKNOWN_COMMAND";
    NH_RESPONSE_STATUS[NH_RESPONSE_STATUS["STATUS_CLOSING"] = 3] = "STATUS_CLOSING";
})(NH_RESPONSE_STATUS || (exports.NH_RESPONSE_STATUS = NH_RESPONSE_STATUS = {}));
/**
 * Estados de autenticação NS (Network Security).
 * @property {number} ASSOCIATED Transição para o estado associado.
 * @property {number} RESET Transição para o estado nulo.
 * @property {number} AUTHORIZED Transição para o estado autorizado.
 * @property {number} EPHEMERAL_AUTH Transição para uma sessão online efêmera.
 * @property {number} CHECK Transição reflexiva, apenas para verificar o conjunto de shadow/share.
 */
var NSAUTH_STATE;
(function (NSAUTH_STATE) {
    NSAUTH_STATE[NSAUTH_STATE["ASSOCIATED"] = 1] = "ASSOCIATED";
    NSAUTH_STATE[NSAUTH_STATE["RESET"] = 2] = "RESET";
    NSAUTH_STATE[NSAUTH_STATE["AUTHORIZED"] = 3] = "AUTHORIZED";
    NSAUTH_STATE[NSAUTH_STATE["EPHEMERAL_AUTH"] = 4] = "EPHEMERAL_AUTH";
    NSAUTH_STATE[NSAUTH_STATE["CHECK"] = 5] = "CHECK";
})(NSAUTH_STATE || (exports.NSAUTH_STATE = NSAUTH_STATE = {}));
/**
 * Tipos de Controle de Acesso (ACL).
 * @property {number} NOP Nenhuma permissão. Valor padrão.
 * @property {number} OBJ_DEL Permissão para deletar objetos.
 * @property {number} OBJ_READ Permissão para ler o conteúdo de objetos.
 * @property {number} OBJ_LIST Permissão para listar objetos de usuário.
 * @property {number} OBJ_CREATE Permissão para criar objetos.
 * @property {number} OBJ_UPDATE Permissão para atualizar objetos (cabeçalhos e similares).
 * @property {number} OBJ_WRITE Permissão para atualizar objetos (sinônimo de OBJ_UPDATE).
 * @property {number} USR_CREATE Permissão para criar usuários.
 * @property {number} USR_DELETE Permissão para deletar usuários. (Apenas a criação faz sentido.)
 * @property {number} USR_REMOTE_INFO Permissão para obter/definir informações remotas de usuários (logs, etc.).
 * @property {number} USR_LIST Permissão para obter a lista de usuários.
 * @property {number} SYS_OPERATOR Operar como mestre (modo administrador).
 * @property {number} SYS_BACKUP Permissão para extrair o backup completo do aparelho.
 * @property {number} SYS_RESTORE Permissão para restaurar o backup completo do aparelho.
 * @property {number} SYS_UPDATE_HSM Permissão para atualizar firmware e similares.
 * @property {number} NS_AUTHORIZATION Permissão para a autorização de usuário com "m de n".
 * @property {number} LOCAL_CRYPTO_PRT Permissão para realizar operações criptográficas de usuário localmente.
 * @property {number} VIRTUAL_X509_AUTH Permissão para usar autenticação PKI (2F PKI).
 * @property {number} VIRTUAL_OTP_AUTH Permissão para usar autenticação OTP (2F OTP).
 * @property {number} CHANGE_PWD_NEXT_TIME Permissão para forçar usuários a mudar a senha no próximo login.
 */
var ACL_MASK;
(function (ACL_MASK) {
    ACL_MASK[ACL_MASK["NOP"] = 0] = "NOP";
    ACL_MASK[ACL_MASK["OBJ_DEL"] = 1] = "OBJ_DEL";
    ACL_MASK[ACL_MASK["OBJ_READ"] = 2] = "OBJ_READ";
    ACL_MASK[ACL_MASK["OBJ_LIST"] = 2] = "OBJ_LIST";
    ACL_MASK[ACL_MASK["OBJ_CREATE"] = 4] = "OBJ_CREATE";
    ACL_MASK[ACL_MASK["OBJ_UPDATE"] = 8] = "OBJ_UPDATE";
    ACL_MASK[ACL_MASK["OBJ_WRITE"] = 8] = "OBJ_WRITE";
    ACL_MASK[ACL_MASK["USR_CREATE"] = 16] = "USR_CREATE";
    ACL_MASK[ACL_MASK["USR_DELETE"] = 16] = "USR_DELETE";
    ACL_MASK[ACL_MASK["USR_REMOTE_INFO"] = 32] = "USR_REMOTE_INFO";
    ACL_MASK[ACL_MASK["USR_LIST"] = 64] = "USR_LIST";
    ACL_MASK[ACL_MASK["SYS_OPERATOR"] = 128] = "SYS_OPERATOR";
    ACL_MASK[ACL_MASK["SYS_BACKUP"] = 256] = "SYS_BACKUP";
    ACL_MASK[ACL_MASK["SYS_RESTORE"] = 256] = "SYS_RESTORE";
    ACL_MASK[ACL_MASK["SYS_UPDATE_HSM"] = 512] = "SYS_UPDATE_HSM";
    ACL_MASK[ACL_MASK["NS_AUTHORIZATION"] = 1024] = "NS_AUTHORIZATION";
    ACL_MASK[ACL_MASK["LOCAL_CRYPTO_PRT"] = 2048] = "LOCAL_CRYPTO_PRT";
    ACL_MASK[ACL_MASK["VIRTUAL_X509_AUTH"] = 268435456] = "VIRTUAL_X509_AUTH";
    ACL_MASK[ACL_MASK["VIRTUAL_OTP_AUTH"] = 536870912] = "VIRTUAL_OTP_AUTH";
    ACL_MASK[ACL_MASK["CHANGE_PWD_NEXT_TIME"] = 1073741824] = "CHANGE_PWD_NEXT_TIME";
})(ACL_MASK || (exports.ACL_MASK = ACL_MASK = {}));
/**
 * Versão do generate SVMK
 * @property {number} V1 Versão 1 da SVMK
 * @property {number} V2 Versão 2 da SVMK
 */
var SVMK_VERSION;
(function (SVMK_VERSION) {
    SVMK_VERSION[SVMK_VERSION["V1"] = 1] = "V1";
    SVMK_VERSION[SVMK_VERSION["V2"] = 2] = "V2";
})(SVMK_VERSION || (exports.SVMK_VERSION = SVMK_VERSION = {}));
/**
 * Tipo de TFA
 * @property {number} OTP - One Time Password TFA
 * @property {number} X509 - X.509 TFA
 */
var TFA_TYPE;
(function (TFA_TYPE) {
    TFA_TYPE[TFA_TYPE["OTP"] = 17] = "OTP";
    TFA_TYPE[TFA_TYPE["X509"] = 18] = "X509";
})(TFA_TYPE || (exports.TFA_TYPE = TFA_TYPE = {}));
