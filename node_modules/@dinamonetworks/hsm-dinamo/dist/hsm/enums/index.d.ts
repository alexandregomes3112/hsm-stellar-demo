/**
 * @internal
 * Tipos de mensagens de log
 * @property {string} INFO Informação
 * @property {string} ERROR Erro
 * @property {string} WARN Aviso
 */
export declare enum MESSAGE_TYPES {
    INFO = "info",
    ERROR = "error",
    WARN = "warn"
}
/**
 * @internal
 * Tipos de mensagens de retorno do HSM
 * @property {string} HELO Handshake TCP efetuado com sucesso
 */
export declare const AAP_HSM_RETURNS: {
    HELO: string;
};
/**
 * Chaves Simétricas
 * @property {number} ALG_DES DES de 56 bits e com paridade impar.
 * @property {number} ALG_3DES_112 3DES-EDE (Encrypt-Decrypt-Encrypt) de 112 bits e com paridade impar.
 * @property {number} ALG_3DES_168 3DES-EDE (Encrypt-Decrypt-Encrypt) de 168 bits e com paridade impar.
 * @property {number} ALG_DESX DESX de 192 bits. O tamanho efetivo é de 118 bits.
 * @property {number} ALG_ARC4 ARC4 com 128 bits.
 * @property {number} ALG_ARC5 ARC5 com 128 bits, bloco de 8 bytes e utilizando 16 rounds.
 * @property {number} ALG_AES_128 AES com 128 bits.
 * @property {number} ALG_AES_192 AES com 192 bits.
 * @property {number} ALG_AES_256 AES com 256 bits.
 */
export declare enum SYMMETRICAL_KEYS {
    ALG_DES = 1,
    ALG_3DES_112 = 2,
    ALG_3DES_168 = 3,
    ALG_DESX = 91,
    ALG_ARC4 = 10,
    ALG_ARC5 = 89,
    ALG_AES_128 = 7,
    ALG_AES_192 = 8,
    ALG_AES_256 = 9
}
/**
 * Chaves Assimétricas RSA
 * @property {number} ALG_RSA_512 Par de chaves RSA com módulo de 512 bits.
 * @property {number} ALG_RSA_1024 Par de chaves RSA com módulo de 1024 bits.
 * @property {number} ALG_RSA_2048 Par de chaves RSA com módulo de 2048 bits.
 * @property {number} ALG_RSA_4096 Par de chaves RSA com módulo de 4096 bits.
 * @property {number} ALG_RSA_1152 Par de chaves RSA com módulo de 1152 bits.
 * @property {number} ALG_RSA_1408 Par de chaves RSA com módulo de 1408 bits.
 * @property {number} ALG_RSA_1536 Par de chaves RSA com módulo de 1536 bits.
 * @property {number} ALG_RSA_1976 Par de chaves RSA com módulo de 1976 bits.
 * @property {number} ALG_RSA_1984 Par de chaves RSA com módulo de 1984 bits.
 * @property {number} ALG_RSA_8192 Par de chaves RSA com módulo de 8192 bits.
 * @property {number} ALG_RSA_2304 Par de chaves RSA com módulo de 2304 bits.
 * @property {number} ALG_RSA_2560 Par de chaves RSA com módulo de 2560 bits.
 * @property {number} ALG_RSA_2816 Par de chaves RSA com módulo de 2816 bits.
 * @property {number} ALG_RSA_3072 Par de chaves RSA com módulo de 3072 bits.
 */
export declare enum RSA_ASYMMETRIC_KEYS {
    ALG_RSA_512 = 4,
    ALG_RSA_1024 = 5,
    ALG_RSA_2048 = 6,
    ALG_RSA_4096 = 11,
    ALG_RSA_1152 = 121,
    ALG_RSA_1408 = 122,
    ALG_RSA_1536 = 131,
    ALG_RSA_1976 = 130,
    ALG_RSA_1984 = 123,
    ALG_RSA_8192 = 124,
    ALG_RSA_2304 = 126,
    ALG_RSA_2560 = 127,
    ALG_RSA_2816 = 128,
    ALG_RSA_3072 = 129
}
/**
 * Chaves Assimétricas ECC
 * @property {number} ALG_ECC_SECP112R1 curva SECG/WTLS sobre um corpo finito primo de 112 bits (verifiably random elliptic curve domain parameters).
 * @property {number} ALG_ECC_SECP112R2 curva SECG sobre um corpo finito primo de 112 bits (verifiably random elliptic curve domain parameters 2).
 * @property {number} ALG_ECC_SECP128R1 curva SECG sobre um corpo finito primo de 128 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP128R2 curva SECG sobre um corpo finito primo de 128 bits (verifiably random elliptic curve domain parameters 2).
 * @property {number} ALG_ECC_SECP160K1 curva SECG sobre um corpo finito primo de 160 bits (koblitz domain parameters ).
 * @property {number} ALG_ECC_SECP160R1 curva SECG sobre um corpo finito primo de 160 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP160R2 curva SECG/WTLS sobre um corpo finito primo de 160 bits (verifiably random elliptic curve domain parameters 2).
 * @property {number} ALG_ECC_SECP192K1 curva SECG sobre um corpo finito primo de 192 bits (koblitz domain parameters ).
 * @property {number} ALG_ECC_SECP192R1 curva SECG/X9.62/NIST sobre um corpo finito primo de 192 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP224K1 curva SECG sobre um corpo finito primo de 224 bits (koblitz domain parameters ).
 * @property {number} ALG_ECC_SECP224R1 curva SECG/NIST sobre um corpo finito primo de 224 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP256K1 curva SECG sobre um corpo finito primo de 256 bits (koblitz domain parameters ).
 * @property {number} ALG_ECC_SECP256R1 curva SECG/X9.62 sobre um corpo finito primo de 256 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP384R1 curva SECG/NIST sobre um corpo finito primo de 384 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_SECP521R1 curva SECG/NIST sobre um corpo finito primo de 521 bits (verifiably random elliptic curve domain parameters 1).
 * @property {number} ALG_ECC_X9_62_PRIME192V1 curva X9.62 sobre um corpo finito primo de 192 bits (version 1 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME192V2 curva X9.62 sobre um corpo finito primo de 192 bits (version 2 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME192V3 curva X9.62 sobre um corpo finito primo de 192 bits (version 3 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME239V1 curva X9.62 sobre um corpo finito primo de 239 bits (version 1 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME239V2 curva X9.62 sobre um corpo finito primo de 239 bits (version 2 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME239V3 curva X9.62 sobre um corpo finito primo de 239 bits (version 3 domain parameters).
 * @property {number} ALG_ECC_X9_62_PRIME256V1 curva X9.62 sobre um corpo finito primo de 256 bits (version 1 domain parameters).
 * @property {number} ALG_ECC_BRAINPOOL_P160R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 160 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P160T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 160 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P192R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 192 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P192T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 192 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P224R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 224 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P224T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 224 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P256R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 256 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P256T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 256 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P320R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 320 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P320T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 320 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P384R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 384 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P384T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 384 bits (twisted domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P512R1 curva Brainpool RFC 5639 sobre um corpo finito primo de 512 bits (verifiably random domain parameters 1)
 * @property {number} ALG_ECC_BRAINPOOL_P512T1 curva Brainpool RFC 5639 sobre um corpo finito primo de 512 bits (twisted domain parameters 1)
 */
export declare enum ECC_ASYMMETRIC_SWITCHES {
    ALG_ECC_SECP112R1 = 18,
    ALG_ECC_SECP112R2 = 19,
    ALG_ECC_SECP128R1 = 20,
    ALG_ECC_SECP128R2 = 21,
    ALG_ECC_SECP160K1 = 22,
    ALG_ECC_SECP160R1 = 23,
    ALG_ECC_SECP160R2 = 24,
    ALG_ECC_SECP192K1 = 25,
    ALG_ECC_SECP192R1 = 26,
    ALG_ECC_SECP224K1 = 27,
    ALG_ECC_SECP224R1 = 28,
    ALG_ECC_SECP256K1 = 29,
    ALG_ECC_SECP256R1 = 30,
    ALG_ECC_SECP384R1 = 31,
    ALG_ECC_SECP521R1 = 32,
    ALG_ECC_X9_62_PRIME192V1 = 26,
    ALG_ECC_X9_62_PRIME192V2 = 33,
    ALG_ECC_X9_62_PRIME192V3 = 34,
    ALG_ECC_X9_62_PRIME239V1 = 35,
    ALG_ECC_X9_62_PRIME239V2 = 36,
    ALG_ECC_X9_62_PRIME239V3 = 37,
    ALG_ECC_X9_62_PRIME256V1 = 30,
    ALG_ECC_BRAINPOOL_P160R1 = 38,
    ALG_ECC_BRAINPOOL_P160T1 = 39,
    ALG_ECC_BRAINPOOL_P192R1 = 40,
    ALG_ECC_BRAINPOOL_P192T1 = 41,
    ALG_ECC_BRAINPOOL_P224R1 = 42,
    ALG_ECC_BRAINPOOL_P224T1 = 43,
    ALG_ECC_BRAINPOOL_P256R1 = 44,
    ALG_ECC_BRAINPOOL_P256T1 = 45,
    ALG_ECC_BRAINPOOL_P320R1 = 46,
    ALG_ECC_BRAINPOOL_P320T1 = 47,
    ALG_ECC_BRAINPOOL_P384R1 = 48,
    ALG_ECC_BRAINPOOL_P384T1 = 49,
    ALG_ECC_BRAINPOOL_P512R1 = 50,
    ALG_ECC_BRAINPOOL_P512T1 = 51
}
/**
 * Chaves Assimétricas ECX
 * @property {number} ALG_ECX_ED25519 curva RFC 8032(apenas assinatura) sobre um corpo finito primo de ~256 bits.
 * @property {number} ALG_ECX_ED448 curva RFC 8032(apenas assinatura) sobre um corpo finito primo de ~448 bits.
 * @property {number} ALG_ECX_X25519 curva RFC 7748(apenas key-agreement) sobre um corpo finito primo de ~256 bits.
 * @property {number} ALG_ECX_X448 curva RFC 7748(apenas key-agreement) sobre um corpo finito primo de ~448 bits.
 */
export declare enum ECX_ASYMMETRIC_SWITCHES {
    ALG_ECX_ED25519 = 201,
    ALG_ECX_ED448 = 202,
    ALG_ECX_X25519 = 203,
    ALG_ECX_X448 = 204
}
/**
 * Chaves HMAC
 * @property {number} ALG_HMAC_MD5 Chave HMAC MD5 com tamanho de 16 bytes.
 * @property {number} ALG_HMAC_SHA1 Chave HMAC SHA1 com tamanho de 20 bytes.
 * @property {number} ALG_HMAC_SHA2_256 Chave HMAC SHA2 256 com tamanho de 32 bytes.
 * @property {number} ALG_HMAC_SHA2_384 Chave HMAC SHA2 384 com tamanho de 48 bytes.
 * @property {number} ALG_HMAC_SHA2_512 Chave HMAC SHA2 512 com tamanho de 64 bytes.
 */
export declare enum HMAC_KEYS {
    ALG_HMAC_MD5 = 92,
    ALG_HMAC_SHA1 = 93,
    ALG_HMAC_SHA2_256 = 94,
    ALG_HMAC_SHA2_384 = 95,
    ALG_HMAC_SHA2_512 = 96
}
/**
 * Chaves PBC (Pairing-Based Cryptography)
 * @property {number} ALT_BN128 Curva ALT BN128.
 */
export declare enum ECC_ASYMMETRIC_PBC_SWITCHES {
    ALT_BN128 = 2771
}
/**
 * Define o algoritmo associado ao contexto de hash.
 * Hash algorithms supported by create hash
 * @property {number} ALG_MD5 Algoritmo de hash MD5. *keyName* deve ser NULL.
 * @property {number} ALG_SHA1 Algoritmo de hash SHA1. *keyName* deve ser NULL.
 * @property {number} ALG_SSL_SHA1_MD5 Hash para autenticação de cliente em SSLv3. *keyName* deve ser NULL.
 * @property {number} ALG_SHA2_224 Algoritmo de hash SHA2 - 224. *keyName* deve ser NULL.
 * @property {number} ALG_SHA2_256 Algoritmo de hash SHA2 - 256. *keyName* deve ser NULL.
 * @property {number} ALG_SHA2_384 Algoritmo de hash SHA2 - 384. *keyName* deve ser NULL.
 * @property {number} ALG_SHA2_512 Algoritmo de hash SHA2 - 512. *keyName* deve ser NULL.
 * @property {number} ALG_SHA3_224 Algoritmo de hash SHA3 - 224. *keyName* deve ser NULL.
 * @property {number} ALG_SHA3_256 Algoritmo de hash SHA3 - 256. *keyName* deve ser NULL.
 * @property {number} ALG_SHA3_384 Algoritmo de hash SHA3 - 384. *keyName* deve ser NULL.
 * @property {number} ALG_SHA3_512 Algoritmo de hash SHA3 - 512. *keyName* deve ser NULL.
 * @property {number} ALG_HMAC_MD5 Algoritmo HMAC MD5. *keyName* deve ser o contexto para a chave utilizada no HMAC.
 * @property {number} ALG_HMAC_SHA1 Algoritmo HMAC SHA1. *keyName* deve ser o contexto para a chave utilizada no HMAC.
 * @property {number} ALG_HMAC_SHA2_256 Algoritmo HMAC SHA2 - 256. *keyName* deve ser o contexto para a chave utilizada no HMAC.
 * @property {number} ALG_HMAC_SHA2_384 Algoritmo HMAC SHA2 - 384. *keyName* deve ser o contexto para a chave utilizada no HMAC.
 * @property {number} ALG_HMAC_SHA2_512 Algoritmo HMAC SHA2 - 512. *keyName* deve ser o contexto para a chave utilizada no HMAC.
 * @property {number} ALG_CMAC_DES Algoritmo CMAC 3DES. *keyName* deve ser o contexto para a chave 3DES utilizada no CMAC.
 * @property {number} ALG_CMAC_AES Algoritmo CMAC AES. *keyName* deve ser o contexto para a chave AES utilizada no CMAC.
 * @property {number} ALG_IDENTITY_FUNC Função identidade. Os dados de entrada são iguais aos dados de saída. *keyName* NULL.
 */
export declare enum HASH_ALGORITHMS {
    ALG_MD5 = 1,
    ALG_SHA1 = 2,
    ALG_SSL_SHA1_MD5 = 3,
    ALG_SHA2_224 = 7,
    ALG_SHA2_256 = 4,
    ALG_SHA2_384 = 5,
    ALG_SHA2_512 = 6,
    ALG_SHA3_224 = 8,
    ALG_SHA3_256 = 9,
    ALG_SHA3_384 = 10,
    ALG_SHA3_512 = 11,
    ALG_HMAC_MD5 = 92,
    ALG_HMAC_SHA1 = 93,
    ALG_HMAC_SHA2_256 = 94,
    ALG_HMAC_SHA2_384 = 95,
    ALG_HMAC_SHA2_512 = 96,
    ALG_CMAC_DES = 251,
    ALG_CMAC_AES = 250,
    ALG_IDENTITY_FUNC = 255
}
/**
 * Tamanho de hashs gerados
 * @property {number} MAX_HASH_LEN tamanho máximo para um hash gerado por função de hash
 */
export declare enum HASH_LEN {
    MAX_HASH_LEN = 64
}
/**
 * Tipos de máscaras para a geração de tokens.
 * @property {number} NONE Não utiliza máscaras para geração do token ou recuperação do secret.
 * @property {number} TOKEN Utiliza máscaras para geração do token.
 * @property {number} SECRET Utiliza máscaras para geração do secret.
 */
export declare enum MASK_TYPE {
    NONE = 0,
    TOKEN = 1,
    SECRET = 2
}
/**
 * Tipos de checksum para a geração de tokens.
 * @property {number} NULL Não faz geração de checksum. Apenas gera o token.
 * @property {number} CPF Gera os 2 dígitos verificadores no padrão CPF (Cadastro de Pessoas Físicas) no token. O secret deverá conter apenas números e incluir os dígitos verificadores.
 * @property {number} CNPJ Gera os 2 dígitos verificadores no padrão CNPJ (Cadastro Nacional da Pessoa Jurídica) no token. O secret deverá conter apenas números e incluir os dígitos verificadores.
 * @property {number} PAN Gera um PAN (Primary Account Number) com o dígito verificador válido no token. O secret deverá ser completo e conter apenas números.
 * @property {number} IEL Gera os 2 dígitos verificadores no padrão do número do título de eleitor no token. O secret deverá conter apenas números e incluir os dígitos verificadores.
 */
export declare enum CHECK_SUM_OPTIONS {
    NULL = 0,
    CPF = 1,
    CNPJ = 2,
    PAN = 3,
    IEL = 4
}
/**
 * Define a base de representação da string UTF-8 do secret para o FPE (Format-Preserving-Encryption). Pode ser uma das opções da tabela abaixo.
 * @property {number} BASE10 Apenas decimais.
 * @property {number} BASE62 Caracteres que são letras A-Z, a-z ou os números 0–9.
 */
export declare enum STR_FORMAT_PRESERVING_ENCRYPTION_OPTIONS {
    BASE10 = 10,
    BASE62 = 62
}
/**
 * Tipos de operações para obtenção de dados do token.
 * @property {number} SECRET Recupera o secret.
 * @property {number} TOKEN Recupera o token.
 */
export declare enum GET_TOKEN_DATA_OPTIONS {
    SECRET = 1,
    TOKEN = 2
}
/**
 * Tipos de geração da chave.
 * @property {number} BITCOIN_MINI_KEY Bitcoin minikey. Data deve ser NULL. Version deve ser NULL.
 * @property {number} BIP32_SEED_XPRV BIP32 seed XPrv. Data deve conter a estrutura DN_BCHAIN_BIP32_SEED_XPRV_DATA preenchida. Version deve ser NULL.
 * @property {number} BIP39_SEED_XPRV BIP39 seed XPrv. Data deve conter a estrutura DN_BCHAIN_BIP39_SEED_XPRV_DATA preenchida. Version deve ser NULL.
 * @property {number} BIP32_XPRV BIP32 XPrv. Data deve ser NULL. Version deve ser uma das opções de versão da chave.
 * @property {number} BIP32_ED25519_XPRV BIP32 Ed25519 XPrv. Data deve ser NULL. Version deve ser uma das opções de versão da chave.
 */
export declare enum BLOCKCHAIN_KEYS {
    BITCOIN_MINI_KEY = 1,
    BIP32_SEED_XPRV = 2,
    BIP39_SEED_XPRV = 3,
    BIP32_XPRV = 4,
    BIP32_ED25519_XPRV = 5
}
/**
 * Objects Attributes.
 * @property {number} EXPORTABLE_KEY Exportable key.
 * @property {number} TEMPORARY_KEY Temporary key.
 * @property {number} BCHAIN_KEY BChain keys: PBKs are handled specially.
 * @property {number} TSP TSP keys: don't replicate, export, backup.
 * @property {number} OATH HOTP stuff, without ST's, with open secret.
 * @property {number} OATH_USE_TIME HOTP stuff, time-based
 * @property {number} PKCS11 PKCS#11 related information.
 * @property {number} RSA_PUB_EXP3 Fallback to problematic RSA small exponent.
 * @property {number} SPB Object related to SPB module.
 * @property {number} HSM_GEN set on HSM generated keys.
 */
export declare enum ATTRIBUTES_OPTIONS {
    OBJ_NOP = 0,
    BCHAIN_KEY = 16384,
    EXPORTABLE_KEY = 1,
    TEMPORARY_KEY = 4,
    OATH = 16,
    OATH_USE_TIME = 128,
    PKCS11 = 1024,
    RSA_PUB_EXP3 = 2048,
    SPB = 4096,
    HSM_GEN = 32768,
    TSP = 8192
}
/**
 * Opções de versão para a chave XPrv.
 * @property {number} BIP32_MAIN_NET Mainnet BIP32.
 * @property {number} BIP32_TEST_NET Testnet BIP32.
 * @property {number} BIP32_HTR_MAIN_NET Mainnet BIP32 Hathor.
 * @property {number} BIP32_HTR_TEST_NET Testnet BIP32 Hathor.
 * @property {number} BIP32_FPRV1 FPRV1.
 */
export declare enum VERSION_OPTIONS {
    BIP32_MAIN_NET = 128,
    BIP32_TEST_NET = 239,
    BIP32_HTR_MAIN_NET = 1,
    BIP32_HTR_TEST_NET = 2,
    BIP32_FPRV1 = 3
}
/**
 * Índice da chave que será derivada. Chaves non hardened usam índice de 0 a 231-1 e chaves hardened (irrestritamente seguras) usam índices de 231 a 232-1, como especificado no padrão BIP32. É altamente recomendado gerar chaves hardened.
 * @property {number} BASE Base para gerar índices hardened.
 */
export declare enum BCHAIN_SECURE_BIP32_INDEX {
    BASE = 2147483648
}
/**
 * Tipo do hash para geração da hash de dados.
 * @property {number} BTC_H160 Bitcoin H160.
 * @property {number} RIPEMD160 RIPEMD160.
 * @property {number} SHA256 SHA256
 * @property {number} BTC_SHA256_2X Bitcoin SHA256 2x.
 * @property {number} KECCAK256 KECCAK256.
 * @property {number} BLAKE2B224 BLAKE2B224.
 * @property {number} BLAKE2B256 BLAKE2B256.
 */
export declare enum BLOCKCHAIN_HASH_MODE {
    BTC_H160 = 1,
    RIPEMD160 = 2,
    SHA256 = 3,
    BTC_SHA256_2X = 4,
    KECCAK256 = 5,
    BLAKE2B224 = 6,
    BLAKE2B256 = 7
}
/**
 * Tipo da assinatura a ser gerada.
 * @property {number} SIG_PURE Assinatura EdDSA Pure.
 * @property {number} SIG_ALGORAND Assinatura EdDSA Algorand.
 * @property {number} SIG_XRP Assinatura EdDSA XRP.
 * @property {number} SIG_SOL Assinatura EdDSA Solana.
 * @property {number} EdDSA_SIG_XLM Assinatura EdDSA Stellar.
 * @property {number} EdDSA_SIG_ADA Assinatura EdDSA Cardano.
 * @property {number} EdDSA_SIG_DOT Assinatura EdDSA Polkadot.
 * @property {number} EdDSA_SIG_XTZ Assinatura EdDSA Tezos.
 * @property {number} EdDSA_SIG_XTZ_PH Assinatura EdDSA Tezos com hash.
 */
export declare enum BLOCKCHAIN_EdDSA_TYPE {
    SIG_PURE = 254,
    SIG_ALGORAND = 253,
    SIG_XRP = 252,
    SIG_SOL = 251,
    EdDSA_SIG_XLM = 250,
    EdDSA_SIG_ADA = 249,
    EdDSA_SIG_DOT = 248,
    EdDSA_SIG_XTZ = 247,
    EdDSA_SIG_XTZ_PH = 246
}
/**
 * Formato da chave pública.
 * @property {number} ED25519 Ed25519.
 * @property {number} AT_ALGORAND Algorand.
 * @property {number} BIP32_XPUB BIP32 XPub.
 * @property {number} AT_SOL Solana.
 */
export declare enum BLOCKCHAIN_PUB_KEY_TYPE {
    ED25519 = 4,
    AT_ALGORAND = 5,
    BIP32_XPUB = 6,
    AT_SOL = 7
}
/**
 * Tipo da assinatura a ser gerada.
 * @property {number} SIG_DER_ECDSA Assinatura DER, no formato v || DER. SECG!SEC1 strict DER com low S como descrito em BIP62/66, BIP146, EIP2. Tendo 'v' o tamanho de 1 byte. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1.
 * @property {number} SIG_RAW_ECDSA Assinatura RAW, no formato v || r || s. Tendo 'v' o tamanho de 1 byte e 'r' e 's' cada uma o tamanho de 32 bytes. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1.
 * @property {number} SIG_BIP340 Assinatura BIP340 - Schnorr 64 bytes.
 * @property {number} SIG_DER_RFC_6979_ECDSA Assinatura ECDSA determinística padrão RFC-6979. Tipo DER no formato v || DER, tendo 'v' o tamanho de 1 byte. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1
 * @property {number} SIG_RAW_RFC_6979_ECDSA Assinatura ECDSA determinística padrão RFC-6979. Tipo RAW no formato v || r || s, tendo 'v' o tamanho de 1 byte e 'r' e 's' cada uma o tamanho de 32 bytes. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1.
 */
export declare enum BLOCKCHAIN_SIG_TYPE {
    SIG_DER_ECDSA = 1,
    SIG_RAW_ECDSA = 2,
    SIG_BIP340 = 3,
    SIG_DER_RFC_6979_ECDSA = 4,
    SIG_RAW_RFC_6979_ECDSA = 5
}
/**
 * Opções de tipo do endereço.
 * @property {number} BTC_P2PKH Endereço P2PKH. Version deve ser BTC_A1_MAIN_NET, BTC_A3_MAIN_NET, BTC_AMN_TEST_NET, HTR_MAIN_NET ou HTR_TEST_NET. Hrp deve ser HRP_UNUSED.
 * @property {number} BTC_P2SH Endereço P2SH BIP13. Version deve ser BTC_A1_MAIN_NET, BTC_A3_MAIN_NET, BTC_AMN_TEST_NET, HTR_MAIN_NET ou HTR_TEST_NET. Hrp deve ser HRP_UNUSED. Pk deve ser o script-hash.
 * @property {number} BTC_B32_PKH Endereço BIP32 P2PKH BIP173. Version deve ser BTC_B32_WITVER. Hrp pode ser BTC_MAIN_NET ou BTC_TEST_NET.
 * @property {number} BTC_B32_SH Endereço BIP32 P2SH. Version deve ser BTC_A1_MAIN_NET, BTC_A3_MAIN_NET, BTC_AMN_TEST_NET, HTR_MAIN_NET ou HTR_TEST_NET. Hrp deve ser HRP_UNUSED. Pk deve ser o script-hash.
 * @property {number} ETH_EOA Endereço ETH EOA. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} ETH_EOA_MC_CKS Endereço ETH EOA MC CKS. EIP55. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} ETH_EOA_ICAP Endereço ETH EOA ICAP. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} ALGORAND Endereço Algorand. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} TRON_HEX Endereço TRON hexadecimal. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} TRON_B58 Endereço TRON Base 58. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} XRP Endereço XRP Ledger/Ripple. Version deve ser VER_XRP_CLASSIC. Hrp deve ser HRP_UNUSED.
 * @property {number} SOL Endereço Solana. Version deve ser VER_UNUSED. Hrp deve ser HRP_UNUSED.
 * @property {number} XLM Endereço Stellar.
 * @property {number} ADA_PKH Endereço Cardano.
 * @property {number} ADA_SH Endereço Cardano.
 * @property {number} LUNC Endereço Terra Classic.
 * @property {number} SS58
 * @property {number} XTZ Endereço Tezos.
 * @property {number} TON Endereço Toncoin.
 * @property {number} TON_SH Endereço Toncoin.
 * @property {number} LTC_P2PKH Endereço Litecoin P2PKH.
 * @property {number} LTC_P2SH Endereço Litecoin P2SH.
 * @property {number} LTC_B32_PKH Endereço Litecoin BIP32 P2PKH.
 * @property {number} LTC_B32_SH Endereço Litecoin BIP32 P2SH.
 * @property {number} ATOM Endereço Cosmos (ATOM).
 * @property {number} BTC_P2TR Endereço Bitcoin P2TR BIP350. Version deve ser BTC_SEGWIT1. Hrp deve ser BTC_MAINNET ou BTC_TESTNET.
 */
export declare enum ADDRESS_TYPE {
    BTC_P2PKH = 1,
    BTC_P2SH = 2,
    BTC_B32_PKH = 3,
    BTC_B32_SH = 4,
    ETH_EOA = 5,
    ETH_EOA_MC_CKS = 6,
    ETH_EOA_ICAP = 7,
    ALGORAND = 8,
    TRON_HEX = 9,
    TRON_B58 = 10,
    XRP = 11,
    SOL = 12,
    XLM = 13,
    ADA_PKH = 14,
    ADA_SH = 15,
    LUNC = 16,
    SS58 = 17,
    XTZ = 18,
    TON = 19,
    TON_SH = 20,
    ATOM = 21,
    BTC_P2TR = 22,
    LTC_P2PKH = 1,
    LTC_P2SH = 2,
    LTC_B32_PKH = 3,
    LTC_B32_SH = 4,
    LTC_P2TR = 22
}
/**
 * Opções de versão do endereço.
 * @property {number} UNUSED Parâmetro não utilizado.
 * @property {number} BTC_A1_MAIN_NET Bitcoin A1 mainnet.
 * @property {number} BTC_AMN_TEST_NET Bitcoin P2PKH testnet.
 * @property {number} BTC_A3_MAIN_NET Bitcoin A3 mainnet.
 * @property {number} BTC_SEGWIT0 Bitcoin Segwit v0.
 * @property {number} BTC_SEGWIT1 Bitcoin Segwit v1.
 * @property {number} HTR_MAIN_NET Hathor mainnet.
 * @property {number} HTR_TEST_NET Hathor testnet.
 * @property {number} HTR_P2SH_MAIN_NET Hathor P2PSH main net.
 * @property {number} HTR_P2SH_TEST_NET Hathor P2PSH testnet.
 * @property {number} XRP_CLASSIC XRP Ledger/Ripple Classic.
 * @property {number} LTC_SEGWIT0 Litecoin Segwit v0.
 * @property {number} LTC_SEGWIT1 Litecoin Segwit v1.
 * @property {number} LTC_AL_MAIN_NET
 * @property {number} LTC_Amn_TEST_NET Litecoin P2PKH testnet.
 * @property {number} LTC_AM_MAIN_NET Litecoin main net.
 * @property {number} LTC_AQ_TEST_NET Litecoin test net.
 * @property {number} ADA_MAIN_NET Cardano main net.
 * @property {number} ADA_TEST_NET Cardano test net.
 * @property {number} SS58_POLKADOT
 * @property {number} SS58_GEN_SUBST
 * @property {number} TON_MN_BWORK Toncoin main net basic workchain.
 * @property {number} TON_MN_MCHAIN Toncoin main net masterchain.
 * @property {number} TON_TN_BWORK Toncoin test net basic workchain.
 * @property {number} TON_TN_MCHAIN Toncoin test net masterchain.
 */
export declare enum ADDRESS_VERSION {
    UNUSED = 0,
    BTC_A1_MAIN_NET = 0,
    BTC_AMN_TEST_NET = 111,
    BTC_A3_MAIN_NET = 5,
    BTC_SEGWIT0 = 0,
    BTC_SEGWIT1 = 1,
    HTR_MAIN_NET = 40,
    HTR_TEST_NET = 73,
    HTR_P2SH_MAIN_NET = 100,
    HTR_P2SH_TEST_NET = 135,
    XRP_CLASSIC = 0,
    LTC_SEGWIT0 = 0,
    LTC_SEGWIT1 = 1,
    LTC_AL_MAIN_NET = 48,
    LTC_Amn_TEST_NET = 111,
    LTC_AM_MAIN_NET = 50,
    LTC_AQ_TEST_NET = 58,
    ADA_MAIN_NET = 1,
    ADA_TEST_NET = 0,
    SS58_POLKADOT = 0,
    SS58_GEN_SUBST = 42,
    TON_MN_BWORK = 1,
    TON_MN_MCHAIN = 2,
    TON_TN_BWORK = 3,
    TON_TN_MCHAIN = 4
}
/**
 * Opções de HRP (Human Readable Part).
 * @property {string} UNUSED Parâmetro não utilizado.
 * @property {string} BTC_MAIN_NET Bitcoin main net.
 * @property {string} BTC_TEST_NET Bitcoin test net.
 * @property {string} BTC_REGTEST_NET Bitcoin regtest net.
 * @property {string} LTC_MAIN_NET Litecoin main net.
 * @property {string} LTC_TEST_NET Litecoin test net.
 * @property {string} TON_BNCBLE Toncoin bounceable.
 * @property {string} TON_NBNCBLE Toncoin non-bounceable.
 */
export declare enum ADDRESS_HRP {
    UNUSED = "",
    BTC_MAIN_NET = "bc",
    BTC_TEST_NET = "tb",
    BTC_REGTEST_NET = "bcrt",
    LTC_MAIN_NET = "ltc",
    LTC_TEST_NET = "tltc",
    TON_BNCBLE = "bounceable",
    TON_NBNCBLE = "non-bounceable"
}
/**
 * Formato da chave pública a ser exportada.
 * @property {number} SEC1_UNCOMP ECDSA SEC1 não comprimida.
 * @property {number} SEC1_COMP ECDSA SEC1 comprimida.
 * @property {number} BIP340 Schnorr, BIP-340.
 * @property {number} ED25519 Ed25519.
 * @property {number} AT_ALGORAND Algorand.
 * @property {number} BIP32_XPUB BIP32 XPub.
 * @property {number} AT_SOL Solana.
 * @property {number} AT_XLM Stellar.
 * @property {number} ADA_VK Cardano.
 * @property {number} AT_SS58 SS58.
 * @property {number} TON Toncoin.
 * @property {number} E_UNCOMP SEC1_UNCOMP com o prefixo 0x04 removido; alt_bn128 (EIPs 196/197) apenas.
 */
export declare enum BLOCKCHAIN_GET_PUB_KEY_TYPE {
    SEC1_UNCOMP = 1,
    SEC1_COMP = 2,
    BIP340 = 3,
    ED25519 = 4,
    AT_ALGORAND = 5,
    BIP32_XPUB = 6,
    AT_SOL = 7,
    AT_XLM = 8,
    ADA_VK = 9,
    AT_SS58 = 10,
    TON = 11,
    E_UNCOMP = 12
}
/**
 * Formato da chave pública para verificação da assinatura.
 * @property {number} SEC1_UNCOMP ECDSA SEC1 não comprimida.
 * @property {number} SEC1_COMP ECDSA SEC1 comprimida.
 * @property {number} BIP340 Schnorr, BIP-340.
 * @property {number} ED25519 Ed25519.
 */
export declare enum BLOCKCHAIN_SIG_VERIFY_PUB_KEY_TYPE {
    SEC1_UNCOMP = 1,//	ECDSA SEC1 não comprimida.
    SEC1_COMP = 2,//	ECDSA SEC1 comprimida.
    BIP340 = 3,//	Schnorr, BIP-340.
    ED25519 = 4
}
/**
 * Tipo da assinatura a ser gerada.
 * @property {number} DER_ECDSA Assinatura DER, no formato v || DER. SECG!SEC1 strict DER com low S como descrito em BIP62/66, BIP146, EIP2. Tendo 'v' o tamanho de 1 byte. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1.
 * @property {number} RAW_ECDSA Assinatura RAW, no formato v || r || s. Tendo 'v' o tamanho de 1 byte e 'r' e 's' cada uma o tamanho de 32 bytes. 'v' é o bit de paridade de 'r' podendo ter os valores 0 ou 1.
 */
export declare enum BLOCKCHAIN_PUB_SIG_REC_TYPE {
    DER_ECDSA = 1,
    RAW_ECDSA = 2
}
/**
 * Formato da chave a ser importada.
 * @property {number} WIF Wallet Import Format (WIF).
 * @property {number} MINI Bitcoin minikey.
 * @property {number} HEX Escalar da chave privada em hexadecimal. Importada como uma chave do tipo {@link enums.ECC_ASYMMETRIC_SWITCHES.ALG_ECC_SECP256K1}.
 * @property {number} SEC1 SEC1.
 * @property {number} XPRIV XPriv.
 * @property {number} ED25529_B64 Ed25519 no formato Base 64.
 * @property {number} ED25529_XPRIV Ed25519 no formato XPriv.
 * @property {number} Ed25519_SKPK Ed25519 no formato SKPK.
 * @property {number} Ed25519_SK Ed25519 no formato SK.
 */
export declare enum IMPORT_EXPORT_FORMAT {
    WIF = 1,
    MINI = 2,
    HEX = 3,
    SEC1 = 4,
    XPRIV = 5,
    ED25529_B64 = 6,
    ED25529_XPRIV = 7,
    Ed25519_SKPK = 8,
    Ed25519_SK = 9,
    Ed25519_XTZ = 10
}
/**
 * Versão da chave.
 * @property {number} UNUSED Parâmetro não utilizado.
 * @property {number} WIF_MAIN_NET WIF main net.
 * @property {number} WIF_TEST_NET WIF test net.
 * @property {number} WIF_LTC_MAIN_NET WIF LTC main net.
 */
export declare enum BLOCKCHAIN_EXPORT_VERSION {
    UNUSED = 0,
    WIF_MAIN_NET = 128,
    WIF_TEST_NET = 239,
    WIF_LTC_MAIN_NET = 176
}
/**
 * Padding da assinatura.
 * @property {number} PKCS1_V1_5 PKCS#1 v1.5.
 * @property {number} PSS PSS.
 * @property {number} X931 X9.31.
 */
export declare enum PAD_TYPE {
    PKCS1_V1_5 = 2,
    PSS = 3,
    X931 = 4
}
/**
 * Permissões do usuário.
 * @property {number} NOP Usuário apenas com autorizações ordinárias.
 *
 * @property {number} OBJ_CREATE Permissão para criar objetos. A permissão de leitura (OBJ_READ) é atribuída implicitamente.
 * @property {number} OBJ_DEL Permissão para remover objetos. A permissão de leitura (OBJ_READ) é atribuída implicitamente.
 * @property {number} OBJ_READ Permissão para ler o conteúdo de objetos.
 * @property {number} OBJ_UPDATE Permissão para atualizar atributos dos objetos. OBJ_UPDATE = OBJ_WRITE
 * @property {number} OBJ_WRITE Permissão para atualizar atributos dos objetos. OBJ_UPDATE = OBJ_WRITE
 *
 * @property {number} USR_LIST Permissão para listar usuários.
 * @property {number} USR_CREATE Permissão para criar e remover usuários. USR_CREATE = USR_DELETE
 * @property {number} USR_DELETE Permissão para criar e remover usuários. USR_CREATE = USR_DELETE
 * @property {number} USR_REMOTE_LOG Permissão para receber notificações de log remota.
 *
 * @property {number} SYS_OPERATOR Permissão para operar como o usuário ‘master’.
 * @property {number} SYS_BACKUP Permissão para criar e restaurar cópias de segurança dos dados do HSM. SYS_BACKUP = SYS_RESTORE
 * @property {number} SYS_RESTORE Permissão para criar e restaurar cópias de segurança dos dados do HSM. SYS_BACKUP = SYS_RESTORE
 * @property {number} SYS_UDATE_HSM Permissão para atualizar o firmware.
 */
export declare enum USER_PERMISSIONS {
    NOP = 0,
    OBJ_DEL = 1,
    OBJ_READ = 2,
    OBJ_CREATE = 4,
    OBJ_LIST = 2,
    OBJ_UPDATE = 8,
    OBJ_WRITE = 8,
    USR_CREATE = 16,
    USR_DELETE = 16,
    USR_REMOTE_LOG = 32,
    USR_LIST = 64,
    SYS_OPERATOR = 128,
    SYS_BACKUP = 256,
    SYS_RESTORE = 256,
    SYS_UDATE_HSM = 512,
    NS_AUTHORIZATION = 1024,
    COLD_PRT = 2048,
    VIRTUAL_OTP_AUTH = 536870912,
    VIRTUAL_X509_AUTH = 268435456,
    CHANGE_PWD_NEXT_TIME = 1073741824
}
/**
 * Formatos das chaves a serem exportadas.
 * @property {number} PRIVATE_KEY_BLOB_STRICT Será exportado um par de chaves RSA ou EC no formato PRIVATE_KEY_BLOB.
 * hKEKey deve ser o contexto de uma chave simétrica, uma chave pública(interna ao HSM ver PUBLIC_KEY_BLOB_HSM) ou ainda NULL.
 * Os seguintes formatos são aceitos.
 * Para RSA: Chave privada (que contém as informações de módulo e expoente público), definido na PKCS#1 v1.5 seção 7.2.
 * Para chaves ECC devem ter o formato ECPrivateKey descrito na RFC 5915.
 * Para chaves ECX(EdDSA e XECDH) o formato é o descrito na RFC 8410.
 * @property {number} PRIVATE_KEY_BLOB Mesmo comportamento de PRIVATE_KEY_BLOB_STRICT mas em versões antigas de HSM pode retornar chaves RSA como uma concatenação de chave privada e chave pública nos formatos definidos no PKCS#1 v1.5, nas seções 7.1 e 7.2. Esta opção é mantida por compatibilidade. Utilizar PRIVATE_KEY_BLOB_STRICT.
 * @property {number} PRIVATE_KEY_BLOB_P8 Será importado um par de chaves RSA no formato PRIVATE_KEY_BLOB_P8.
 * hKEKey deve ser o contexto de uma chave de simétrica.
 * O formato do blob da chave é o PrivateKeyInfo definido no PKCS#8.
 * @property {number} PUBLIC_KEY_BLOB Será exportada uma chave pública de um par de chaves RSA ou EC no formato PUBLIC_KEY_BLOB.hKEKey deve ser igual a NULL. O contexto retornado pela exportação de chave pública deve ser utilizado apenas nas operações de envelope digital, pois o HSM não cria de forma persistente objetos RSA com apenas a parte pública da chave seguindo o padrão PKCS#1 v2.2 formato DER.Para chaves públicas EC (ECC e ECX) o padrão é o SubjectPublicKeyInfo formato DER.
 * @property {number} SIMPLE_BLOB Será exportada uma chave simétrica no formato SIMPLE_BLOB.hKEKey deve ser o contexto de uma chave privada associada à chave pública usada para criptografar o blob a ser importado.O tipo do padding usado para criptografia da chave deve ser 2, como definido no PKCS#1 v1.5 seção 8.1.
 * @property {number} PLAINTEXT_KEY_BLOB Será exportada uma chave simétrica ou HMAC em claro.Essa flag ainda não é suportada para chaves RSA.
 * @property {number} SIMPLE_BLOB_OAEP Define a exportação através de envelope digital usando o padrão PKCS#1 versão 2.1, com esquema de cifragem RSAES-OAEP. A KEK deverá ser uma chave privada no HSM, cuja chave pública correspondente foi utilizada na criação do envelope. O contexto para esta KEK pode ser obtido via uma chamada à DGetUserKey, onde será informado o id da chave RSA do HSM usada para abrir o envelope. Este método de exportação pode ser utilizado nos modos de operação restritos.
 * @property {number} SYM_WRAPPED_KEY_BLOB Define uma chave simétrica encriptada por uma KEK (Key Encryption Key) também simétrica.O parâmetro hKEKey deverá conter o contexto de uma chave simétrica com os devidos parâmetros de utilização já definidos, como modo e padding.A chave será decriptada e importada para a base do HSM diretamente, sem formatação específica.
 * @property {number} HOTP_BLOB Define a importação de um objeto tipo HTOP para a partição do usuário.
 * @property {number} PUBLIC_KEY_BLOB_HSM Será importada uma chave pública de um par de chaves RSA/ECC no formato DER para dentro do HSM. hKEKey deve ser igual a NULL.
 * @property {number} PUBLIC_KEY_RSA_PARTS_HSM Será importada uma chave pública, a partir do módulo e do expoente público, para dentro do HSM. hKEKey deve ser igual a NULL. Deve ser passado em pbData a estrutura RSA_PUB_KEY_PARTS devidamente preenchida.
 * @property {number} WRAPPED_KEY_BLOB Importa uma chave encriptada por uma KEK (Key Encryption Key).O parâmetro hKEKey deverá conter o contexto de uma chave simétrica com os devidos parâmetros de utilização já definidos, como modo(de acordo com o algoritmo) e padding. A chave será decriptada e importada para a base do HSM diretamente, sem formatação específica.
 * @property {number} WRAPPED_KEY_BLOB_P8 Importa uma chave encriptada por uma KEK (Key Encryption Key).O parâmetro hKEKey deverá conter o contexto de uma chave simétrica com os devidos parâmetros de utilização já definidos, como modo(de acordo com o algoritmo) e padding. A chave será decriptada e importada para a base do HSM diretamente, sem formatação específica. Na operação de exportação de chave o formato da chave privada será PKCS#8.
 */
export declare enum KEY_EXPORT_FORMAT {
    PRIVATE_KEY_BLOB_STRICT = 14,
    PRIVATE_KEY_BLOB = 1,
    PRIVATE_KEY_BLOB_P8 = 13,
    PUBLIC_KEY_BLOB = 2,
    SIMPLE_BLOB = 3,
    PLAINTEXT_KEY_BLOB = 4,
    SIMPLE_BLOB_OAEP = 7,
    SYM_WRAPPED_KEY_BLOB = 9,
    HOTP_BLOB = 6,
    PUBLIC_KEY_BLOB_HSM = 11,
    PUBLIC_KEY_RSA_PARTS_HSM = 12,
    WRAPPED_KEY_BLOB = 16,
    WRAPPED_KEY_BLOB_P8 = 18
}
/**
 * Algoritmos de hash para assinatura do CSR.
 */
export declare enum PKCS10_HASH_ALGORITHM {
    SHA1 = 1,
    SHA224 = 2,
    SHA256 = 3,
    SHA384 = 4,
    SHA512 = 5,
    SHA3_224 = 6,
    SHA3_256 = 7,
    SHA3_384 = 8,
    SHA3_512 = 9
}
/**
 * Opções de padding para operação de KEK.
 * @property {number} UNUSED_PAD Padding não utilizado.
 * @property {number} P5_PAD Padding P5.
 * @property {number} 0_PAD Padding 0.
 * @property {number} OAEP_PAD Padding OAEP com SHA1.
 * @property {number} P1_PAD Padding P1.
 * @property {number} OAEP2_PAD Padding OAEP com SHA256.
 */
export declare enum KEK_WRAP_PADDING {
    UNUSED_PAD = 0,
    P5_PAD = 1,
    _0_PAD = 2,
    OAEP_PAD = 3,
    P1_PAD = 4,
    OAEP2_PAD = 5
}
/**
 * Modo suportado pela operação de KEK.
 * @property {number} UNUSED_MODE Modo não utilizado.
 */
export declare enum KEK_WRAP_MODE {
    UNUSED_MODE = 0
}
/**
 * Classe pseudo obj_type suportada pela operação de KEK.
 * @property {number} T_P_RSA Tipo RSA.
 * @property {number} T_P_ECC Tipo ECC.
 * @property {number} T_P8 Tipo P8.
 * @property {number} T_P_ECX Tipo ECX.
 * @property {number} T_P_DSA Tipo DSA.
 * @property {number} T_P_DH Tipo DH.
 */
export declare enum KEK_WRAP_OBJ_TYPE {
    T_P_RSA = 4294967265,
    T_P_ECC = 4294967264,
    T_P8 = 4294967263,
    T_P_ECX = 4294967262,
    T_P_DSA = 4294967261,
    T_P_DH = 4294967260
}
/**
 * Modo KEK.
 * @property {number} MODE_CBC Modo de Cifra de Bloco em Cadeia (CBC).
 * @property {number} MODE_ECB Modo de Cifra de Bloco Eletrônico (ECB).
 */
export declare enum KEK_MODE {
    MODE_ECB = 1,
    MODE_CBC = 2
}
/**
 * Modo de preenchimento de criptografia e descriptografia.
 * @property {number} PKCS1 Preenchimento PKCS #1.
 * @property {number} OAEP_SHA1 Preenchimento OAEP com SHA-1.
 * @property {number} OAEP_SHA256 Preenchimento OAEP com SHA-256.
 */
export declare enum ENC_DEC_PADDING {
    PKCS1 = 1,
    OAEP_SHA1 = 2,
    OAEP_SHA256 = 3
}
/**
 * Tamanhos de chave RSA.
 * @property {number} RSA_512 Chave RSA de 512 bits.
 * @property {number} RSA_1024 Chave RSA de 1024 bits.
 * @property {number} RSA_2048 Chave RSA de 2048 bits.
 * @property {number} RSA_4096 Chave RSA de 4096 bits.
 * @property {number} RSA_1152 Chave RSA de 1152 bits.
 * @property {number} RSA_1408 Chave RSA de 1408 bits.
 * @property {number} RSA_1536 Chave RSA de 1536 bits.
 * @property {number} RSA_1976 Chave RSA de 1976 bits.
 * @property {number} RSA_1984 Chave RSA de 1984 bits.
 * @property {number} RSA_8192 Chave RSA de 8192 bits.
 * @property {number} RSA_2304 Chave RSA de 2304 bits.
 * @property {number} RSA_2560 Chave RSA de 2560 bits.
 * @property {number} RSA_2816 Chave RSA de 2816 bits.
 * @property {number} RSA_3072 Chave RSA de 3072 bits.
 */
export declare enum RSA_LENGTH_KEYS {
    RSA_512 = 64,
    RSA_1024 = 128,
    RSA_2048 = 256,
    RSA_4096 = 512,
    RSA_1152 = 144,
    RSA_1408 = 176,
    RSA_1536 = 192,
    RSA_1976 = 247,
    RSA_1984 = 248,
    RSA_8192 = 1024,
    RSA_2304 = 288,
    RSA_2560 = 320,
    RSA_2816 = 352,
    RSA_3072 = 384
}
/**
 * Tipo da chave utilizada para a função OCRA
 * @property {number} MOD_OATH_OCRA_USE_PH20 indica o uso da função SHA1
 * @property {number} MOD_OATH_OCRA_USE_PH32 indica o uso da função SHA256
 * @property {number} MOD_OATH_OCRA_USE_PH64 indica o uso da função SHA512
 */
export declare enum OCRA_PIN_HASH_TYPE {
    MOD_OATH_OCRA_USE_PH20 = 2,
    MOD_OATH_OCRA_USE_PH32 = 4,
    MOD_OATH_OCRA_USE_PH64 = 8
}
/**
 * Modos de preenchimento OCRA
 * @property {number} MOD_OATH_OCRA_USE_CTR indica o uso de um contador para a função OCRA
 * @property {number} MOD_OATH_OCRA_USE_TS indica o uso de um timestamp para a função OCRA
 */
export declare enum OCRA_MODE {
    MOD_OATH_OCRA_USE_CTR = 1,
    MOD_OATH_OCRA_USE_TS = 16
}
/**
 * Tamanhos de variáveis no payload OCRA
 * @property {number} MOD_OATH_OCRA_MAX_SUITE_LEN tamanho máximo para o ocraSuite
 * @property {number} MOD_OATH_OCRA_CTR_LEN tamanho máximo para o contador
 * @property {number} MOD_OATH_OCRA_MAX_Q_LEN tamanho máximo para o challenger
 * @property {number} MOD_OATH_OCRA_CSESS_MAX_LEN tamanho máximo para dados de sessão
 * @property {number} MOD_OATH_OCRA_TIME_STEPS_LEN tamanho máximo para o timestamp
 */
export declare enum OCRA_MODE_LEN {
    MOD_OATH_OCRA_MAX_SUITE_LEN = 128,
    MOD_OATH_OCRA_CTR_LEN = 8,
    MOD_OATH_OCRA_MAX_Q_LEN = 128,
    MOD_OATH_OCRA_CSESS_MAX_LEN = 512,
    MOD_OATH_OCRA_TIME_STEPS_LEN = 8
}
/**
 * Tamanhos de variáveis MOD_OATH_OTP
 * @property {number} MOD_OATH_MIN_OTP_LEN Menor tamanho possível para um PIN HASH OTP
 * @property {number} MOD_OATH_LOOKAHEAD_WND Tamanho máximo para o look-ahead window.
 * @property {number} MOD_OATH_MAX_OTP_LEN Maior tamanho possível para um PIN HASH OTP
 */
export declare enum MOD_OATH_OTP {
    MOD_OATH_MIN_OTP_LEN = 6,
    MOD_OATH_LOOKAHEAD_WND = 10,
    MOD_OATH_MAX_OTP_LEN = 16
}
/**
 * @internal
 * Status de resposta do Dinamo Native Host
 * @property {number} STATUS_SUCCESS Indica que a operação foi bem-sucedida.
 * @property {number} STATUS_ERROR Indica que ocorreu um erro na operação.
 * @property {number} STATUS_UNKNOWN_COMMAND Indica que o comando enviado é desconhecido.
 * @property {number} STATUS_CLOSING Indica que o Native Host está fechando.
 */
export declare enum NH_RESPONSE_STATUS {
    STATUS_SUCCESS = 0,
    STATUS_ERROR = 1,
    STATUS_UNKNOWN_COMMAND = 2,
    STATUS_CLOSING = 3
}
/**
 * Estados de autenticação NS (Network Security).
 * @property {number} ASSOCIATED Transição para o estado associado.
 * @property {number} RESET Transição para o estado nulo.
 * @property {number} AUTHORIZED Transição para o estado autorizado.
 * @property {number} EPHEMERAL_AUTH Transição para uma sessão online efêmera.
 * @property {number} CHECK Transição reflexiva, apenas para verificar o conjunto de shadow/share.
 */
export declare enum NSAUTH_STATE {
    ASSOCIATED = 1,
    RESET = 2,
    AUTHORIZED = 3,
    EPHEMERAL_AUTH = 4,
    CHECK = 5
}
/**
 * Tipos de Controle de Acesso (ACL).
 * @property {number} NOP Nenhuma permissão. Valor padrão.
 * @property {number} OBJ_DEL Permissão para deletar objetos.
 * @property {number} OBJ_READ Permissão para ler o conteúdo de objetos.
 * @property {number} OBJ_LIST Permissão para listar objetos de usuário.
 * @property {number} OBJ_CREATE Permissão para criar objetos.
 * @property {number} OBJ_UPDATE Permissão para atualizar objetos (cabeçalhos e similares).
 * @property {number} OBJ_WRITE Permissão para atualizar objetos (sinônimo de OBJ_UPDATE).
 * @property {number} USR_CREATE Permissão para criar usuários.
 * @property {number} USR_DELETE Permissão para deletar usuários. (Apenas a criação faz sentido.)
 * @property {number} USR_REMOTE_INFO Permissão para obter/definir informações remotas de usuários (logs, etc.).
 * @property {number} USR_LIST Permissão para obter a lista de usuários.
 * @property {number} SYS_OPERATOR Operar como mestre (modo administrador).
 * @property {number} SYS_BACKUP Permissão para extrair o backup completo do aparelho.
 * @property {number} SYS_RESTORE Permissão para restaurar o backup completo do aparelho.
 * @property {number} SYS_UPDATE_HSM Permissão para atualizar firmware e similares.
 * @property {number} NS_AUTHORIZATION Permissão para a autorização de usuário com "m de n".
 * @property {number} LOCAL_CRYPTO_PRT Permissão para realizar operações criptográficas de usuário localmente.
 * @property {number} VIRTUAL_X509_AUTH Permissão para usar autenticação PKI (2F PKI).
 * @property {number} VIRTUAL_OTP_AUTH Permissão para usar autenticação OTP (2F OTP).
 * @property {number} CHANGE_PWD_NEXT_TIME Permissão para forçar usuários a mudar a senha no próximo login.
 */
export declare enum ACL_MASK {
    NOP = 0,
    OBJ_DEL = 1,
    OBJ_READ = 2,
    OBJ_LIST = 2,
    OBJ_CREATE = 4,
    OBJ_UPDATE = 8,
    OBJ_WRITE = 8,
    USR_CREATE = 16,
    USR_DELETE = 16,
    USR_REMOTE_INFO = 32,
    USR_LIST = 64,
    SYS_OPERATOR = 128,
    SYS_BACKUP = 256,
    SYS_RESTORE = 256,
    SYS_UPDATE_HSM = 512,
    NS_AUTHORIZATION = 1024,
    LOCAL_CRYPTO_PRT = 2048,
    VIRTUAL_X509_AUTH = 268435456,
    VIRTUAL_OTP_AUTH = 536870912,
    CHANGE_PWD_NEXT_TIME = 1073741824
}
/**
 * Versão do generate SVMK
 * @property {number} V1 Versão 1 da SVMK
 * @property {number} V2 Versão 2 da SVMK
 */
export declare enum SVMK_VERSION {
    V1 = 1,
    V2 = 2
}
/**
 * Tipo de TFA
 * @property {number} OTP - One Time Password TFA
 * @property {number} X509 - X.509 TFA
 */
export declare enum TFA_TYPE {
    OTP = 17,
    X509 = 18
}
